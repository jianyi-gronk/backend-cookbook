## 1. 事务

- **事务是指是程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，否则在每个操作中所作的所有更改都会被撤消**。可以通俗理解为：就是把多件事情当做一件事情来处理

#### 1.1 本地事务的完美解决方案（ ACID ）

- **事务处理几乎在每一个信息系统中都会涉及，它存在的意义是为了保证系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾，即数据状态的一致性**（ C，Consistency ）
- 按照数据库的经典理论，要达成这个目标，需要三方面共同努力来保障
  - 原子性（ Atomic ）：在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销
  - 隔离性（ Isolation ）：在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响
  - 持久性（ Durability ）：事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据
- 以上四种属性即事务的 “ACID” 特性，但对这种说法其实不是太认同，因为这四种特性并不正交，A、I、D 是手段，C 是目的，前者是因，后者是果，弄到一块去完全是为了拼凑个单词缩写

#### 1.2 场景

- 事务的概念虽然最初起源于数据库系统，但今天已经有所延伸，而不再局限于数据库本身了，所有需要保证数据一致性的应用场景，包括但不限于数据库、事务内存、缓存、消息队列、分布式存储，等等，都有可能会用到事务，后面使用 “数据源” 来泛指所有这些场景中提供与存储数据的逻辑设备，但是上述场景所说的事务和一致性含义可能并不完全一致，说明如下
  - 当一个服务只使用一个数据源时，通过 A、I、D 来获得一致性是最经典的做法，也是相对容易的。此时，多个并发事务所读写的数据能够被数据源感知是否存在冲突，并发事务的读写在时间线上的最终顺序是由数据源来确定的，这种事务间一致性被称为 “内部一致性”
  - 当一个服务使用到多个不同的数据源，甚至多个不同服务同时涉及多个不同的数据源时，问题就变得相对困难了许多。此时，并发执行甚至是先后执行的多个事务，在时间线上的顺序并不由任何一个数据源来决定，这种涉及多个数据源的事务间一致性被称为 “外部一致性”
- 外部一致性，比如有一个在线书店。每当一本书被成功售出时，需要确保以下三件事情被正确地处理：
  - 用户的账号扣减相应的商品款项
  - 商品仓库中扣减库存，将商品标识为待配送状态
  - 商家的账号增加相应的商品款项
- 外部一致性问题通常很难再使用 A、I、D 来解决，因为这样需要付出很大乃至不切实际的代价；但是外部一致性又是分布式系统中必然会遇到且必须要解决的问题，为此要转变观念，将一致性从 “是或否” 的二元属性转变为可以按不同强度分开讨论的多元属性，在确保代价可承受的前提下获得强度尽可能高的一致性保障，也正因如此，事务处理才从一个具体操作上的 “编程问题” 上升成一个需要全局权衡的 “架构问题”
- 我们可以归为 4 种场景：
  - **“单个服务使用单个数据源”（ 本地事务 ）**
  - **“单个服务使用多个数据源”（ 全局事务 ）**
  - **“多个服务使用单个数据源”（ 共享事务 ）**
  - **“多个服务使用多个数据源”（ 分布式事务 ）**

#### 1.3 非本地事务

- 系统拆分为分布式之后，事务概念边界逐渐扩大了， 跨库事务会遇到各种不可控制的问题，如个别节点宕机
- 而分布式事务的目的就是完成分布式一致性，常见方案比如 2PC（ 强一致性 ），3PC（ 强一致性 ），补偿事务（ 最终一致性 ），Saga 模式（ 最终一致性 ）

## 2. 一致性

- 在分布式系统中，经常需要解决的问题就是数据的复制。常见的场景如下：
  - 增加系统可用性，数据不能存在单个节点（ 主机 ）上，否则可能出现单点故障
  - 提高系统性能，通过负载均衡，让分布在不同地方的数据副本都能够为用户提供服务
- 所谓分布式一致性，就是对一个副本数据更新的同时，必须确保也能其他副本也能更新
- 为了解决该问题，最简单的方案，则是将更新操作阻塞，直到动作完成，但是会由此带来系统性能的急剧下降
- 所以如何保证系统一致性，又不影响系统性能，是需要考虑的，由此一致性级别（ 一致性模型 ）诞生

## 3. 一致性常用模型

- 主要分为强一致性和弱一致性
  ![image](https://img-blog.csdnimg.cn/6c3db4b17962425ba58ed00bf4557e9c.png)
- 在实际应用系统中，强一致性 是很难实现的，应用最广的是 弱一致性 中的 最终一致性

#### 3.1 强一致性

- 是最强的一致性模型，要求任何读取操作都能读取到最新的值
- 在强一致性系统中，只要某个数据的值有更新，这个数据的副本都要进行同步，以保证这个更新被传播到所有备份数据库中
- 在这个同步进程结束之后，オ允许服务器来读取这个数据
- 所以，强一致性一般会牺牲一部分延迟性，而且对于全局时钟的要求很高
- 比如 严格一致性、线性一致性 等都是强一致性

#### 3.2 弱一致性

- 这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不久承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（ 比如秒级别 ）后，数据能够达到一致状态

#### 3.3 最终一致性

- 最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态
- 它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型

#### 3.4 顺序一致性

- 有人说是强一致性中的一种，有人说是弱一致性中的一种，这里暂且归为弱一致性
- 当程序在各个处理机上并行运行时，所有处理机（ 或进程 ）对同一个存储器的访问是同样顺序进行的

#### 3.5 读写一致性

- 手机刷虎扑的时候经常遇到，回复某人的帖子然后想马上查看，但我刚提交的回复可能尚未到达从库，看起来好像是刚提交的数据丢失了，很不爽
- 在这种情况下，我们需要读写一致性，也称为读己之写一致性
- 它可以保证，如果用户刷新页面，他们总会看到自己刚提交的任何更新。它不会对其他用户的写入做出承诺，其他用户的更新可能稍等才会看到，但它保证用户自己提交的数据能马上被自己看到
- 如何实现读写一致性
  - 最简单的方案，对于某些特定的内容，都从主库读。举个例子，知乎个人主页信息只能由用户本人编辑，而不能由其他人编辑。因此，永远从主库读取用户自己的个人主页，从从库读取其他用户的个人主页。 如果应用中的大部分内容都可能被用户编辑，那这种方法就没用了。在这种情况下可以使用其他标准来决定是否从主库读取，例如可以记录每个用户最后一次写入主库的时间，一分钟内都从主库读，同时监控从库的最后同步时间，任何超过一分钟没有更新的从库不响应查询
  - 还有一种更好的方法是，客户端可以在本地记住最近一次写入的时间戳，发起请求时带着此时间戳。从库提供任何查询服务前，需确保该时间戳前的变更都已经同步到了本从库中。如果当前从库不够新，则可以从另一个从库读，或者等待从库追赶上来

#### 3.6 单调读

- 用户从某从库查询到了一条记录，再次刷新后发现此记录不见了，就像遇到时光倒流。如果用户从不同从库进行多次读取，就可能发生这种情况
- 单调读可以保证这种异常不会发生。单调读意味着如果一个用户进行多次读取时，绝对不会遇到时光倒流，即如果先前读取到较新的数据，后续读取不会得到更旧的数据。单调读比强一致性更弱，比最终一致性更强
- 实现单调读取的一种方式是确保每个用户总是从同一个节点进行读取（不同的用户可以从不同的节点读取），比如可以基于用户 ID 的哈希值来选择节点，而不是随机选择节点

#### 3.7 因果一致性

- 因果一致性往往发生在分区（ 也称为分片 ）的分布式数据库中
- 分区后，每个节点并不包含全部数据。不同的节点独立运行，因此不存在全局写入顺序
- 如果用户 A 提交一个问题，用户 B 提交了回答。问题写入了节点 A，回答写入了节点 B。因为同步延迟，发起查询的用户可能会先看到回答，再看到问题
- 为了防止这种异常，需要另一种类型的保证：因果一致性。 即如果一系列写入按某个逻辑顺序发生，那么任何人读取这些写入时，会看见它们以正确的逻辑顺序出现
- 因果一致性类似于 Java 内存模型里面的 happens-before 原则
- 因果一致性是一个听起来简单，实际却很难解决的问题
- 一种方案是应用保证将问题和对应的回答写入相同的分区。但并不是所有的数据都能如此轻易地判断因果依赖关系
- 如果有兴趣可以搜索向量时钟深入此问题

## 4. 举例

- 对于微信朋友圈的评论功能，哪种一致性模型更适用？为什么？
  - 最终一致性，因果一致性，读写一致性
  - 微信朋友圈评论主要由评论和后续回复组成
  - 对于评论，评论内容对评论者而言应该要保证读写一致性（ read-your-writes consistency ），即评论一旦发出，那么对于该评论者无论在手机、网页还是其它城市应该都能看到其之前写的评论
  - 而对于朋友圈可见的其它人来说，只要保证最终一致性（ eventual consistency ）就可以了（ 可能有时间要求 ），不同人的评论读取顺序无需和真实发生的顺序保持一致
  - 对于评论的后续回复。回复内容对于回复者而言应该要保证读写一致性（ read-your-writes consistency ）
  - 而其它朋友圈可见的人一样，评论和回复內容应该按顺序被读取到，重要的是对于某一条评论的评论必须显示在派生这条评论的原始评论之后，否则用户读起来会很混乱，此时就需要因果一致性
