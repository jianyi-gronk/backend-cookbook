## 1. 全局事务（ Global Transaction ）

- 与本地事务相对的是全局事务，有一些资料中也将其称为外部事务（ External Transaction ）

#### 1.1 强一致性场景事务

- 在本节里，全局事务被限定为一种适用于单个服务使用多个数据源场景的事务解决方案。请注意，理论上真正的全局事务并没有 “单个服务” 的约束，它本来就是 DTP（ Distributed Transaction Processing ）模型中的概念
- 但本节所讨论的内容是一种 **在分布式环境中仍追求强一致性的事务处理方案**，对于多节点而且互相调用彼此服务的场合（ 典型的就是现在的微服务系统 ）是极不合适的，今天它几乎只实际应用于单服务多数据源的场合中
- 为了避免与后续介绍的放弃了 ACID 的弱一致性事务处理方式相互混淆，所以这里的全局事务所指范围有所缩减，后续涉及多服务多数据源的事务，后面将称其为 “分布式事务”

#### 1.2 事务处理方案

- 因为基于单进程的 ACID 实现机制已经无法满足于新的分布式事务形式了，所以基于 ACID 的事务实现思路，由此最先衍生出了 XA、2PC、3PC 等事务模型和协议
- 因为 ACID 是强一致性，所以最开始基于 ACID 衍生出来的 XA、2PC、3PC 等也都是强一致性的

## 2. XA 分布式事务模型（ 强一致性 ）

- 1991 年，为了解决分布式事务的一致性问题，X/Open 组织（ 后来并入了 The Open Group ）提出了一套名为 X/Open XA 的处理事务架构

#### 2.1 提出背景

- 单机事务的解决方案由 ACID 完美解决，基本上形成了一套不可动摇的规范，而 XA 就是立志于解决分布式事务并形成一套统一的规范，也满足 ACID 原则
- 从单进程事务演变成多进程事务时，场景发生了改变，之前是一个人做一件事，现在变成了多个人协作做一件事了，一个人想对事务进行回滚还是提交 是很容易达成一致的，因为决定权在自己手上，不需要考虑其它人。但是如何协调多个人一起进行统一的操作就是一个难题了，所以此时就必须要有一个统一的人来协调多个节点的操作，达到多个节点操作的一致性
- **建立在每个节点都能保证自己节点的 ACID 特性前提上，XA 的核心目标是解决如何协调多个节点之间的操作一致性**。也就是如何在一个节点不满足事务要求需要回滚的时候，可以让大家一起回滚事务，如果大家都满足事务完成条件时，可以让大家一起提交事务

#### 2.2 XA 内容

- 该事务架构的核心内容是定义了全局的事务管理器和局部资源管理器之间的通信接口
  - 全局的事务管理器（ Transaction Manager ），用于协调全局事务
  - 局部的资源管理器（ Resource Manager ），用于驱动本地事务
- 事务的执行过程由协调者统一来决策，其它节点只需要按照协调者的指令来完成具体的事务操作即可
- **而协调者在协商各个事务节点的过程中、什么情况下决定集体提交事务，什么情况下又决定集体回滚事务，这里取决于 XA 事务模型里使用了哪种协商协议（ 2PC、3PC 等 ）**
- XA 接口是双向的，能在一个事务管理器和多个资源管理器之间形成通信桥梁，通过协调多个数据源的一致动作，实现全局事务的统一提交或者统一回滚，现在我们在 Java 代码中还偶尔能看见的 XADataSource、XAResource 这些名字都源于此

#### 2.2 JTA

- 不过，XA 并不是 Java 的技术规范（ XA 提出那时还没有 Java ），而是一套语言无关的通用规范，所以 Java 中专门定义了 JSR 907 Java Transaction API，基于 XA 模式在 Java 语言中的实现了全局事务处理的标准，这也就是我们现在所熟知的 JTA
- JTA 最主要的两个接口是：
  - 事务管理器的接口：javax.transaction.TransactionManager。这套接口是给 Java EE 服务器提供容器事务（ 由容器自动负责事务管理 ）使用的，还提供了另外一套 javax.transaction.UserTransaction 接口，用于通过程序代码手动开启、提交和回滚事务
  - 满足 XA 规范的资源定义接口：javax.transaction.xa.XAResource，任何资源（ JDBC、JMS 等等 ）如果想要支持 JTA，只要实现 XAResource 接口中的方法即可
- JTA 原本是 Java EE 中的技术，一般情况下应该由 JBoss、WebSphere、WebLogic 这些 Java EE 容器来提供支持，但现在 Bittronix、Atomikos 和 JBossTM（ 以前叫 Arjuna ）都以 JAR 包的形式实现了 JTA 的接口，称为 JOTM（ Java Open Transaction Manager ），使得我们能够在 Tomcat、Jetty 这样的 Java SE 环境下也能使用 JTA

#### 2.3 举例

- 现在，我们对本章的场景事例做另外一种假设：如果书店的用户、商家、仓库分别处于不同的数据库中，其他条件仍与之前相同，那情况会发生什么变化呢？假如你平时以声明式事务来编码，那它与本地事务看起来可能没什么区别，都是标个@Transactional 注解而已，但如果以编程式事务来实现的话，就能在写法上看出差异，伪代码如下所示：
  ```
  public void buyBook(PaymentBill bill) {
    userTransaction.begin();
    warehouseTransaction.begin();
    businessTransaction.begin();
    try {
      userAccountService.pay(bill.getMoney());
      warehouseService.deliver(bill.getItems());
      businessAccountService.receipt(bill.getMoney());
      userTransaction.commit();
      warehouseTransaction.commit();
      businessTransaction.commit();
    } catch(Exception e) {
      userTransaction.rollback();
      warehouseTransaction.rollback();
      businessTransaction.rollback();
    }
  }
  ```
  - 从代码上可看出，程序的目的是要做三次事务提交，但实际上代码并不能这样写，试想一下，如果在 businessTransaction.commit() 中出现错误，代码转到 catch 块中执行，此时 userTransaction 和 warehouseTransaction 已经完成提交，再去调用 rollback() 方法已经无济于事，这将导致一部分数据被提交，另一部分被回滚，整个事务的一致性也就无法保证了

## 3. 分布式事务协议 2PC

- 属于 强一致性 中的 线性一致性

#### 3.1 基础介绍

- 2PC（ two-phase commit protocol ）又称两阶段提交，2PC 是一个非常经典的 **强一致**、**中心化** 的原子提交协议
- 这里所说的中心化是指协议中有两类节点：一个是中心化协调者节点（ coordinator ）和 N 个参与者节点（ partcipant ），事务的提交过程分成了两个阶段来进行处理
- **2PC 是为了使基于分布式系统架构下的所有节点在进行事物处理过程中能够保持原子性和一致性而设计的算法**
- 目前绝大数关系型数据库（ 比如 mysql ）都是采用两阶段提交来完成事物处理的，而三阶段的思想更多的被借鉴扩散成其他的算法
- **在 2PC 中，只有协调者拥有超时机制**，即如果在一定时间内没有收到 partcipant 的消息则默认失败

#### 3.2 两个阶段

- 准备阶段：
  - 又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared
  - 这里所说的准备操作跟人类语言中通常理解的准备并不相同，**对于数据库来说，准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已**，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态
- 提交阶段：
  - 又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作
  - 对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载的操作

#### 3.2 核心思路

- **核心思想为参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作**
- 参与者全部同意，则 2PC 执行成功
  ![image](https://img-blog.csdnimg.cn/0d197c06526a4bbf99a137682a57ed13.png)
- 参与者任意一个不同意，则 2PC 都会执行失败
  ![image](https://img-blog.csdnimg.cn/216d8f5918b84a73b82ad60c3c9aab44.png)

#### 3.3 前提条件

- 两段式提交协议能够成功保证一致性还需要一些其他前提条件
  - 必须假设网络在提交阶段的短时间内是可靠的，即提交阶段不会丢失消息。同时也假设网络通信在全过程都不会出现误差，即可以丢失消息，但不会传递错误的消息，XA 的设计目标并不是解决诸如拜占庭将军一类的问题。两段式提交中投票阶段失败了可以补救（ 回滚 ），而提交阶段失败了无法补救（ 不再改变提交或回滚的结果，只能等崩溃的节点重新恢复 ），因而此阶段耗时应尽可能短，这也是为了尽量控制网络风险的考虑
  - 必须假设因为网络分区、机器崩溃或者其他原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态。由于在准备阶段已经写入了完整的重做日志，所以当失联机器一旦恢复，就能够从日志中找出已准备妥当但并未提交的事务数据，并向协调者查询该事务的状态，确定下一步应该进行提交还是回滚操作
- 上面所说的协调者、参与者都是可以由数据库自己来扮演的，不需要应用程序介入。协调者一般是在参与者之间选举产生的，而应用程序相对于数据库来说只扮演客户端的角色。两段式提交的交互时序如下图所示
  ![image](https://github.com/user-attachments/assets/72601c5e-2dec-4943-b6ec-59eb3f093f0c)

#### 3.4 具体流程

- 阶段一：提交事务请求
  - 协调者节点给每个参与者发送 Prepare 消息，询问是否可以执行提交操作，并开始等待各参与者节点的响应。
  - 参与者节点在本地执行询问发起为止的所有事务操作，并将 Undo 信息和 Redo 信息写入日志，此时事务还没有提交（ Undo 日志是记录修改前的数据，用于数据库回滚，Redo 日志是记录修改后的数据，用于提交事务后写入数据文件 ）
  - 各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个 ”同意” 消息；如果参与者节点的事务操作实际执行失败，则它返回一个 ”中止” 消息
- 阶段二：事务执行
  - 在该阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消
  - 当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，发送提交（ Commit ）消息；否则协调者将通知所有的参与者取消事务，发送回滚（ Rollback ）消息
  - 参与者在接收到协调者发来的消息后将执行响应的操作，并释放事务处理过程中使用的锁资源

#### 3.5 缺点

- 两段式提交原理简单，并不难实现，但有几个非常显著的缺点
- 单点问题：
  - 协调者在两段提交中具有举足轻重的作用，协调者等待参与者回复时可以有超时机制，允许参与者宕机，但参与者等待协调者指令时无法做超时处理
  - 一旦宕机的不是其中某个参与者，而是协调者的话，所有参与者都会受到影响。如果协调者一直没有恢复，没有正常发送 Commit 或者 Rollback 的指令，那所有参与者都必须一直等待
- 性能问题：
  - 两段提交过程中，所有参与者相当于被绑定成为一个统一调度的整体，期间要经过两次远程服务调用，三次数据持久化（ 准备阶段写重做日志，协调者做状态持久化，提交阶段在日志写入 Commit Record ），整个过程将持续到参与者集群中最慢的那一个处理操作结束为止，这决定了两段式提交的性能通常都较差
- 一致性风险：
  - 前面已经提到，两段式提交的成立是有前提条件的，当网络稳定性和宕机恢复能力的假设不成立时，仍可能出现一致性问题
  - 宕机恢复能力这一点不必多谈，1985 年 Fischer、Lynch、Paterson 提出了 “FLP 不可能原理”，证明了如果宕机最后不能恢复，那就不存在任何一种分布式协议可以正确地达成一致性结果。该原理在分布式中是与 “CAP 不可兼得原理“ 齐名的理论
  - 而网络稳定性带来的一致性风险是指，尽管提交阶段时间很短，但这仍是一段明确存在的危险期，如果协调者在发出准备指令后，根据收到各个参与者发回的信息确定事务状态是可以提交的，协调者会先持久化事务状态，并提交自己的事务，如果这时候网络忽然被断开，无法再通过网络向所有参与者发出 Commit 指令的话，就会导致部分数据（ 协调者的 ）已提交，但部分数据（ 参与者的 ）既未提交，也没有办法回滚，产生了数据不一致的问题

## 4. 分布式事务协议 3PC

- 属于 强一致性 中的 线性一致性
- 为了缓解两段式提交协议的一部分缺陷，具体地说是协调者的单点问题和准备阶段的性能问题，后续又发展出了 “三段式提交” 协议

#### 4.1 基础介绍

- 3PC，全称 “three phase commit”，是 2PC 的改进版
  - 三阶段提交协议在协调者和参与者中都引入 **超时机制**，而 2PC 只有协调者有超时机制
  - 并且把两阶段提交协议的 **准备阶段拆分成了两步**：询问，然后再锁资源（ 分别称为 CanCommit、PreCommit ），最后真正提交（ 改称为 DoCommit 阶段 ）
- 其中，新增的 CanCommit 是一个询问阶段，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成
- PreCommit 是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的
  ![image](https://img-blog.csdnimg.cn/3e5c736ca1be4a8f858d2ebcb1d8ae41.png)
- 虽然阶段了协调者故障导致阻塞的问题，但是数据不一致的风险还是存在，而且性能因为多了一次网络交互，反而变得更慢。正是因为这些原因 3PC 也一直是处于一个理论的模型，而没有实践下去

#### 4.2 准备阶段拆分理由

- 将准备阶段一分为二的理由是这个阶段是重负载的操作，一旦协调者发出开始准备的消息，每个参与者都将马上开始写重做日志，它们所涉及的数据资源即被锁住，如果此时某一个参与者宣告无法完成提交，相当于大家都白做了一轮无用功
- 所以，增加一轮询问阶段，如果都得到了正面的响应，那事务能够成功提交的把握就比较大了，这也意味着因某个参与者提交时发生崩溃而导致大家全部回滚的风险相对变小

#### 4.2 具体流程

- 阶段一：事务询问阶段（ can commit ）
  - 协调者进行事务询问，协调者向所有的参与者发送一个包含事务内容的 CanCommit 请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应
  - 参与者向协调者反馈事务询问 参与者在接收到来自协调者的包含了事务内容的 CanCommit 请求后，正常情况下，如果自身认为可以顺利执行事 务，则反馈 Yes 响应， 并进入预备状态，否则反馈 No 响应
  - 和 2PC 阶段不同的是，此时参与者没有锁定资源，没有写 Undo，Redo，执行回滚日志，所以回滚代价低
- 阶段二：事务准备阶段 （ pre commit ）
  - 如果参与者都返回 Yes，那么就发送 Prepare 消息，所有参与者本地会执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中，如果执行成功，则返回 Ack
  - 如果有参与者返回 No，那么就向所有参与者提交终止（ abort ）事务的请求
  - 注意
    - 如果协调者在发送 Prepare 消息的时候，等待反馈超时，也会向参与者提交终止事务的请求
    - 如果参与者等待协调者请求过程中超时，参与者也会中断事务
- 阶段三：执行事务阶段（ do commit ）
  - 如果所有发送 Prepare 都返回成功，那么此时变为执行事务阶段，向参与者发送 DoCommit 事务的消息，否则回滚事务
  - 参与者需要反馈事务提交结果，如果都成功，则完成事务；如果有参与者失败，则向所有参与者提交终止（ abort ）事务的请求
  - 注意
    - 在此阶段参与者如果在一定时间内没有收到 DoCommit 消息，触发超时机制，会自己提交事务
    - 此番处理的逻辑是，能够进入此阶段，说明在事务询问阶段所有节点都是好的。所以即使在提交的时候部分失败，有理由相信，此时大部分节点都是好的，是可以提交的
- 三段式提交的操作时序如下图所示
  ![image](https://github.com/user-attachments/assets/8910afd7-b03b-438e-8334-9ad8c0c21725)

#### 4.3 优缺点

- 优点
  - 超时机制 降低了阻塞 和 解决了协调者单点故障问题
    - 参与者返回 CanCommit 请求的响应后，等待第二阶段指令，若 等待超时 或 协调者宕机，则自动 Abort
    - 参与者返回 PreCommit 请求的响应后，等待第三阶段指令，若 等待超时 或 协调者宕机，则自动 commit 事务
- 缺点
  - 数据不一致问题仍然是存在的
    - 比如第三阶段协调者发出了 Abort 请求，而此时因网络问题，有部分参与者直至超时都未能收到协调者的 Abort 指令的话，这些参与者将会自动 commit，错误地提交事务，这就产生了不同参与者之间数据不一致的问题
- 性能变化（ 是否劣化需要分场景讨论 ）
  - 新增 CanCommit 询问阶段去评估该事务是否有可能顺利完成，因此在事务需要回滚的场景中，三段式的性能通常是要比两段式好很多的
  - 但在事务能够正常提交的场景中，2PC 需要锁定资源，并且时间取决于最慢的一个参与者，在 3PC 里这样的情况并未发生任何变化，3PC 也还是需要锁定资源，同样也是必须要等待所有参与者响应才能进行下一步流程，反而 3PC 增加了一个阶段的协商通讯，这就使得 3PC 通信成本更高，性能反而会更差

## 5. 强一致性方案缺点

- 最终经过理论和实践，不管是用 2PC 还是 3PC 协议始终都存在数据不一致的风险，而且因为每个参与者的本地事务的锁都需要等到整体事务结束才能真正的释放，所以 XA 的性能问题也是一直被人诟病
- 强一致事务模型是否还能完美的从 单机事务环境 迁移到 分布式事务环境，到这里开始被人们怀疑，因为无论怎么优化和增加协商的次数都还是会存在数据不一致的问题，而且强一致事务模型性能实在令人堪忧
- 直到 CAP 的出现才让大家明白，在分布式环境下完美的强一致是非常难实现的，于是人们开始考虑弱一致性的解决方案
- 但是并非所有分布式系统、应用场景都需要放弃强一致性，对于某些特定的业务需求，仍然需要保持强一致性，比如银行等涉及钱财的场景
