## 1. 分布式事务（ Distributed Transaction ）

#### 1.1 前提提要

- 分布式事务这里特指多个服务同时访问多个数据源的事务处理机制。请注意它与 DTP 模型中 “分布式事务” 的差异，DTP 模型所指的 “分布式” 是相对于数据源而言的，并不涉及服务，而这里拆分一部分作为 “全局事务”。本节所指的 “分布式” 是相对于服务而言的，如果严谨地说，它更应该被称为 “在分布式服务环境下的事务处理机制”

#### 1.2 最终一致性方案

- 在 2000 年以前，人们曾经寄希望于 XA 的事务机制可以在本节所说的分布式环境中也能良好地应用，但这个美好的愿望今天已经被 CAP 理论彻底地击碎了
- CAP 的出现才让大家明白，在分布式环境下完美的强一致是非常难实现的，人们开始思考是继续追求强一致性，还是去追求可用性
- 于是基于 BASE 理论 倡导的最终一致性的分布式事务实现方案逐渐兴起，比如有 基于消息队列实现事务、AT、TCC、SAGA 等模式实现分布式事务最终一致性的解决方案

## 2. 可靠事件队列

- 可靠事件队列 是在上节提出 BASE 的论文《Base: An Acid Alternative》的作者 Dan Pritchett 提出的

#### 2.1 举例介绍

- 继续以之前有场景事例来解释 Dan Pritchett 提出的 “可靠事件队列” 的具体做法，目标仍然是交易过程中正确修改账号、仓库和商家服务中的数据，下图列出了修改过程的时序图
  ![image](https://github.com/user-attachments/assets/cff64a65-ee2e-4c80-8b9e-cd24baf5dc06)
- 最终用户向 Fenix's Bookstore 发送交易请求：购买一本价值 100 元的《深入理解 Java 虚拟机》
- Fenix's Bookstore 首先应对用户账号扣款、商家账号收款、库存商品出库这三个操作有一个出错概率的先验评估，根据出错概率的大小来安排它们的操作顺序，这种评估一般直接体现在程序代码中，有一些大型系统也可能会实现动态排序。譬如，根据统计，最有可能的出现的交易异常是用户购买了商品，但是不同意扣款，或者账号余额不足；其次是仓库发现商品库存不够，无法发货；风险最低的是收款，如果到了商家收款环节，一般就不会出什么意外了。那顺序就应该安排成最容易出错的最先进行，即：账号扣款 → 仓库出库 → 商家收款
- 账号服务进行扣款业务，如扣款成功，则在自己的数据库建立一张消息表，里面存入一条消息：“事务 ID：某 UUID，扣款：100 元（状态：已完成），仓库出库《深入理解 Java 虚拟机》：1 本（状态：进行中），某商家收款：100 元（状态：进行中）”，注意，这个步骤中“扣款业务”和“写入消息”是使用同一个本地事务写入账号服务自己的数据库的
- 在系统中建立一个消息服务，定时轮询消息表，将状态是“进行中”的消息同时发送到库存和商家服务节点中去（也可以串行地发，即一个成功后再发送另一个，但在我们讨论的场景中没必要）。这时候可能产生以下几种情况
  - 商家和仓库服务都成功完成了收款和出库工作，向用户账号服务器返回执行结果，用户账号服务把消息状态从“进行中”更新为“已完成”。整个事务宣告顺利结束，达到最终一致性的状态
  - 商家或仓库服务中至少一个因网络原因，未能收到来自用户账号服务的消息。此时，由于用户账号服务器中存储的消息状态一直处于“进行中”，所以消息服务器将在每次轮询的时候持续地向未响应的服务重复发送消息。这个步骤的可重复性决定了所有被消息服务器发送的消息都必须具备幂等性，通常的设计是让消息带上一个唯一的事务 ID，以保证一个事务中的出库、收款动作会且只会被处理一次
  - 商家或仓库服务有某个或全部无法完成工作，譬如仓库发现《深入理解 Java 虚拟机》没有库存了，此时，仍然是持续自动重发消息，直至操作成功（譬如补充了新库存），或者被人工介入为止。由此可见，可靠事件队列只要第一步业务完成了，后续就没有失败回滚的概念，只许成功，不许失败
  - 商家和仓库服务成功完成了收款和出库工作，但回复的应答消息因网络原因丢失，此时，用户账号服务仍会重新发出下一条消息，但因操作具备幂等性，所以不会导致重复出库和收款，只会导致商家、仓库服务器重新发送一条应答消息，此过程重复直至双方网络通信恢复正常
  - 也有一些支持分布式事务的消息框架，如 RocketMQ，原生就支持分布式事务操作，这时候上述情况 2、4 也可以交由消息框架来保障

#### 2.2 最大努力交付

- 以上这种靠着持续重试来保证可靠性的解决方案谈不上是 Dan Pritchett 的首创或者独创，它在计算机的其他领域中已被频繁使用，也有了专门的名字叫作 “最大努力交付”，譬如 TCP 协议中未收到 ACK 应答自动重新发包的可靠性保障就属于最大努力交付
- 而可靠事件队列还有一种更普通的形式，被称为 “最大努力一次提交”，指的就是将最有可能出错的业务以本地事务的方式完成后，采用不断重试的方式（ 不限于消息系统 ）来促使同一个分布式事务中的其他关联业务全部完成

#### 2.3 缺陷

- 可靠消息队列虽然能保证最终的结果是相对可靠的，过程也相对简单，但整个过程完全没有任何隔离性可言
- 有一些业务中隔离性是无关紧要的，但有一些业务中缺乏隔离性就会带来许多麻烦。譬如在本章的场景事例中，缺乏隔离性会带来的一个显而易见的问题便是 “超售”：完全有可能两个客户在短时间内都成功购买了同一件商品，而且他们各自购买的数量都不超过目前的库存，但他们购买的数量之和却超过了库存
- 如果这件事情处于刚性事务，且隔离级别足够的情况下是可以完全避免的，譬如，以上场景就需要 “可重复读” 的隔离级别，以保证后面提交的事务会因为无法获得锁而导致失败，但用可靠消息队列就无法保证这一点
- 如果业务需要隔离，那架构师通常就应该重点考虑其他方案，例如 TCC，该方案天生适合用于需要强隔离性的分布式事务中

## 3. AT 分布式事务模型（ 最终一致性 ）

#### 3.1 基础介绍

- AT 模式同样是分阶段提交的事务模型，不过缺弥补了 XA 模型中资源锁定周期过长的缺陷
- AT 模式是一种实现分布式事务的可靠性和一致性的协议和模式，旨在确保分布式系统中的多个参与者能够按照一致的方式执行和提交事务
  - 参与者，通常指服务或数据库，也称为 RM（ Resource Manager ），分布式事务中的资源管理器
- AT 模式通过两阶段提交的方式，在准备阶段协调参与者的状态，然后在提交阶段根据参与者的响应来决定是否进行全局提交或全局回滚
- **和 XA 核心不同的地方在于 AT 模式在执行完 sql 之后会直接提交事务，而不是进行等待，在执行的同时 RM 会拦截本次执行，记录更新前后的快照到数据库的 undo_log 中**

#### 3.2 详细阶段

- 阶段一 RM 的工作：
  - 注册分支事务
  - 记录 undo-log（ 数据快照 ）
  - 执行业务 sql 并提交
  - 报告事务状态
- 阶段二提交时 RM 的工作：
  - 删除 undo-log 即可
- 阶段二回滚时 RM 的工作：
  - 根据 undo-log 回复数据到更新前

#### 3.3 AT 模式特性

- 与 XA 模式最大的区别是：
  - XA 模式一阶段不提交事务，锁定资源，而 AT 模式一阶段直接提交，不锁定资源
  - XA 模式依赖数据库机制实现回滚，而 AT 模式利用数据快照实现数据回滚
  - XA 模式强一致，而 AT 模式最终一致
- 优点：
  - 一阶段完成直接提交事务，释放数据库资源，性能比较好
  - 利用全局锁实现读写隔离
  - 没有代码侵入，框架自动完成回滚和提交
- 缺点：
  - 两阶段之间属于软状态，属于最终一致性
  - 框架的快照功能会影响性能，但比 XA 模式要好很多

## 4. TCC 分布式事务模型（ 最终一致性 ）

- 是由数据库专家 Pat Helland 在 2007 年撰写的论文《Life beyond Distributed Transactions: An Apostate’s Opinion》中提出

#### 4.1 基础介绍

- TCC，即 Try-Confirm-Cancel，是一种基于补偿思想的分布式事务解决方案，用于实现最终一致性，与 AT 模式非常相似，每阶段都是独立事务，不同的是 TCC 通过人工编码来实现数据恢复
- TCC 的核心思想是将一个复杂的业务操作拆解为多个子操作，并在每个子操作上进行 Try、Confirm 和 Cancel 的处理
- 由于该方案将一个业务操作拆分成了多个子操作，因此可以更好地控制整个系统的事务并发度，以及减少事务的竞争和冲突，从而提高系统的性能和可用性
- **和 XA 核心不同的地方在于 TCC 模式使用的是 “预留”，而 XA 使用的是 “日志”（ 预留机制强调在事务执行之前锁定资源，而日志机制则强调在事务执行过程中对操作进行记录和分析 ）**
- TCC 解决方案主要包括三个阶段
  - Try：尝试业务执行，该阶段完成所有业务的一致性检查，预留必要的业务资源
  - Confirm：确定业务执行，该阶段真正执行业务，因为 try 已经执行了资源预留，所以此阶段不会再检查数据，此阶段的操作需要满足幂等
  - Cancel：取消业务执行，该阶段释放 try 预留的业务资源，此阶段也需要满足幂等
- TCC 解决分布式事务问题的主要思路是：
  - 将业务操作拆解成多个 try-confirm-cancel 三阶段操作，每个阶段都是原子性操作
  - 在执行业务操作前，先进行 try 操作，检查所需资源是否可用，如果可用，则锁定这些资源，准备执行 confirm 操作
  - 在执行 confirm 操作时，对所需要的资源进行实际的操作，同时释放预留的资源，完成操作
  - 如果 try 操作失败，则回滚之前预留的资源和数据（ 执行 cancel 操作 ），维护数据的最终一致性
- TCC 方案执行流程：
  ![image](https://img-blog.csdnimg.cn/a9b7fd9cf83a46d394a449eb69f5872d.png)

#### 4.2 优缺点

- 优点：
  - 高性能：相比于 XB 模型一阶段完成直接提交事务，释放数据库资源；相比于 AT 模型，无需生成快照，无需使用全局锁
  - 高可用性：由于 TCC 采用了乐观锁的方式，不涉及资源锁定的等待阻塞，降低了事务竞争和冲突，提高了系统的可用性
  - 灵活性：TCC 允许在 Try 阶段进行资源预留和业务检查，根据实际情况进行决策，可以适应不同的业务需求和规则；并且不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库
  - 最终一致性：和 XB 相比，TCC 采用了补偿机制来实现最终一致性，在发生异常或失败的情况下，TCC 通过执行 Cancel 阶段中定义的补偿操作来回滚之前的操作，从而达到一致性的目标
- 缺点：
  - 开发复杂度增加：TCC 要求将一个复杂业务操作拆分为多个子操作，并编写 Try、Confirm 和 Cancel 逻辑，增加了开发难度和代码量
  - 幂等性要求高：由于 TCC 可能会进行多次尝试和回滚，要求业务操作具备高度的幂等性，以确保在重试或回滚时不会产生副作用
  - 业务侵入性：TCC 需要在业务系统中嵌入 Try、Confirm 和 Cancel 逻辑，对业务代码的侵入性较大

## 5. SAGA 分布式事务模型（ 最终一致性 ）

#### 5.1 基础介绍

- SAGA 是一种支持最终一致性的分布式事务解决方案。它将一个全局事务拆分为多个局部事务，并通过协调器来管理和协调这些局部事务的执行顺序，从而实现了分布式事务的一致性
- SAGA 方案由以下三个部分组成：协调器、局部事务以及补偿机制
  - 协调器：
    - 是 SAGA 方案的核心组件，用于管理并协调分布式事务中的各个局部事务。在一个分布式事务中，协调器掌握着所有局部事务的执行顺序和状态，并根据当前的执行结果来决定下一步的操作。协调器的工作流程如下：
      - 确定全局事务的类型，例如基于请求-响应的事务模型或者基于事件驱动的事务模型
      - 确定完成每个局部事务所需的前置条件和后置条件
      - 根据局部事务的依赖关系和前置条件，生成局部事务执行序列
      - 逐一执行局部事务，并根据当前的执行结果来决定是否进行下一步操作
  - 局部事务：
    - 是 SAGA 方案中的基本单位，它表示分布式事务中的每个子操作
    - 在 SAGA 方案中，每个局部事务都有一个对应的补偿操作，用于撤销该事务的执行结果
    - 这允许 SAGA 方案在出现错误或异常情况时进行故障恢复或者回滚操作
  - 补偿机制
    - 是 SAGA 方案的一个关键特性，用于在系统发生错误或失败时进行故障恢复或回滚操作
    - 在 SAGA 方案中，每个局部事务都对应着一个补偿操作，用于原子性地将该事务的执行结果撤销
    - 当一个局部事务执行失败或超时时，协调器会根据局部事务的执行状态和补偿操作来判断应该采取何种措施
    - 如果局部事务已经完成并且存在对应的补偿操作，则协调器会触发相应的补偿操作；否则，协调器会直接回滚全局事务

#### 5.2 优缺点

- 优点：
  - 事务参与者可以基于事件驱动实现异步调用，吞吐高
  - 一阶段直接提交事务，无锁，性能好、
  - 不用编写 TCC 中的三个阶段，实现简单
- 缺点：
  - 软状态持续时间不确定，时效性差
  - 没有锁，没有事务隔离，会有脏写
