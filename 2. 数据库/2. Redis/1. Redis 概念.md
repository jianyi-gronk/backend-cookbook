## 1. 什么是 Redis

- 是一个开源，内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理，是使用 ANSI C 语言编写的
- 是个非关系型数据库，即 key-value 数据库
- 内置复制、Lua 脚本、LRU 收回、事务以及不同级别磁盘持久化功能
- 同时通过 Redis Sentinel 提供高可用，通过 Redis Cluster 提供自动分区
- 由于是基于内存，所以特点非常明显，Redis 的性能和速度比较快，但它的存储能力较低
- Redis 通常用于处理实时数据、缓存、队列等，比如在电商网站中，我们可以用 Redis 作为缓存技术，用于存储商品信息、浏览量信息、评论数、热搜 TOP10 等

![image](https://img-blog.csdnimg.cn/0dfa8b5b84584efeac1391be0e61abcf.png)

- Redis 缓存
  https://blog.csdn.net/qq_22918243/article/details/128282453
  https://blog.51cto.com/u_16099302/6548467
- Redis 缓冲
  https://blog.csdn.net/qq_44226094/article/details/130542163
  https://zhuanlan.zhihu.com/p/652951708

## 2. Redis 特点

- 高性能：
  - Redis 是一个基于 **内存** 的数据存储系统，它的读写速度非常快。相比于传统的关系型数据库，Redis 可以提供更高的性能和吞吐量。这使得它非常适合用作缓存，可以显著提升应用程序的响应速度和吞吐量
  - 当需要读取数据时，Redis 会先从内存中查询数据。如果数据不存在或已过期，它会根据配置的持久化方式（ 如 RDB 或 AOF ）从磁盘上加载数据到内存中，然后返回给客户端
- 内置数据结构：
  - Redis 不仅仅是一个简单的键值存储，它还支持丰富的数据结构，如字符串、哈希表、列表、集合和有序集合等
  - 这使得开发人员可以更方便地利用这些数据结构来解决各种问题，从而简化了应用程序的开发过程
- 持久化支持：
  - 尽管 Redis 是一个基于内存的数据库，但它提供了持久化的支持，可以将数据保存到磁盘上，以防止数据丢失
  - 这使得 Redis 可以在应用程序重启后快速恢复数据，并且可以根据需求进行灵活的配置，以平衡性能和数据安全性
- 高可用性：
  - Redis 提供了主从复制和集群功能，可以实现数据的备份和故障恢复。通过设置主从复制，可以将写操作分发到多个 Redis 实例，提高系统的可用性和容错能力。而 Redis 集群则可以在多个节点之间分布数据，进一步提高系统的可靠性和扩展性

## 3. Redis 基础数据结构

- Redis 支持 字符串、列表、集合、有序集合、哈希表，位图，hyperloglogs 等数据类型
- [底层原理 1](https://www.modb.pro/db/178661)，[底层原理 2](https://www.zhihu.com/tardis/bd/art/487583440?source_id=1001)

#### 3.1 String（ 字符串 ）

- String 类型是 Redis 的最基础的数据结构，也是最经常使用到的类型。其他的 4 种类型多多少少都是在字符串类型的基础上构建的，所以 String 类型是 Redis 的基础
- String 类型的值最大能存储 512 MB
- String 类型是二进制安全的，意思是 Redis 的 String 可以包含任何数据，可以是：简单的字符串、复杂的字符串（ xml、json ）、数字（ 整数、浮点数 ）、二进制（ 图片、音频、视频 ）等

#### 3.2 List（ 列表 ）

- List 类型是用来存储多个有序的字符串的，列表当中的每一个字符看做一个元素
- 一个列表当中可以存储有一个或者多个元素，Redis 的 List 支持最多存储 2^32 - 1 个元素
- Redis 可以从列表的两端进行插入和弹出元素，支持读取指定范围的元素集，或者读取指定下标的元素等操作。List 是一种比较灵活的链表数据结构，它可以充当队列或者栈的角色
- List 是链表型的数据结构，所以它的元素是有序的，而且列表内的元素是可以重复的

#### 3.3 Set（ 集合 ）

- Set 类型和 List 列表类型类似，都可以用来存储多个字符串元素的集合
- 但是和 List 不同的是 Set 集合当中不允许重复的元素。而且 Set 集合当中元素是没有顺序的，不存在元素下标
- Set 类型是使用哈希表构造的，因此复杂度是 O(1)，它支持集合内的增删改查，并且支持多个集合间的交集、并集、差集操作。可以利用这些集合操作，解决程序开发过程当中很多数据集合间的问题

#### 3.4 Sorted Set（ 有序集合 ）

- 它保留了集合中元素不能重复的特性，但是不同的是，有序集合给每个元素多设置了一个分数，利用该分数作为排序的依据

#### 3.5 Hash（ 哈希 ）

- Hash 是一个键值对（ key-value ）集合，它是一个 field 和 value 的映射表，而 Redis 本身就是一个 key-value 型数据库，因此 Hash 数据结构相当于在 value 中又套了一层 key-value 型数据
- Hash 数据结构特别适合存储关系型对象

## 4. Redis 应用场景

#### 3.6 String（ 字符串 ）

- 缓存功能：
  - String 字符串是最常用的数据类型，不仅仅是 Redis，各个语言都是最基本类型，因此，利用 Redis 作为缓存，配合其它数据库作为存储层，利用 Redis 支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力
- 计数器：
  - 许多系统都会使用 Redis 作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存
- 统计多单位的数量：
  - 比如根据不同的 uid 更新 count 数量
- 共享用户 Session：
  - 用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存 Cookie，这两种方式做有一定弊端
    - 每次都重新登录效率低下
    - Cookie 保存在客户端，有安全隐患
  - 这时可以利用 Redis 将用户的 Session 集中管理，在这种模式只需要保证 Redis 的高可用，每次用户 Session 的更新和获取都可以快速完成，大大提高效率

#### 3.7 List（ 列表 ）

- 消息队列：
  - Redis 的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计
  - 比如，数据的生产者可以通过 Lpush 命令从左边插入数据，多个数据消费者，可以使用 BRpop 命令阻塞的列表尾部的数据
- 文章列表或者数据分页展示的应用：
  - 比如，常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用 Redis 的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能，大大提高查询效率

#### 3.8 Set（ 集合 ）

- 归并相似点：
  - 比如我们博客网站常常使用到的兴趣标签，把一个个有着相同爱好，关注类似内容的用户利用一个标签把他们进行归并
  - 还有比如共同好友功能，共同喜好，或者可以引申到二度好友之类的扩展应用
- 统计网站的独立 IP：
  - 利用 Set 集合当中元素唯一性，可以快速实时统计访问网站的独立 IP

#### 3.9 Sorted Set（ 有序集合 ）

- 排行榜：
  - 例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等
- 带权重的队列：
  - 比如普通消息的 score 为 1，重要消息的 score 为 2，然后工作线程可以按 score 的倒序来获取工作任务，让重要的任务优先执行

#### 3.10 Hash（ 哈希 ）

- 用来存储关系型数据库中表记录：
  - 是 Redis 中哈希类型最常用的场景，一条记录作为一个 key-value，把每列属性值对应成 field-value 存储在哈希表当中，然后通过 key 值来区分表当中的主键
- 经常被用来存储用户相关信息：
  - 优化用户信息的获取，不需要重复从数据库当中读取，提高系统性能

## 4. 特殊数据类型

#### 4.1 Geospatial（ 地理位置 ）

- Geospatial 将指定的地理空间位置（ 纬度、经度、名称 ）添加到指定的 key 中
- 这些数据将会存储到 Sorted Set 这样的目的是为了方便使用 GEORADIUS 或者 GEORADIUSBYMEMBER 命令对数据进行半径查询等操作
- Sorted Set 使用一种称为 Geohash 的技术进行填充。经度和纬度的位是交错的，以形成一个独特的 52 位整数（ Geohash 技术，使用二分法构建唯一的二进制串 ）
- Sorted Set 的 double score 可以代表一个 52 位的整数，而不会失去精度
- 有效的经度是 -180 度到 180 度，有效的纬度是 -85.05112878 度到 85.05112878 度

#### 4.2 Geospatial 应用场景

- 查看附近的人
- 微信位置共享
- 地图上直线距离的展示

#### 4.3 HyperLogLog（ 基数 ）

- HyperLogLog 是用来做基数统计的，输入的提及无论多么大，HyperLogLog 使用的空间总是固定的 12KB ，利用 12KB，它可以计算 2^64 个不同元素的基数，非常节省空间，但缺点是估算的值，可能存在 0.81% 的误差

#### 4.4 HyperLogLog 应用场景

- 网页统计 UV（ 浏览用户数量，同一天同一个 ip 多次访问算一次访问，目的是计数，而不是保存用户 ）
  - 传统的方式，set 保存用户的 id，可以统计 set 中元素数量作为标准判断
  - 但如果这种方式保存大量用户 id，会占用大量内存，我们的目的是为了计数，而不是去保存 id

#### 4.5 Bitmaps（ 位存储 ）

- Redis 提供的 Bitmaps 这个数据结构可以实现对位的操作
- Bitmaps 本身不是一种数据结构，实际上就是字符串，但是它可以对字符串的位进行操作
- 可以把 Bitmaps 想象成一个以位为单位数组，数组中的每个单元只能存 0 或者 1，数组的下标在 bitmaps 中叫做偏移量。单个 bitmaps 的最大长度是 512MB，即 2^32 个比特位

#### 4.6 Bitmaps 应用场景

- 有关两种状态的统计都可以使用 bitmaps，例如，统计用户活跃与非活跃数量、登录与非登录、上班打卡 等等

## 5. 单线程与多线程（ [详细](https://zhuanlan.zhihu.com/p/646111642) ）

#### 5.1 基础介绍

- Redis 的版本很多，比如 3.x、4.x、6.x 等，版本不同，架构不同，从 4 开始慢慢支持多线程的，直到 Redis 6 / 7 后才稳定
  - 3.x 版本，最早的版本，单线程
  - 4.x 版本，严格意义上来说不是单线程，负责处理客户端请求的线程是单线程，并且加了一些多线程（ 比如：异步删除 等 ）
  - 2020 年 5 月版本的 6.0.x 后及 2022 年出的 7.0 版本后，用一种全新的多线程来解决问题，全面支持多线程

#### 5.2 单线程

- Redis 的单线程主要是指 Redis 网络 IO 和键值对读写是由一个线程来完成的，Redis 在处理客户端的请求时包括获取（ Socket 读 ）、解析、执行、内容返回（ Socket 写 ）等都是由一个顺序串行的主线程处理，这是 Redis 对外提供键值对存储服务的主要流程

![image](https://img-blog.csdnimg.cn/a21aa6a2b2964614b04a7b77371220b8.png)

#### 5.3 为什么 Redis 3.x 采用单线程

- 使用单线程模型使 Redis 开发和维护更简单，单线程模型方便开发和调试
- 因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，而且单线程不会导致死锁问题的发生
- 使用单线程模式也能并发处理多客户端的请求，Redis 使用 IO 多路复用功能来监听多个 socket 连接客户端，这样可以使用一个线程来处理多个请求，减少线程切换带来额开销，同时也避免了 IO 阻塞操作
- 对于 Redis 来说，主要性能瓶颈是内存和网络带宽，不是 CPU

#### 5.4 Redis 4.x 为什么又逐渐加入了多线程特性

- 硬件的发展
  - CPU 并不是 Redis 的瓶颈，通常 Redis 要不受内存限制要不受网络限制，但是随着计算机硬件的发展，多核 CPU 已经成为常态，为了更大限度的利用 CPU
- 单线程的缺点
  - Redis 使用单线程也是有一定缺点的，比较典型的就是使用 del 指令删除大 key 数据时（ 比如包含了几万个元素的 hash 集合 ），del 指令就会造成主线程卡顿，如果再加上高并发场景就更加严重
  - 所以引入了 惰性删除（ 异步删除 ） 有效避免 Redis 主线程卡顿
    - 惰性删除 的本质就是把某些 cost（ 主要是 时间复制度，占用主线程 cpu 时间片 ）较高删除操作，从 Redis 主线程剥离让 BIO 子线程来处理，极大地减少主线阻塞时间，从而减少删除导致性能和稳定性问题
    - 主要是 del 操作，此外例如 flushdb 还有 flushall 在数据量达到一定程度时，也会造成卡顿
  - Redis 除了上面操作，其他功能，比如持久化 RDB 和 AOF、集群数据同步 等操作，也是由额外的线程执行的
  - Redis 命令的工作线程是单线程的，但是对于整个 Redis 来说，是多线程
  - **虽然引入了多个线程来实现 异步惰性删除，持久化 等功能，但其处理读写请求的仍然只有一个线程，所以仍然是狭义单线程**

#### 5.5 Redis 6 / 7 为什么叫真正意义的多线程

- ​ Redis 之前一直被大家熟知的就是它的单线程架构，虽然有些命令操作可以用后台线程或子进程执行（ 比如 数据删除、快照生成、AOF 重写 ），但是从网络 IO 处理到实际的读写命令处理，都是由单个线程完成的
- 随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 IO 的处理上，也就是说，单个主线程处理网络请求的速度跟不上底层网络硬件的速度。采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度，Redis 6 / 7 就是采用的这种方法
- 但是，Redis 的多 IO 线程只是用来处理网络请求的，对于读写操作命令 Redis 仍然使用单线程来处理。这是因为，Redis 处理请求时，网络处理经常是瓶颈，通过多个 IO 线程并行处理网络操作，可以提升实例的整体处理性能。而继续使用单线程执行命令操作，就不用为了保证 Lua 脚本、事务的原子性，额外开发多线程互斥加锁机制了（ 不管加锁操作处理 ），这样一来，Redis 线程模型实现就简单了
- Redis 只是将 I/O 读写变成了多线程，而命令的执行依旧是由主线程串行执行的

## 6. Redis 6 / 7 特性

#### 6.1 主线程和 IO 线程的四个阶段（ Redis 6 之前 ）

- 阶段一：服务端和客户端建立 Socket 连接，并分配处理线程
  - 首先，主线程负责接收建立连接请求，当有客户端请求和实例建立 Socket 连接时，主线程会创建和客户端的连接，并把 Socket 放入全局等待队列中。紧接着，主线程通过轮询方法把 Socket 连接分配给 IO 线程
- 阶段二：IO 线程读取并解析请求
  - 主线程一旦把 Socket 分配给 IO 线程，就会进入阻塞状态，等待 IO 线程完成客户端请求读取和解析。因为有多个 IO 线程在并行处理，所以该过程执行很快
- 阶段三：主线程执行请求操作
  - 等到 IO 线程解析完请求，主线程以单线程的方式执行命令操作
- 阶段四：IO 线程回写 Socket 和主线程清空全局队列
  - 当主线程执行完请求操作后，把需要返回的结果写入缓冲区，然后主线程会阻塞等待 IO 线程，把这些结果回写到 Socket 中，并返回给客户端。和 IO 线程读取和解析请求一样，IO 线程回写 Socket 时，有多个 IO 线程在并行处理，所以该过程执行很快，等到 IO 线程回写 Socket 完毕，主线程会清空全局队列，等待客户端的后续请求

![image](https://img-blog.csdnimg.cn/172783101bf54d18b917abd3137dd658.png)
![image](https://img-blog.csdnimg.cn/cacdad3faa204075a019e77a8058a16b.png)

#### 6.2 主线程和 IO 线程（ Redis 6 之后 ）

- 从 Redis6 开始，新增了多线程的功能来提高 IO 的读写性能
- 主要实现思路是将主线程的 IO 读写任务拆分给一组独立的线程去执行，这样就可以使用多个 socket 的读写进行并行化了，采用多路 IO 复用技术可以让单个线程高效处理多个连接请求，将最耗时的 socket 的读取、请求解析、写入等单独执行，剩下的命令执行仍然由主线程串行执行并和内存的数据交换

## 7. Redis 持久化

#### 7.1 基础介绍

- 因为 Redis 的数据是全部存储在内存中的，如果机器突然故障，那么数据就会全部丢失，因此需要有持久化机制来保证数据不会因为宕机而丢失
- 数据从 Redis 中到磁盘的这一过程（ 简要版 ）：
  - 客户端向数据库发起 write 指令（ 数据在客户端的内存中 ）
  - 数据库收到 write 指令和对应的写数据（ 数据在服务端内存中 ）
  - 数据库调用将数据写入磁盘的系统调用函数（ 数据在系统内核缓冲区 ）
  - 操作系统将写入缓冲区中的数据写到磁盘控制器中（ 数据在磁盘缓冲区中 ）
  - 磁盘控制器将磁盘缓冲区中的数据写入磁盘的物理介质中（ 数据真正写入磁盘中 ）
- 所以说数据库在持久化的过程中主要应该去实现 步骤 3，也就是将原本在内存中的数据持久化到操作系统的内核缓冲区中。至于下面的两步，则是操作系统需要关心的事，数据库无能为力

#### 7.2 持久化方案

- Redis 提供了以下几种不同的持久化方案
  - 如果仅希望数据只在数据库运行时存在，那么还可以完全禁用掉持久化机制
  - 利用 RDB 持久化在指定的时间间隔生成数据集的时间点快照（ point-in-time ）
  - 利用 AOF 持久化将服务器收到的所有写操作命令记录下来，并在服务器重新启动的时候，利用这些命令来恢复数据集。AOF 的命令使用的是与 Redis 本身协议的命令一致，通过追加的方式将数据写入备份文件中，同时当备份文件过大时，Redis 也能对备份文件进行重压缩
  - Redis 还可以同时使用 AOF 持久化和 RDB 持久化。在这种情况下，当 AOF 重启时，会优先使用 AOF 文件去恢复原始数据。因为 AOF 中保存的数据通常比 RDB 中保存的数据更加完整

#### 7.3 RDB（ Redis Database ）持久化

- RDB 通过快照的形式将数据保存到磁盘中
- 所谓快照，可以理解为在某一时间点将数据集拍照并保存下来
- Redis 通过这种方式可以在指定的时间间隔或者执行特定命令时将当前系统中的数据保存备份，以二进制的形式写入磁盘中，默认文件名为 dump.rdb
- RDB 的触发有 3 种机制
  - 执行 save 命令
    ![image](https://img-blog.csdnimg.cn/95c36be4de77436dac575200feb21cba.png)
    - Redis 是单线程程序，这个线程要同时负责多个客户端套接字的并发读写操作和内存结构的逻辑读写。而 save 命令会阻塞当前的 Redis 服务器，在执行该命令期间，Redis 无法处理其他的命令，直到整个 RDB 过程完成为止
    - 当这条指令执行完毕，将 RDB 文件保存下来后，才能继续去响应请求。这种方式用于新机器上数据的备份还好，如果用在生产上，那么简直是灾难，数据量过于庞大，阻塞的时间点过长，所以这种方式并不可取
  - 执行 bgsave 命令
    ![image](https://img-blog.csdnimg.cn/7d1c9b6e8a1a4aad8e96e94b076a294d.png)
    - 为了不阻塞线上的业务，那么 Redis 就必须一边持久化，一边响应客户端的请求。所以在执行 bgsave 时可以通过 fork 一个子进程，然后通过这个子进程来处理接下来所有的保存工作，父进程就可以继续响应请求而无需去关心 I/O 操作
  - 在 redis.config 中配置自动化
    - 上述两种方式都需要我们在客户端中去执行 save 或者 bgsave 命令，在生产情况下我们更多地需要是自动化的触发机制，那么 Redis 就提供了这种机制，我们可以在 redus.config 中对持久化进行配置

#### 7.4 RDB 优缺点

- 优点：
  - RDB 是一个非常紧凑的文件（ 保存二进制数据 ），它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份：
    - 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件
    - 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本
  - RDB 非常适用于灾难恢复（ disaster recovery ）：
    - 它只有一个文件，并且内容都非常紧凑，可以（ 在加密后 ）将它传送到别的数据中心
  - RDB 可以最大化 Redis 的性能：
    - 父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作
  - RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快
- 缺点：
  - 如果业务上需要尽量避免在服务器故障时丢失数据，那么 RDB 并不适合
    - 虽然 Redis 允许在设置不同的保存点（ save point ）来控制保存 RDB 文件的频率， 但是， 由于 RDB 文件需要保存整个数据集的状态， 所以这个过程并不快，可能会至少 5 分钟才能完成一次 RDB 文件保存
    - 在这种情况下， 一旦发生故障停机， 就可能会丢失好几分钟的数据
  - 每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。
    - 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端，如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒
    - 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失

#### 7.5 AOF（ Append Only File ）持久化

![image](https://img-blog.csdnimg.cn/affc5eb335c64cdd8c3aa1e5913711aa.png)

- RDB 持久化是全量备份，比较耗时，所以 Redis 就提供了一种更为高效的 AOF 持久化方案
- AOF 的工作原理为，AOF 日志存储的是 Redis 服务器指令序列，AOF 只记录对内存进行修改（ 写操作 ）的指令记录，在服务器从新启动时，Redis 就会利用 AOF 日志中记录的这些操作从新构建原始数据集
- Redis 会在收到客户端修改指令后，进行参数修改、逻辑处理，如果没有问题，就立即将该指令文本存储到 AOF 日志中，也就是说，先执行指令才将日志存盘。这点不同于 leveldb、hbase 等存储引擎，它们都是先存储日志再做逻辑处理
- RDB 的触发主要有 3 种机制（ 还有别的不常用的方案 ）
  - no：默认配置，即不使用 AOF 持久化方案
  - always：每次发生数据修改就会立即记录到磁盘文件中，这种方案的完整性好但是 IO 开销很大，性能较差
  - everysec：在每一秒中进行同步，速度有所提升。但是如果在一秒内宕机的话可能失去这一秒内的数据
- 可以在 redis.config 中进行配置，appendonly no 改换为 yes，再配置 appendfsync 需要的方案，比如 appendfsync always

#### 7.6 AOF 重写机制

- 随着 Redis 的运行，AOF 的日志会越来越长，如果实例宕机重启，那么重放整个 AOF 将会变得十分耗时
- 而在日志记录中，又有很多无意义的记录，比如将一个数据 incr 一千次，那么就不需要去记录这 1000 次修改，只需要记录最后的值即可，所以就需要进行 AOF 重写
- Redis 提供了 bgrewriteaof 指令用于对 AOF 日志进行重写，该指令运行时会开辟一个子进程对内存进行遍历，然后将其转换为一系列的 Redis 的操作指令，再序列化到一个日志文件中。完成后再替换原有的 AOF 文件，至此完成
- 同样的也可以在 redis.config 中对重写机制的触发进行配置：
  - 通过将 no-appendfsync-on-rewrite 设置为 yes，开启重写机制
  - auto-aof-rewrite-percentage 100 意为比上次从写后文件大小增长了 100% 再次触发重写
  - auto-aof-rewrite-min-size 64mb 意为当文件至少要达到 64mb 才会触发制动重写
- 重写也是会耗费资源的，所以当磁盘空间足够的时候，这里可以降低重写的频率，达到优化效果

#### 7.7 AOF 优缺点

- 优点：
  - AOF 持久化的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多也只会丢失掉一秒钟内的数据
  - AOF 文件是一个只进行追加操作的日志文件（ append only log ）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（ 如 写入时磁盘已满，写入中途停机 等等）， redis-check-aof 工具也可以轻易地修复这种问题
  - Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写
    - 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合
    - 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失
    - 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作
  - AOF 文件有序地保存了对数据库执行的所有写入操作
    - 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（ parse ）也很轻松
    - 并且导出（ export ） AOF 文件也非常简单，举个例子， 如果不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态
- 缺点：
  - 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积
  - 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（ latency ）
  - AOF 在曾经发生过这样的 bug，因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样

#### 7.8 混合持久化

- 重启 Redis 时，如果使用 RDB 来恢复内存状态，会丢失大量数据。而如果只使用 AOF 日志重放，那么效率又太过于低下
- 因此 Redis 4.0 提供了混合持久化方案，将 RDB 文件的内容和增量的 AOF 日志文件存在一起
- 这里的 AOF 日志不再是全量的日志，而是自 RDB 持久化开始到持久化结束这段时间发生的增量 AOF 日志，通常这部分日志很小
- 于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志，就可以完全替代之前的 AOF 全量重放，重启效率因此得到大幅提升

![image](https://img-blog.csdnimg.cn/2a26fb85bfc9471c9df56f17e01691c3.png)
