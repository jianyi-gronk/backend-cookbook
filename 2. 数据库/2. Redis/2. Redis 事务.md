## 1. Redis 自带事务

#### 1.1 基础介绍

- Redis 为内存数据库, 不同于传统的关系数据库，为了提供了更高的性能，更快的写入速度，在设计和实现层面做了一些平衡，并不能完全支持事务的 ACID
- 在 Redis 中，一个客户端请求会被顺序地执行，而且 Redis 不支持并行处理多个请求，因此可以说 **Redis 是单线程操作的数据库**
- Redis 的事务具备如下特点：
  - 保证隔离性
  - 无法保证持久性
  - 具备了一定的原子性，但不支持回滚
  - 一致性的概念有分歧，假设在一致性的核心是约束的语意下，Redis 的事务可以保证一致性
- 从工程角度来看，假设事务操作中每个步骤需要依赖上一个步骤返回的结果，则需要通过 watch 来实现乐观锁

#### 1.2 事务命令

- Redis 的事务包含如下命令：

  <img src="https://img-blog.csdnimg.cn/direct/3407e257d28b4d37b40ff2dbd09e0d8b.png">

- 事务包含三个阶段：
  - 事务开启，使用 MULTI , 该命令标志着执行该命令的客户端从非事务状态切换至事务状态
  - 命令入队，MULTI 开启事务之后，客户端的命令并不会被立即执行，而是放入一个事务队列
  - 执行事务或者丢弃。如果收到 EXEC 的命令，事务队列里的命令将会被执行，如果是 DISCARD 则事务被丢弃
- Redis 事务不支持回滚，如果在执行事务的时候碰到错误，则依然会继续执行，
- 例如，实现基础事务
  ```shell
  redis> MULTI
  OK
  redis> SET msg "hello world"
  QUEUED
  redis> GET msg
  QUEUED
  redis> EXEC
  1) OK
  1) hello world
  ```
- 例如，借助 watch 实现乐观锁
  - 没有 watch 的情况，其他事务修改了数据，无法察觉
    <img src="https://img-blog.csdnimg.cn/direct/465ca3e1f57e417ea6ed346cca67efd0.png">
  - 有 watch 的情况，如果其他事务修改了 watch 的数据，在 EXEC 的时候，会报错
    <img src="https://img-blog.csdnimg.cn/direct/377810d450c342c688f581026891803e.png">

#### 1.3 原子性

- 原子性，即一个事务中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样
- 第一个例子：在执行 EXEC 命令前，客户端发送的操作命令错误，比如语法错误或者使用了不存在的命令
  ```shell
  # 在这个例子中，我们使用了不存在的命令，导致入队失败，整个事务都将无法执行
  redis> MULTI
  OK
  redis> SET msg "other msg"
  QUEUED
  redis> wrongcommand  ### 故意写错误的命令
  (error) ERR unknown command 'wrongcommand'
  redis> EXEC
  (error) EXECABORT Transaction discarded because of previous errors.
  redis> GET msg
  "hello world"
  ```
- 第二个例子：事务操作入队时，命令和操作的数据类型不匹配，入队列正常，但执行 EXEC 命令异常
  ```shell
  # 在执行 EXEC 命令出现错误时，不会终止其它命令的执行，事务也不会因为某个命令执行失败而回滚
  redis> MULTI
  OK
  redis> SET msg "other msg"
  QUEUED
  redis> SET mystring "I am a string"
  QUEUED
  redis> HMSET mystring name  "test"
  QUEUED
  redis> SET msg "after"
  QUEUED
  redis> EXEC
  1) OK
  2) OK
  3) (error) WRONGTYPE Operation against a key holding the wrong kind of value
  4) OK
  redis> GET msg
  "after"
  ```
- Redis 事务在特定条件下，才具备一定的原子性
  - 命令入队时报错， 会放弃事务执行，保证原子性
  - 命令入队时正常，执行 EXEC 命令后报错，不保证原子性

#### 1.4 隔离性

- 隔离性，即数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致
- 事务隔离分为不同级别 ，分别是：
  - 未提交读（ read uncommitted ）
  - 提交读（ read committed ）
  - 可重复读（ repeatable read ）
  - 串行化（ serializable ）
- 首先，需要明确一点，Redis 并没有事务隔离级别的概念，这里讨论 Redis 的隔离性是指，并发场景下，事务之间是否可以做到互不干扰
- 当执行一个事务期间，在 MULTI 和 EXEC 之间的所有命令都将被放入队列中，不会被立即执行。因此，**在 EXEC 之前，其他事务仍然可以去修改数据，在 EXEC 之后，因为 Redis 是单线程操作数据库，所以开始执行过程中，其他事务不会执行**
- 因此我们可以将事务执行可以分为 EXEC 命令执行前和 EXEC 命令执行后两个阶段，分开讨论
  - EXEC 命令执行前
    - 在上一小节，我们发现在事务执行之前，Redis key 依然可以被修改。此时，可以使用 WATCH 机制来实现乐观锁的效果
  - EXEC 命令执行后
    - 因为 Redis 是单线程执行操作命令， EXEC 命令执行后，Redis 会保证命令队列中的所有命令执行完，这样就可以保证事务的隔离性

#### 1.5 持久性

- 持久性，即事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失
- Redis 数据是否持久化取决于 Redis 的持久化配置，没有配置 RDB 或 AOF，事务持久性则无法保证；
  - 使用了 RDB模式，在一个事务执行后，下一次的 RDB 快照还未执行前，如果发生了实例宕机，事务的持久性同样无法保证
  - 使用了 AOF 模式；AOF 模式的三种配置选项 no，everysec 都会存在数据丢失的情况。always 可以保证事务的持久性，但因为性能太差，在生产环境一般不推荐使用
- 综上，redis 事务的持久性是无法保证的

#### 1.6 一致性

- 一致性，即事务只能将数据库状态从一个一致性状态转变为另一个一致性状态（ 一致状态的含义是数据库中的数据应满足完整性约束 ）
  - 完整性约束常见包括
    - 实体完整性约束：确保每行记录都有一个唯一标识。通常通过主键约束来实现，要求表中的每条记录都有一个独一无二的主键值
    - 参照完整性约束：用于维护关联表之间的一致性，确保外键引用的数据必须存在于被引用的表中。这样可以防止出现孤儿记录或无效引用
    - 域完整性约束：规定了每个字段的取值范围、格式和长度等限制条件，确保存储在数据库中的数据符合预期的规范
    - 用户定义的完整性约束：基于业务需求定义的其他完整性条件，例如某些特定的业务规则、逻辑条件等（ 虽然 Mysql 可以定义，但是 Redis 不能定义，只能从上层业务代码去定义 ）
- 如果不考虑 用户定义的完整性约束，Redis 是可以保证一致性的

## 2. Lua 基础介绍

- Lua 是一种轻量级的脚本语言，它具有简洁、灵活、高效的特点。Lua 语言最初是为嵌入式系统设计的，但现在已广泛应用于游戏开发、Web 开发、嵌入式设备控制等领域
- 特点：
  - 简单易学：Lua 语法简单且易于学习，可以快速上手
  - 轻量级：Lua 脚本的运行环境非常轻量，占用资源少
  - 高效性能：Lua b脚本的执行速度非常快，特别擅长处理大量数据
  - 可扩展性：Lua 脚本可以通过调用 C/C++ 编写的函数来扩展功能
- Redis 其内置了脚本语言 Lua，允许用户通过 Lua 脚本执行一系列操作

## 3. Lua 基础语法

#### 3.1 数据类型

- Lua 是动态类型语言，变量不要类型定义，只需要为变量赋值
- Lua 有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table
  - nil：只有值 nil 属于该类，表示一个无效值，类似于别的语言的 undefined，在条件表达式中相当于 false
  - boolean：包含两个值，false 和 true
  - number：表示双精度类型的实浮点数
  - string：字符串由一对双引号或单引号来表示
  - function：由 C 或 Lua 编写的函数
  - userdata：表示任意存储在变量中的 C 数据结构
  - thread：表示执行的独立线路，用于执行协同程序
  - table：Lua 中的 table 其实是一个 “关联数组”（ associative arrays ），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过 “构造表达式” 来完成，最简单构造表达式是 {}，用来创建一个空表

#### 3.2 声明变量

- Lua 变量有三种类型：全局变量、局部变量、表中的域
- Lua 中的变量全是全局变量，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量
- 局部变量的作用域为从声明位置开始到所在语句块结束
- 变量的默认值均为 nil
- 例如
  ```lua
  -- test.lua 文件脚本
  a = 5               -- 全局变量
  local b = 5         -- 局部变量

  function joke()
    c = 5           -- 全局变量
    local d = 6     -- 局部变量
  end

  joke()
  print(c,d)          --> 5 nil

  do
    local a = 6     -- 局部变量
    b = 6           -- 对局部变量重新赋值
    print(a,b);     --> 6 6
  end

  print(a,b)      --> 5 6
  ```

#### 3.3 循环语句

- while 循环
  ```lua
  while(condition)
  do
    statements
  end
  ```
- Lua for 循环

  ```lua
  -- 数值 for 循环
  -- var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次 "执行体"
  for var=exp1,exp2,exp3 do
    <执行体>
  end

  -- 泛型 for 循环
  -- 通过一个迭代器来遍历所有值，类似 java 中的 foreach 语句
  a = {"one", "two", "three"}
  for i, v in ipairs(a) do
    print(i, v)
  end
  ```

#### 3.4 条件语句

- 语法为
  ```lua
  if( 布尔表达式 1)
  then
    --[ 在布尔表达式 1 为 true 时执行该语句块 --]

  elseif( 布尔表达式 2)
  then
    --[ 在布尔表达式 2 为 true 时执行该语句块 --]

  elseif( 布尔表达式 3)
  then
    --[ 在布尔表达式 3 为 true 时执行该语句块 --]
  else
    --[ 如果以上布尔表达式都不为 true 则执行该语句块 --]
  end
  ```

#### 3.5 函数

- 语法为
  ```lua
  function_scope function function_name(argument1, argument2, ..., argumentn)
    function_body
    return result_params_comma_separated
  end
  ```

## 4. Lua + Redis 执行流程

#### 4.1 基础介绍

- Redis 除了自带事务，也可通过 Lua 去实现事务，在 Lua 脚本中，可以通过 redis.call 调用 Redis 操作
- 对于 Redis Lua 脚本的执行流程，可以分为 加载脚本、编译脚本 和 执行脚本 三个阶段
- 加载脚本时会进行脚本缓存，编译脚本会将脚本转换为可执行的字节码，执行脚本具有原子性和事务性特点
- 简单介绍
  - 加载：使用 SCRIPT LOAD 命令将 Lua 脚本加载到 Redis 中，获得一个 SHA1 校验和
  - 编译：Redis 将加载的 Lua 脚本进行编译，生成可执行的字节码
  - 执行：通过 EVALSHA 命令传递 SHA1 校验和和参数，Redis 会根据 SHA1 校验和查找并执行相应的 Lua 脚本

#### 4.2 加载脚本：

- 脚本缓存机制：
  - Redis 脚本缓存的目的是为了提高脚本的执行效率，避免每次执行脚本都需要重新加载和编译
  - 脚本缓存的实现方式是将脚本的 SHA1 散列值和脚本内容一起保存在 Redis 服务器的脚本缓存中
- 脚本加载与缓存的关系：
  - 脚本加载的流程是将脚本传输给 Redis 服务器，并通过 SHA1 散列值判断脚本是否已经存在于缓存中
    - 如果脚本已经存在于缓存中，则直接返回脚本的 SHA1 散列值
    - 如果脚本不存在于缓存中，则将脚本进行缓存，并返回脚本的 SHA1 散列值
  - 在使用脚本时，可以通过脚本的 SHA1 散列值来引用脚本，而不需要每次都传输脚本内容

#### 4.3 编译脚本：

- Lua 脚本语法：
  - Lua 脚本是基于 Lua 语言的一种脚本语言，具有自己的语法规则
  - 常用的 Lua 语法元素包括变量、表达式、控制结构、函数等
- 脚本编译过程：
  - 脚本编译的原理是将 Lua 脚本解析为一种可执行的中间表示形式（ 字节码 ）
  - 在编译过程中，会检查脚本的语法错误，并将脚本转换为可执行的字节码

#### 4.4 执行脚本：

- 脚本执行的原子性：
  - Redis Lua 脚本具有原子性特点，即脚本中的所有操作要么全部执行成功，要么全部不执行
  - 这是因为 Redis 在执行脚本时会将脚本作为一个整体进行执行，不会被其他操作中断
- 脚本执行的事务性：
  - Redis 事务是一种原子性的操作集合，可以将多个操作封装在一个事务中进行执行
  - 在 Lua 脚本中，可以使用 Redis 事务的命令（ 如 MULTI、EXEC、WATCH 等 ）来实现事务性操作

## 5. Lua + Redis 应用场景

#### 5.1 原子性操作

- Lua 脚本在 Redis 中的执行是原子性的，可以实现事务处理、乐观锁、排他锁等原子性操作
- 例，使用 Lua 脚本实现排他锁

  ```lua
  -- 加锁脚本如下
  -- 使用 Redis 的 set 设置键值对，并用 NX 参数来保证只有在键不存在时才进行设置，从而实现排他锁效果
  -- 通过传递键名、值和过期时间来使用该脚本
  local key = KEYS[1]
  local value = ARGV[1]
  local ttl = tonumber(ARGV[2])

  local lock = redis.call('set', key, value, 'NX', 'PX', ttl)

  if lock then
    return true
  else
    return false
  end
  ```

#### 5.2 复杂计算

- Lua 脚本可以进行复杂的计算，如计算统计数据、排序、过滤等
- 例，使用 Lua 脚本计算列表中所有元素的总和

  ```lua
  -- 计算列表中所有元素的总和
  -- Redis 的 lrange 命令来获取列表中的所有元素，然后对这些元素进行求和操作，最后返回计算结果
  local key = KEYS[1]
  local sum = 0

  local values = redis.call('lrange', key, 0, -1)
  for i, value in ipairs(values) do
      sum = sum + tonumber(value)
  end

  return sum
  ```

#### 5.3 批量操作

- 通过 Lua 脚本可以实现批量操作，如批量插入、批量删除等
- 例，使用 Lua 脚本进行批量操作

  ```lua
  -- 批量删除指定前缀的键
  -- keys 命令获取指定前缀的键名列表，然后循环遍历这些键名
  -- 使用 del 命令进行批量删除操作，并返回删除的键的数量
  local prefix = ARGV[1]

  local keys = redis.call('keys', prefix .. '*')
  for i, key in ipairs(keys) do
      redis.call('del', key)
  end

  return #keys
  ```

#### 5.4 分布式锁

- 使用 Lua 脚本可以实现分布式锁，防止多个客户端同时访问共享资源

#### 5.5 优化性能

- 通过将多个命令封装在一个 Lua 脚本中执行，可以减少网络开销，提高性能
