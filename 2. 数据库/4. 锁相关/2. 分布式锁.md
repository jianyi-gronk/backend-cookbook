## 1. 什么是分布式锁

- 常见实现分布式锁的方式有：
  - 基于数据库的分布式锁。db 操作性能较差，并且有锁表的风险，一般不考虑
  - 基于 Redis 的分布式锁。适用于并发量很大、性能要求很高而可靠性问题可以通过其他方案去弥补的场景
  - 基于 ZooKeeper 的分布式锁。适用于高可靠（ 高可用 ），而并发量不是太高的场景

## 2. 基于数据库实现分布式锁

#### 2.1 利用主键唯一的特性（ 借助 insert ）

- 具体步骤：
  - 获取锁：如果有多个请求同时要插入主键相同的数据，当这些请求提交到数据库时，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁
  - 释放锁：当方法执行完毕之后，想要释放锁的话，只要删除插入的那条数据库数据即可
- 存在问题以及解决方案：
  - **数据库单点问题**：这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用
    - 搞两个数据库，数据之前双向同步，一旦挂掉快速切换到备库上
  - **没有失效时间问题**：这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁
    - 只要添加一个字端表示获取锁的时间，做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍
  - **非阻塞锁问题**：这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作
    - 搞一个 while 循环，直到 insert 成功再返回成功
  - **非重入锁问题**：这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了
    - 在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。但是这样是很消耗性能的，增加数据库压力
  - **非公平锁问题**：这把锁是非公平锁，所有等待锁的线程凭运气去争夺锁
    - 再建一张中间表，将等待锁的线程全记录下来，并根据创建时间排序，只有最先创建的允许获取锁
  - **锁表问题**：在 MySQL 数据库中采用主键冲突防重，在大并发情况下有可能会造成锁表现象
    - 比较好的办法是在程序中生产主键进行防重

#### 2.2 基于版本号（ 借助 update ）

- 类似于上一个方法，存在的问题以及对应解决方案也类似
- 主要思想：**在表中添加字段，用于表示版本号（ 也可以称为锁的状态字段 ）**，初始值为 0，当值为 1 时，即表示已经有锁
- 具体步骤：
  - 获取锁：当某个线程想要获取锁时，它首先尝试使用 update 语句来执行该更新操作，并检查受影响的行数。如果受影响的行数为 0，则表示其他线程已经获取了锁，当前线程获取锁失败；如果受影响的行数为 1，则表示当前线程成功获取了锁
  - 释放锁：当线程执行完关键代码片段后，需要释放锁。为了释放锁，该线程需要再次执行 update 语句来将版本号字段的值重置为初始值 0

## 3. 基于 zookeeper 实现分布式锁

#### 3.1 基础介绍

- 核心思想：**利用有序临时节点与 watch 机制**，在与该方法对应的持久节点的目录 /lock 下，为每个进程创建一个临时顺序节点
- 具体步骤：
  - 每个进程获取所有临时节点列表，对比自己的编号是否最小
    - 如果是最小则获取锁成功，执行代码，最后释放锁（ 删除该有序临时节点 ）
    - 如果不是则取锁失败，并继续判断
      - 若本进程为读请求，则向比自己序号小的最后一个写请求节点注册 watch 监听，当监听到该节点释放锁后，则获取锁
      - 若本进程为写请求，则向比自己序号小的最后一个读请求节点注册 watch 监听，当监听到该节点释放锁后，获取锁

#### 3.2 优缺点

- 优点：
  - 有序临时节点的机制确保了获取锁的顺序，避免了循环等待，从而有效地避免了死锁问题。因为任何一个客户端在释放锁之前都会删除自己的节点，从而触发下一个等待的客户端获取锁
- 缺点：
  - 可能会造成羊群问题，在整个分布式锁的竞争过程中，大量的 Watcher 通知和子节点列表的获取操作重复运行，并且大多数节点的运行结果都是判断出自己当前并不是编号最小的节点，继续等待下一次通知，而不是执行业务逻辑

## 4. 基于 Redis 实现分布式锁

#### 4.1 基于 setnx()，expire()，del() 方法

- 核心函数
  - setnx(key, value)
    - setnx 的含义就是 SET if Not Exists，该方法是原子的，如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0
    - key 的值可以根据业务设置，比如是用户中心使用的，可以命令为 USER_REDIS_LOCK，value 可以使用 uuid 保证唯一，用于标识加锁的客户端，保证加锁和解锁都是同一个客户
  - expire(key, expiration)
    - expire 设置过期时间，要注意的是 setnx 命令不能设置 key 的超时时间，只能通过 expire() 来对 key 设置
  - del(key)
    - 删除指定 key
- 具体步骤
  - 加锁：使用 setnx(key, value) 命令，如果 key 不存在，成功设置 value，则加锁成功。如果已经存在 key，也就是有客户端持有锁了，导致设置 value 失败，则加锁失败
  - 解锁：使用 del 命令，通过删除键值释放锁。释放锁之后，其他客户端可以通过 setnx 命令进行加锁
- 存在问题
  - 虽然可以解决大部分日常工作中的需求的，但是如果在 setnx 执行成功后，在 expire 命令执行成功前，发生了宕机的现象，那么就依然会出现死锁的问题

#### 4.2 基于 setnx()，get()，getset()方法做分布式锁

- 核心函数
  - setnx(key, value)
    - 和上面一样
  - get(key)
    - 获取 key 对应的 value
  - getset(key, newValue)
    - 将 key 对应的值设为 newValue，并返回 oldValue
- 具体步骤
  - 执行 setnx(lockkey, 当前时间 + 过期超时时间)
    - 如果返回 1，则获取锁成功，开始自己的业务处理
    - 如果返回 0 则没有获取到锁，继续进行下面步骤
  - get(lockkey) 获取值 oldExpireTime ，并将这个 value 值与当前的系统时间进行比较，如果小于当前系统时间，则认为这个锁已经超时，可以允许别的请求重新获取
  - 计算 newExpireTime = 当前时间 + 过期超时时间，然后 getset(lockkey, newExpireTime) 会返回当前 lockkey 的值currentExpireTime
  - 判断 currentExpireTime 与 oldExpireTime 是否相等
    - 如果相等，说明当前 getset 设置成功，获取到了锁
    - 如果不相等，说明这个锁又被别的请求获取走了，那么需要进行回退，然后当前请求可以直接返回失败，或者继续重试
  - 在获取到锁之后，当前线程可以开始自己的业务处理，当处理完毕后，比较自己的处理时间和对于锁设置的超时时间
    - 如果小于锁设置的超时时间，则直接执行 delete 释放锁
    - 如果大于锁设置的超时时间，则不需要再锁进行处理
- 存在问题
  - 回退是个很难处理的事情，如果 getset 后发现需要回退，但是发生宕机，会导致 value 变成脏数据

#### 4.3 基于 lua

- 基于 setnx()，get()，getset()方法做分布式锁，其实类似于 CAS，但是并没有保证事务原子性，所以这时候需要 lua 出手
