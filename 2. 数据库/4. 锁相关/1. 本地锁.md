## 1. 悲观锁和乐观锁

#### 1.1 悲观锁

- 悲观锁是基于一种悲观的态度类来防止一切数据冲突
  - 它是以一种 **预防** 的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁，然后下一个人才可以对数据进行操作
- 特点：
  - 可以完全保证数据的 独占性 和 正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，但是因为加锁和释放锁的过程会造成消耗，所以性能不高
- 使用场景：
  - 悲观锁适用于写多读少的情况下
  - **一般数据库本身锁的机制都是基于悲观锁的机制实现的**，数据库中的 行锁，表锁，读锁（ 共享锁 ），写锁（ 排他锁 ），以及 Java 的 syncronized 关键字的实现的锁均为悲观锁
- 如何实现：
  - 悲观锁实现，就是通过加锁，可以对代码块加锁，也可以对数据加锁。Java 中可以使用 synchronized 同步代码块，而数据库中可以使用排它锁等自带功能
- 本质就是 添加锁 -> 访问 -> 释放，如图所示
  <img src="https://img-blog.csdnimg.cn/direct/8dd04e4037cd425997a28bdde8a9b7ae.png" width="800">

#### 1.2 乐观锁

- 乐观锁是对于数据冲突保持一种乐观态度
  - 乐观控制相信事务之间的数据竞争的概率是比较小的，因此本身是不加锁的（ 这使得多个任务可以 **并行** 的对数据进行操作 ），尽可能直接做下去，直到提交的时候才去判断数据是否存在冲突，所以不会产生任何锁和死锁
- 特点：
  - 乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能
  - 不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能
- 使用场景：
  - 乐观锁适用于读多写少的情况下（ 写的多的情况，冲突多 ）
  - 不适合高并发场景，因为在并发非常高的情况下，可能会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁
- 如何实现：
  - 常用 版本号（ 或 时间戳 ），CAS 去实现
  - 版本号（ 时间戳类似 ）
    - 数据库的表中添加一个 version 字段，用于标识哪个版本，每当修改一次数据时候，会将版本号加 1
    - 当查询数据时候，将数据中的版本号一起查询出来
    - 接着修改数据，准备提交数据到数据库时候，再次查询数据库中版本号
    - 判断当前查询的版本号是否和第一次查询的一样，如果一样，则进行操作，否则重试
  - CAS
    - CAS 有三个操作数：需要读写的内存位置（ V ），进行比较的预期值（ A ） 和 拟写入的新值（ B ）
    - 如果内存位置 V 的值等于预期的 A 值，则将该位置更新为新值 B，否则不进行任何操作
    - 不过 CAS 通常是自旋的，也就说如果一次不成功，它会一直循环去判断，直到成功为止，自旋 CAS 就会占用系统资源，比较耗费 CPU 的开销
    - 并且 CAS 存在 ABA 问题
      - ABA 问题即：线程 1 修改数据后值等于 A，线程 2 修改数据后值变成 B，线程 2 再次修改数据后值变成 A，这样， CAS 检查时候，发现修改前后的值是一样的，就认为没有修改，所以 CAS 操作成功
      - 可以通过引入上面说的版本号来解决，即只有值和版本号都匹配的时候

## 2. 共享锁和排他锁

- 共享锁（ 又称为读锁，简称 S 锁 ），就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是都只能读不能修改
- 排他锁（ 又称为写锁，简称 X 锁 ），就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括 共享锁 和 排他锁，只有获取排他锁的事务是可以对数据就行读取和修改
  - 需要注意，排它锁并不是指有排它锁的时候，不能执行其他事务，而是指不能加其他锁，在有排它锁的时候，仍然可以执行普通查询
- 以 mysql 举例
  <img src="https://img-blog.csdnimg.cn/direct/9f4afae51ddb46bd8bec562a2c1cabe0.png" width="600">

## 3. 阻塞锁和非阻塞锁

#### 3.1 阻塞锁

- **阻塞锁需要线程阻塞挂起，等待锁的可用性**
- 多个线程同时调用同一个方法的时候，所有线程都被排队处理了。让等待的线程进入阻塞状态进行等待，当获得相应的信号（ 唤醒，时间等 ）时，才可以进入线程的准备就绪状态，准备就绪状态的所有线程，通过竞争，进入运行状态
- 阻塞锁会把等待的进程 **阻塞挂起**，在线程阻塞挂起的过程中，该线程会释放 CPU 的使用权，让其他就绪的线程有机会执行，线程阻塞挂起适用于等待时间较长的情况，它可以避免线程忙等待导致的 CPU 资源浪费，并提高系统的并发性能
- 代码如下
  ```
  public class Lock{
    private boolean isLocked = false;
    public synchronized void lock() throws InterruptedException{
        while(isLocked){
           // 当其他线程进来，直接让其进入等待状态
            wait();
        }
        isLocked = true;
    }
    public synchronized void unlock(){
        isLocked = false;
        notify();
    }
  }
  ```

#### 3.2 非阻塞锁

- **非阻塞锁不会阻塞线程，而是通过返回失败或执行其他操作来处理锁可用的情况**
- 多个线程同时调用一个方法的时候，当某一个线程最先获取到锁，这时其他线程判断没拿到锁，这时就直接返回失败（ 或者执行其他操作 ），只有当最先获取到锁的线程释放，其他线程才能进来，在它释放之前其它线程都会获取失败
- 非阻塞锁 **不会归还 CPU 资源**，当知道需要等待时，会执行 忙等待 等方法
- 代码如下

  ```
  public class Lock{
    private boolean isLocked = false;
    public synchronized boolean lock() throws InterruptedException{
        if(isLocked){
           // 当没有拿到锁，立即返回，线程不阻塞
           return false;
        }
        isLocked = true;

       return true;
    }
    public synchronized void unlock(){
        isLocked = false;
    }
  }
  ```

## 4. 互斥锁和自旋锁

#### 4.1 互斥锁

- 互斥锁是阻塞锁，当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环
- 获取锁的线程一直处于活跃状态，由于一直调用 while 循环，但是并没有执行任何有效的任务，使用这种锁会造成忙等待
- 代码如下
  ```
  public class Lock{
    private boolean isLocked = false;
    public synchronized void lock() throws InterruptedException{
        while(isLocked){
           // 当其他线程进来，直接让其进入等待状态
            wait();
        }
        isLocked = true;
    }
    public synchronized void unlock(){
        isLocked = false;
        notify();
    }
  }
  ```

#### 4.2 自旋锁

- 自旋锁是非阻塞锁，是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环，而不会阻塞挂起，即也不会被收回 CPU 资源
- 获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，如果长时间使用这种锁会造成系统负载很大，耗费性能，阻止了其他线程的运行和调度
- 如果正在执行的线程发生中断情况，那么其他线程将保持旋转状态（ 反复尝试获取锁 ），而持有该锁的线程并不打算释放锁，这样导致的是结果是无限期推迟，直到持有锁的线程可以完成并释放它为止
- 代码如下
  ```
  public class Lock{
    private boolean isLocked = false;
    public synchronized void lock() throws InterruptedException{
        while(isLocked){
          sout("继续不断的循环来判断是否可以拿到锁");
        }
        isLocked = true;
    }
    public synchronized void unlock(){
        isLocked = false;
    }
  }
  ```
- CAS 便是典型的自旋锁

## 5. 可重入锁

- **可重入锁是一种特殊的互斥锁**，因该锁通过线程独占共享资源的方式确保并发安全，也可以称为独占锁
- 可重入是指一个线程在持有锁的情况下，可以再次请求该锁而不会被自己阻塞，也就是说，如果线程 A 已经获得了一个锁，那么在没有释放该锁之前，它可以继续多次获得同一个锁
- 可重入锁解决了线程在重复获取同一个锁时引发的死锁问题。在复杂的多线程应用程序中，一个线程可能需要多次获取同一个锁。如果锁是不可重入的，那么线程在第二次请求锁时将被阻塞，因为它已经拥有了该锁。这种情况下，该线程可能会因为无法获取该锁而导致程序发生死锁
- 通过使用可重入锁，一个线程可以多次获得同一个锁而不会被自己阻塞，从而避免了死锁问题的发生。这对于编写安全可靠的多线程代码非常重要

## 5. 公平锁和非公平锁

- 公平锁 指按照锁申请的顺序来获取锁，线程直接进入队列中，当释放锁之后，队列中的第一个线程才能获取锁
  - 公平锁 的优点是不会造成饥饿，但整体性能会比 非公平锁 低
  - 因为除等待队列中的第一个线程，其它线程都需要进行阻塞和唤醒操作
- 非公平锁 指多个线程获取锁时，会先直接尝试获取锁，只有当线程未获取到锁时才放入队列末尾
  - 非公平锁 有几率直接获得锁，减少了线程阻塞和唤醒的次数，但可能会造成饥饿
  - 因此在饥饿无影响或不会产生饥饿的场景下优先考虑非公平锁
