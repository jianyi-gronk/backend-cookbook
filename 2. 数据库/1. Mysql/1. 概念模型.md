## 1. 层次模型

#### 基础介绍

- 层次数据模型是用树状（ 层次 ）结构来组织数据的数据模型
- 实体用记录来表示，实体间的联系用链接（ 可看作指针 ）来表示
- 现实世界中许多实体之间的联系本来就呈现出一种很自然的层次关系，如组织结构，家族关系等
- 特征（ 树的性质决定了树状数据模型的特征 ）：
  - 整个模型中有且仅有一个节点没有父节点，其余的节点必须有且仅有一个父节点，但是所有的节点都可以不存在子节点
  - 所有的子节点不能脱离父节点而单独存在，也就是说如果要删除父节点，那么父节点下面的所有子节点都要同时删除，但是可以单独删除一些叶子节点
  - 每个记录类型有且仅有一条从父节点通向自身的路径

#### 定义

- 在数据库中定义满足如下两个条件的基本层次联系的集合称为层次模型
  - 有且仅有一个结点没有双亲结点，这个结点称为根节点
  - 根以外的其他结点有且只有一个双亲结点

#### 优缺点

- 优点：
  - 数据结构简单清晰，很容易看到各个实体之间的联系
  - 操作层次数据类型的数据库语句比较简单，只需要几条语句就可以完成数据库的操作
  - 因为记录之间的联系用有向边表示，这种联系在 DBMS 中通常使用指针实现，查询效率高，层次模型数据库性能优于关系数据库，不低于网状数据库
  - 提供了良好的完整性支持。进行插入操作时，如果没有对应的双亲结点就不能插入它的子女结点值，进行删除操作时，如果删除双亲结点，则相应的子女结点值也将被同时删除
- 缺点：
  - 现实世界中的很多联系是非层次性的。如果结点之间具有多对多联系，不再适合使用层次模型表示。如果一个子女结点确实具有多个双亲结点，使用层次结构模型表示的时候就会出现大量的冗余，且操作复杂
  - 查询子女结点必须通过双亲结点，因此限制了对数据库存取路径的控制
  - 由于结构严密，层次命令趋于程序化，缺乏灵活性

## 2. 网状模型

#### 基础介绍

- 网状数据模型是用有向图表示实体和实体之间的联系的数据结构模型
- 与层次模型一样，网状模型中的每个结点也表示一个记录型，每个记录型可包含若干个字段，结点间的有向连线表示记录（ 型 ）之间一对多的父子联系
- 由于网状模型的双亲结点和孩子结点之间的联系不是唯一的，因此要为每个联系命名，并指出与该联系有关的双亲记录和孩梓记录

#### 定义

- 在数据库中定义满足如下两个条件的基本层次联系的集合称为网状模型
  - 允许一个以上的节点无双亲
  - 一个结点可以有多个双亲
- 网状模型是一种比层次模型更具普遍性的结构，去掉了层次模型的两个限制，还允许两个结点之间有多种联系（ 称为复合联系 ），因此网状模型可以更直接地去描述现实世界

#### 优缺点

- 优点：
  - 网状数据模型可以很方便的表示现实世界中的很多复杂的关系
  - 实体之间的关系在底层中可以借由指针指针实现，因此在这种数据库中的执行操作的效率较高
  - 修改网状数据模型时，没有层次状数据模型的那么多的严格限制，可以删除一个节点的父节点而依旧保留该节点，也允许插入一个没有任何父节点的节点
- 缺点：
  - 结构复杂，而且随着应用规模的扩大，数据库的结构变得越来越复杂，数据的插入、删除牵动的相关数据太多，不利于数据库的维护和重建
  - 网状模型的数据定义语言和数据管理语言复杂
  - 由于记录之间的联系通过存取路径实现，应用程序在访问数据的时候必须选择恰当的存取路径，因此用户必须了解系统结构的细节，导致加重了编写应用程序的负担

## 3. 关系模型

#### 基础介绍

- 关系模型由一组关系组成，每个关系的数据结构是一张规范化的二维表
- 采用了关系模型来组织数据的数据库就是关系型数据库，否则就是非关系型数据库

#### 定义

- 关系模型要求关系必须是规范化的，即要求关系必须满足一定的规范条件，这些规范条件中最基本的是
  - 关系的每一个元组必须是可区分的，即存在码属性
  - 关系的每一个属性（ 即元组的分量 ）必须是一个不可分的数据项，即不允许表中有表

#### 优缺点

- 优点：
  - 关系模型建立在严格的数学概念的基础之上，有关系代数作为语言模型，有关系数据理论作为理论基础
  - 关系模型概念单一，无论是实体还是实体之间的联系都用关系来表示，对数据（ 关系 ）的操作（ 查询和更新 ）结果还是关系，所以其数据结构简单，清晰，用户易懂易用
  - 关系模型的存取路径对用户透明，从而具有较高的数据独立性，更好的安全保密性，也简化了程序员的工作，提高了软件的开发和维护效率
- 缺点：
  - 由于存取路径对用户是透明的，查询效率往往不如格式化数据模型，因此为了提高系统性能，DBMS 必须对用户的查询请求进行优化

#### 常见概念名词

- 关系：一个关系对应一张二维表，每一个关系有一个名称即关系名
- 元组：表中的一行称为一个元组
- 属性：表中的一列称为一个属性，每一个属性有一个名称即属性名
- 码：也成为码键或键，表中的某个属性或属性组，它可以唯一的标识表中的一行
  - 超码：对于关系 r 的一个或多个属性的集合 A，如果属性集 A 可以唯一地标识关系 r 中的一个元组，则称属性集 A 为关系 r 的一个超码
  - 候选码：对于关系 r 的一个或多个属性的集合 A，如果属性集 A 是关系 r 的超码，且属性集 A 的任意真子集都不能称为关系 r 的超码，则称属性集 A 为候选码（ 即候选码是最小的超码 ）
  - 主码：若一个关系有多个候选码，则可以选定其中一个候选码作为该关系的主码
  - 外码：设 F 是关系 r 的一个属性（ 或属性集 ），K 是关系 s 的主码（ r 和 s 可以是一个关系 ），如果 F 与 K 相对应（ 即 F 的取值范围对应于 K 的取值范围的子集 ），则称 F 是关系 r 参照关系 s 的外码，简称 F 是关系 r 的外码（ 关系 r 是参照关系，关系 s 是被参照关系或目标关系 ）
- 域：属性的取值范围
- 分量：元组中的一个属性值
- 关系模式：通过关系名和属性名列表对关系进行描述，相当于二维表的表头部分（ 即表格的描述部分 ），一般形式为
  - 关系名（ 属性名 1，属性名 2，...，属性名 n ）
- 笛卡尔积：给定一组域 D1，D2，...，Dn，它们之中可以有相同的域
  - D1，D2，...，Dn 的笛卡尔积为 D1 × D2 × ... × Dn = { ( d1, d2, ..., d3 ) | di ∈ Di, i = 1, 2, ..., n }
  - 其中集合中的每一个元素 ( d1, d2, ..., dn ) 称为一个 n 元组，简称为元组，且元素中的每个值 di 称为一个分量
  - 例如，A = { a, b }, B = { 0,1,2 }，则
    - A × B = { ( a, 0 ), ( a, 1 ), ( a, 2 ), ( b, 0 ), ( b, 1 ), ( b, 2 ) }
    - B × A = { ( 0, a ), ( 0, b ), ( 1, a ), ( 1, b ), ( 2, a ), ( 2, b ) }

#### 完整性约束

- 关系数据模型定义了三种完整性约束：实体完整性、参照完整性 以及 用户定义完整性
- 实体完整性：
  - 若由一个或若干个属性构成的属性集 A 是关系 r 的主码，则要求构成主码 A 的每一个属性的值都不能取空值 null
  - 实体完整性是针对基本关系而言的，一个基本关系对应着现实世界中的一个主题，例如学生表对应着学生这个实体。现实世界中的实体是可以区分的，他们具有某种唯一性标志，这种标志在关系模型中称之为主码，主码的属性也就是主属性不能为空
- 参照完整性：
  - 在关系数据库中主要是指外键参照的完整性
  - 若关系 r 的外码 F 参照关系 s 的主码，则对于关系 r 中的每一个元组在属性 F 上的取值，要么为空值 null，要么等于关系 s 中某个元组的主码值
  - 如选课关系的 stu_id 和 cour_id 分别是参考 学生 和 课程 的外键，那么对于现实的系统而言，stu_id 和 cour_id 必须分别出现在 学生 和 课程 关系中，这就是外键参考的完整性，同时删除的时候根据设置的不同有不同的处理方式
- 用户定义完整性：
  - 用户定义完整性是针对某一个具体关系的约束条件
  - 即某一个具体应用所对应的数据必须满足一定的约束条件，例如，某些属性必须取唯一值，某些值的范围为 0-100 等

#### 关系代数

- 关系代数是通过关系代数运算来构造查询表达式
- 基本的关系代数运算有 选择，投影，集合并，集合差，笛卡尔积 和 更名 等，并且在这些基本运算之外，还有一些其他运算，即 集合交，连接，除 和 赋值 等
- 集合并
  - 关系 r 与关系 s 的并记作：r ∪ s = { t | t ∈ r ∨ t ∈ s }
  - 其结果关系仍为 n 目关系，由属于 r 或属于 s 的所有元组组成
- 集合差
  - 关系 r 与关系 s 的差记作：r - s = { t | t ∈ r ∧ t ∉ s }
  - 其结果关系仍为 n 目关系，由属于 r 而不属于 s 的所有元组组成
- 集合交
  - 关系 r 与关系 s 的交记作：r ∩ s = { t | t ∈ r ∧ t ∈ s }
  - 其结果关系仍为 n 目关系，由属于 r 且属于 s 的所有元组组成
- 笛卡尔积
  - 关系 r 与 关系 s 的笛卡尔积记作：r × s = { tr · ts | tr ∈ r ∧ ts ∈ s }
  - 两个分别为 n 目和 m 目的关系的笛卡尔积是一个 n + m 目元组的集合，元组的前 n 列是关系 r 的一个元组，后 m 列是关系 s 的一个元组
  - 两个分别为 x 和 y 个元组的关系的笛卡尔积是一个 x \* y 个元组的集合
- 选择
  - 选择操作是在关系 r 中查找满足给定选择条件的所有元组，记作：σP\(r\) = { t | t ∈ r ∧ P(t) }
  - 其中 P 表示选择条件，是一个逻辑表达式，取值为 “真” 或 “假”
  - 简单选择条件的形式为：X op Y
    - 其中 op 为比较运算符，包括 <，<=，>，>=，= 和 !=（ 或 <> ）
    - 运算对象 X，Y 可以是属性名，常量或简单函数等
    - 通过 非（ ┐ ），与（ ∧ ），或（ ∨ ）等逻辑运算符可以将多个简单选择条件连接起来
- 投影
  - 关系 r 上的投影是从 r 中选择出若干属性列组成新的关系，记作：ΠA\(r\) = { t[A] | t ∈ r }
  - 其中 A 为关系 r 的属性集合
  - 如果取消了某些列之后的元组出现了重复，则会去除重复元组，即完全相同的元组仅保留一条
- 连接
  - 连接也称为 θ 连接，它是从两个关系的笛卡尔积中选取属性间满足一定条件的元组
    - θ 连接运算就是从关系 r 和 s 的笛卡尔积 r × s 中，选取 r 关系在 A 属性集上的值与 s 关系在 B 属性集上的值满足连接 θ 的所有元组，记作：r ⋈ θs = σθ(r × s)
  - 连接 包括 等值连接，自然连接，全外连接，左外连接（ 也称为 左连接 ）和 右外连接（ 也称为 右连接 ）
    - 等值连接，即 θ 为等值比较的连接运算（ 即选择条件是 = ）
    - 自然连接是特殊的等值连接，记作 r ⋈ s，它要求两个参与连接的关系具有公共的属性集，并在这个公共的属性集上进行等值连接，同时还要求将连接结果中的重复属性列去除掉，即在公共属性集中的列只保留一次
  - 关系 r
    ![image](https://img-blog.csdnimg.cn/912c71db9530436084ca2fd7cb21ab75.png)
  - 关系 s
    ![image](https://img-blog.csdnimg.cn/02da781d8b5d4d56ae0a4d8cfd400289.png)
  - 自然连接：只返回两个表中联结字段相等的行
    ![image](https://img-blog.csdnimg.cn/e0a2fdae1c9e4605baa0c6f3390fc96c.png)
  - 左连接：返回包括左表中的所有记录和右表中联结字段相等的记录，不相等则用 null 表示
    ![image](https://img-blog.csdnimg.cn/a093c46a2d2e4414b305237810be2073.png)
  - 右连接：返回包括右表中的所有记录和左表中联结字段相等的记录，不相等则用 null 表示
    ![image](https://img-blog.csdnimg.cn/8cea09b41f814398b52a37fc8224eb26.png)
  - 全外连接：左连接 并 右连接
    ![image](https://img-blog.csdnimg.cn/497b21f1cc8e41bba427e91a4686de55.png)
- 集合除
  - 公式记作：r ÷ s = { tr[R - S] | tr ∈ R ∧ s ∈ Sx }
  - 设有关系 r，s 如图所示，求 r ÷ s 的结果
    ![image](https://img-blog.csdnimg.cn/dc694cebce7e46038f3cfd0c0951fb58.png)
    - 第一步：找出关系 r 和关系 s 中相同的属性，即 Y 属性，并在关系 s 中对 Y 做投影（ 即将 Y 列取出 ），结果如下
      ![image](https://img-blog.csdnimg.cn/859fddeaff3d457ca58ff0e33f58f7ab.png)
    - 第二步：被除关系 r 中与 s 中不相同的属性列是 X ，关系 r 在属性 X 上做取消重复值的投影为 { X1，X2 }
    - 第三步：分别求关系 R 中 X 属性对应的像集 Y
      ![image](https://img-blog.csdnimg.cn/56e94bc5bb9c475d9cb75ac730404353.png)
    - 第四步：判断包含关系
      - **r ÷ s 其实就是判断关系 r 中 X 各个值的像集 Y 是否包含关系 s 中属性 Y 的所有值**，对比即可发现：
        - X1 的像集只有 Y1，不能包含关系 s 中属性 Y 的所有值，所以排除掉 X1
        - X2 的像集包含了关系 s 中属性 Y 的所有值
      - 所以 r ÷ s 的最终结果就是 X2
        ![image](https://img-blog.csdnimg.cn/3bc6b13f9b7a4a1a88855f5b9b3982aa.png)
