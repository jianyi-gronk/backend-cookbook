## 1. 基础概念

- 首先需要注意，**B- 树，即为 B 树**。因为 B 树的英文名称为 B-tree，所以很多人喜欢把 B-tree 译作 B- 树，而事实上是，B-tree 就是指的 B 树，B 的意思为平衡
- 数据库系统普遍采用 B-/+Tree 作为索引结构，例如 mysql 的 InnoDB 引擎使用的 B+ 树
- 说到快速查询我们就能想到二叉搜索树，但是有的时候二叉树会两边不同深度，就能想到平衡二叉搜索树；但是每个节点最多只有两个子节点，会导致深度非常非常深，就能想到平衡多叉搜索树，这就是 B 树
- B 树是平衡多叉树，相比于平衡二叉树，解决了其痛点
  - 虽然平衡二叉树的查找效率是非常高的，但是当数据量非常大，树的存储的元素数量是有限的，这样会导致二叉查找树结构由于树的深度过大而造成磁盘 I/O 读写过于频繁，进而导致查询效率低下
  - 另外数据量过大会导致内存空间不够容纳平衡二叉树所有结点的情况

#### 1.1 定义

- B 树是一种平衡的多叉树，通常我们说 m 阶的 B 树，它必须满足如下条件：
  - 每个节点最多只有 m 个子节点
  - 每个非叶子节点（ 除了根，根至少是是 0 或 2 个子节点 ）具有至少 m / 2 个子节点
  - 根至少有两个子节点，除非根节点是树中唯一节点
  - 具有 k 个子节点的非叶节点包含 k - 1 个键
  - 所有叶子都出现在同一水平，高度一致

#### 1.2 名次解释

- 例如存在 B 树如下
  ![image](https://github.com/user-attachments/assets/7bd290cc-a64e-4cfe-bcb4-6135660b5a2c)
- B 树的阶
  - B 树中一个节点的子节点数目的最大值，用 m 表示，假如最大值为 4，则为 4 阶
  - 如上图，所有节点中，节点 [13, 16, 19] 拥有的子节点数目最多，四个子节点（ 灰色节点 ），所以可以定义上面的图片为 4 阶 B 树
- 根节点
  - 节点 [10] 即为根节点
  - 根节点拥有的子节点数量的上限和内部节点相同，下限为 2，除非根节点是树中唯一节点，因为如果只有 1 个子节点就变成单支了
- 内部节点
  - 节点 [13, 16, 19]、节点 [3, 6] 都为内部节点
  - 内部节点是除叶子节点和根节点之外的所有节点，拥有父节点和子节点
  - 假定 m 阶 B 树的内部节点的子节点数量为 M，则一定要符合（m/2）<= M <= m 关系式，包含元素数量 M-1；包含的元素数量 (m/2)-1 <= K <= m-1，K 为元素数量，m/2 向上取整
- 叶子节点
  - 节点 [1, 2]、节点 [11, 12] 等最后一层都为叶子节点。叶子节点对元素的数量有相同的限制。但是没有子节点，也没有指向子节点的指针
  - 在 m 阶 B 树中叶子节点的元素符合 (m/2) - 1 <= K <= m-1

#### 1.3 增删改查

- “查” 非常简单，类似于二叉树
- “改” 的本质就是先删再增
- “增” 和 “删” 的本质，就是先找到要修改的地方，然后进行添加或删除。但是需注意，添加或删除后会导致 节点元素数量 不等于 子节点数 - 1。元素个数小于 2（m/2-1）就合并，大于 4（m-1）就分裂

## 2. 插入操作

#### 2.1 插入步骤

- 针对 m 阶高度 h 的 B 树，插入一个元素时，首先判断该元素在 B 树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素
  - 若该节点元素个数小于 m - 1，直接插入
  - 若该节点元素个数等于 m - 1，引起节点分裂；以该节点中间元素为分界，取中间元素（ 偶数个数，中间两个随机选取 ）插入到父节点中
  - 重复上面动作，直到所有节点符合 B 树的规则。最坏的情况一直分裂到根节点，生成新的根节点，高度增加 1

#### 2.2 插入举例

- 以 5 阶 B 树为例，详细讲解插入的动作
- 5 阶 B 树关键点:
  - 2 <= 根节点子节点个数 <= 5
  - 3 <= 内节点子节点个数 <= 5
  - 1 <= 根节点元素个数 <= 4
  - 2 <= 非根节点元素个数 <= 4
- 首先，图（1）插入元素【8】后变为图（2），此时根节点元素个数为 5
  ![image](https://github.com/user-attachments/assets/758f509e-4893-495c-96a9-60e2048aea6e)
  ![image](https://github.com/user-attachments/assets/cead8306-d535-4d46-9d62-3acafe36352b)
- 因为不符合 1<= 根节点元素个数 <= 4，进行分裂（ 真实情况是先分裂，然后插入元素，这里是为了直观而先插入元素，下面的操作都一样，不再重复说明 ），取节点中间元素 [7]，加入到父节点，左右分裂为 2 个节点，如图（3）
  ![image](https://github.com/user-attachments/assets/a7223a08-6214-42ab-bb63-00652bd94bb7)
- 接着插入元素 [5]，[11]，[17] 时，不需要任何分裂操作，如图（4）
  ![image](https://github.com/user-attachments/assets/3d9b6c20-a4ae-4299-a588-9942729c981f)
- 插入元素 [13]，如图（5），节点元素超出最大数量，进行分裂，提取中间元素 [13]，插入到父节点当中，如图（6）
  ![image](https://github.com/user-attachments/assets/25593881-3aae-4701-b532-1ad990c268c5)
  ![image](https://github.com/user-attachments/assets/26b18ca2-eb42-498c-8e0a-78e826ac4dc4)
- 接着插入元素 [6]，[12]，[20]，[23]时，不需要任何分裂操作，如图（7）
  ![image](https://github.com/user-attachments/assets/2007fa6c-aa6c-49e2-92f6-3b1f3424ec70)
- 插入 [26] 时，最右的叶子结点空间满了，需要进行分裂操作，中间元素 [20] 上移到父节点中，注意通过上移中间元素，树最终还是保持平衡，分裂结果的结点存在 2 个关键字元素，如图（8）
  ![image](https://github.com/user-attachments/assets/8e09322c-3b3a-41a6-8c31-a40b75ff829e)
- 插入 [4] 时，导致最左边的叶子结点被分裂，[4] 恰好也是中间元素，上移到父节点中，然后元素 [16]，[18]，[24]，[25] 陆续插入不需要任何分裂操作，如图（9）
  ![image](https://github.com/user-attachments/assets/e311b55c-b4a5-482f-8156-5d640342a3d3)
- 最后，当插入 [19] 时，含有 [14]，[16]，[17]，[18] 的结点需要分裂，把中间元素 [17] 上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素 [13] 上移到新形成的根结点中，这样具体插入操作的完成，如图（10）
  ![image](https://github.com/user-attachments/assets/968fafa1-e698-48f2-8650-307f570e21b0)

## 3. 删除操组

#### 3.1 删除步骤

- 首先查找 B 树中需删除的元素，如果该元素在 B 树中存在，则将该元素在其节点中进行删除
- 删除该元素后，首先判断该元素是否有左右孩子结点
  - 如果有，则上移孩子结点中的某相近元素（ “左孩子最右边的节点” 或 “右孩子最左边的节点” ）到父节点中，然后是移动之后的情况
  - 如果没有，则分情况讨论
    - 如果删除后，节点中元素数目大于等于（ m / 2 ）- 1，则不需要处理
    - 如果删除后，节点中元素数目小于（ m / 2 ）- 1，则需要看其某相邻兄弟结点是否丰满
      - 如果相邻兄弟结点丰满，则借一个过来
      - 如果相邻兄弟结点不丰满，则合并

#### 3.2 删除举例

- 以 5 阶 B 树为例，详细讲解删除的动作
- 依次删除依次删除 [8]，[20]，[18]，[5]
  ![image](https://github.com/user-attachments/assets/f789e325-b5b6-4942-8bcc-77964447c848)
- 首先删除元素 [8]，首先查找 [8]，[8] 在一个叶子结点中，删除后该叶子结点元素个数为 2，符合 B 树规则，操作很简单，只需要移动 [11] 至原来 [8] 的位置，移动 [12] 至 [11] 的位置，也就是结点中删除元素后面的元素向前移动
  ![image](https://github.com/user-attachments/assets/d843c9e9-6a36-4f0f-9692-70aad18186d0)
- 下一步，删除 [20]，因为 [20] 没有在叶子结点中，而是在中间结点中找到。它的子节点 [23] 是升序的下个元素，将 [23] 上移到 [20] 的位置，然后将孩子结点中的 [23] 进行删除。这里删除后，该子结点中元素个数大于 2，无需进行合并操作
  ![image](https://github.com/user-attachments/assets/8a2c6fc6-fbf8-4cd4-a65e-0ae958adaf62)
- 下一步删除 [18]，[18] 在叶子结点中。该结点中元素数目为 2，删除后导致只有 1 个元素，已经小于最小元素数目 2。如果其某个相邻兄弟结点中比较丰满（ 元素个数大于 ceil(5/2) - 1 = 2 ），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中，在这个实例中，右相邻兄弟结点中比较丰满（ 3 个元素大于 2 ），所以先向父节点借一个元素 [23] 下移到该叶子结点中，代替原来 [19] 的位置，[19] 前移；然[24] 在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除 [24]，后面元素前移
  ![image](https://github.com/user-attachments/assets/77593903-d6ad-493b-addc-00db46bae711)
- 最后一步删除 [5]， 删除后会导致很多问题，因为 [5] 所在的结点数目刚好达标，刚好满足最小元素个数（ ceil(5 / 2) - 1 = 2 ），而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作。首先移动父结点中的元素（ 该元素在两个需要合并的两个结点元素之间 ）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，首先将父节点中的元素 [4] 下移到已经删除 [5] 而只有 [6] 的结点中，然后将含有 [4] 和 [6] 的结点和含有 [1]，[3] 的相邻兄弟结点进行合并成一个结点
  ![image](https://github.com/user-attachments/assets/7e455543-b7dd-4023-b002-590c2e0a74c4)
- 但是这样父节点只包含一个元素 [7]，没达标（ 因为非根节点包括叶子结点的元素 K 必须满足于 2 =< K <= 4，而此处的 K = 1 ）。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。而此时兄弟节点元素刚好为 2，刚刚满足，只能进行合并，而根结点中的唯一元素 [13] 下移到子结点，这样，树的高度减少一层
  ![image](https://github.com/user-attachments/assets/c540fed3-2c40-430c-9b5a-4777d880bd42)

## 4. 预读

- 磁盘 IO：
  - 磁盘（ ms 级别 ）<< 内存（ ns 级别 ），100000 倍，因此磁盘 IO 的成本非常昂贵
- 预读：
  - 从磁盘中读 1 B，与读写 1KB 的时间成本几乎一样
  - 当计算机访问一个地址的数据的时候，与其相邻的数据也会很有可能被访问到
  - 当一次 IO 时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内。每一次 IO 读取的数据称之为一页。具体一页有多大数据跟操作系统有关，一般为 4k 或 8k，也就是当读取一页内的数据时候，实际上才发生了一次 IO
- 因此要尽可能减少 I/O，进行预读。假设，一次硬盘一次 I/O 数据为 8K，索引用 int（ 4 字节 ）类型数据建立，理论上一个节点最多可以为 2000 个元素，2000 ^ 2000 ^ 2000 = 8000000000，理论上 80 亿条的数据只需 3 次 I/O

## 5. B+ 树

#### 5.1 介绍

- B+ 树是应文件系统所需而产生的 B 树的变形树
  ![image](https://github.com/user-attachments/assets/aaa95ae1-cd70-4ca7-959c-19b5fee2bb61)
  ![image](https://github.com/user-attachments/assets/144e3073-a187-4e56-a4c5-317d60609b5a)
  ![image](https://github.com/user-attachments/assets/2123fd96-63e8-439a-8d82-a0b61a899a7c)
- B+ 树相比于 B 树的特征：
  - B+ 树与 B 树最大的不同是**内部结点不保存数据，只用于索引，所有数据都保存在叶子结点中**
  - 有 k 个子树的中间节点包含有 k 个元素（ B 树中是 k - 1 个元素 ），每个元素不保存数据，只用来索引
  - 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（ 或最小 ）关键字（ 而 B 树的非终节点也包含需要查找的有效信息 ）

#### 5.2 B+ 优点

- B+ 树比 B 树更适合数据库索引的原因如下
- B+ 树的磁盘读写代价更低
  - B+ 树的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对 B 树更小
  - 如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说 IO 读写次数也就降低了
- B+ 树查询效率更加稳定
  - 由于 B+ 任何关键字的查找必须找到叶子结点才能找到，所以所有关键字查询的路径长度相同，导致每一个数据的查询效率相当
- B+ 树便于范围查询（ 是最重要的原因，因为范围查找是数据库的常态 ）
  - B 树在提高了 IO 性能的同时并没有解决元素遍历的效率低下的问题
  - B+ 树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而 B 树不支持这样的操作或者说效率太低
  - B 树的范围查询用的是中序遍历，而 B+ 树用的是在链表上遍历

## 6. 范围查询

- B 树范围查询
  - 比如我们查询 5 到 15 的数据。当查询到 8 之后，我们还需要回的根节点在进行查询，会增加我们的 IO 读取次数
    ![image](https://github.com/user-attachments/assets/0cb80965-6542-48b7-91c6-55cf16238005)
- B+ 树范围查询
  - B+ 树的叶子节点是一个双向有序列表，每个磁盘块会通过一个指针想联，当我们查询 5 到 10 的数据时。只需要通过查询到磁盘块 5，在查询磁盘块 8，10... 即可，不需要返回到上一节点或者根节点
    ![image](https://github.com/user-attachments/assets/6d19cc78-1a44-46bc-ba97-9de662a81e09)
