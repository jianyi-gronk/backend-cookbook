## 1. 磁盘 IO（ 题外话 ）

- 磁盘读写时涉及到磁盘上数据查找，地址一般由柱面号、盘面号和块号三者构成。也就是说移动臂先根据柱面号移动到指定柱面，然后根据盘面号确定盘面的磁道，最后根据块号将指定的磁道段移动到磁头下，便可开始读写
- 整个过程主要有三部分时间消耗，查找时间 + 等待时间 + 传输时间
  - 查找时间：定位柱面的耗时
  - 等待时间：将块号指定磁道段移到磁头的耗时
  - 传输时间将数据传到内存的耗时
- 整个磁盘 IO 最耗时的地方在查找时间，所以减少查找时间能大幅提升性能

## 2. 基础概念

- LSM-Tree 全称是 Log Structured Merge Tree（ 日志结构合并树 ），其实它并不属于一个具体的数据结构，它更多是一种数据结构的设计思想。 大多 NoSQL 数据库核心思想都是基于 LSM 来做的， 只是具体的实现不同
  ![image](https://github.com/user-attachments/assets/6af0a478-1b61-48a2-9286-7be84c35d2f1)

#### 2.1 算法背景

- 传统关系型数据库使用 B 树或一些变体作为存储结构，能高效进行查找。但保存在磁盘中时它也有一个明显的缺陷，那就是逻辑上相离很近但物理却可能相隔很远，这就可能造成大量的磁盘随机读写
- 随机写比顺序写慢很多，为了提升 IO 性能，我们需要一种能将随机操作变为顺序操作的机制，于是便有了 LSM 树
- LSM 树具有批量特性，存储延迟能让我们进行顺序写磁盘，从而大幅提升写操作，作为代价的是牺牲了一些读性能。因此 LSM 树相比于 B 树更适合读少写多的场景

#### 2.2 核心思路

- **本质就是 B+ 树是把所有需要写入的数据，一个一个写入磁盘中，而 LSM 树是把需要写入的数据在内存中存储并排完序后，一次性写入磁盘队尾**
- 所以 LSM 的存储磁盘是由一个个小的有序的数据块组成，比如每 m 个数据，在内存里排序一次，这样依次做下去，总共有 N 条数据，就可以获得 N / m 个有序的小的有序结构
- 只有内存中数据允许原地更新，磁盘上数据的变更只允许追加写，不做原地更新
- 但是 LSM 树对于磁盘索引树的合并步骤比较繁琐

#### 2.3 LSM 索引

- LSM 树是一个横跨内存和磁盘的，包含多颗 “子树” 的一个森林
- LSM 树由两个或以上的存储结构组成，比如在论文中为了方便说明使用了最简单的两个存储结构
  - 一个存储结构常驻内存中（ C0 tree ），具体可以是任何方便健值查找的数据结构，一般采用排序树，比如红黑树、map 之类，甚至可以是跳表
  - 另外一个存储结构常驻在硬盘中（ C1 tree ... Cn tree ），具体结构类似 B 树。其所有节点都是 100% 满的，节点的大小为磁盘块大小
    ![image](https://github.com/user-attachments/assets/94acddb8-4b59-4a02-9852-6b064cca848a)
- 每一层的子树都有一个阈值大小，达到阈值后会进行合并，合并结果写入下一层

## 3. 插入操作

#### 3.1 插入步骤

- 插入索引具体步骤为：
  - 插入一条新数据时，首先在日志文件中插入操作日志，以便后面恢复使用，日志是以 append 形式插入，所以速度非常快
  - 将新纪录的索引插入到 C0 中，这里在内存中完成，不涉及磁盘 IO 操作
  - 当 C0 大小达到某一阈值时或者每隔一段时间，将 C0 中记录滚动合并到磁盘 C1 中
  - 对于多个存储结构的情况，当 C1 体量越来越大就向 C2 合并，以此类推，一直往上合并 Ck
- 插入数据具体步骤为：
  - 先存入内存中，并保持有序
  - 最后一次性写入磁盘队尾
- 如图
  ![image](https://github.com/user-attachments/assets/fd038c20-0c23-4274-b618-8b1b30f837e8)

#### 3.2 合并步骤

- 合并过程中会使用两个块：emptying block 和 filling block
- 具体步骤为：
  - 从 C1 中读取未合并叶子节点，放置内存中的 emptying block 中
  - 从小到大找 C0 中的节点，与 emptying block 进行合并排序，合并结果保存到 filling block 中，并将 C0 对应的节点删除
  - 不断执行第 2 步操作，合并排序结果不断填入 filling block 中，当其满了则将其追加到磁盘的新位置上，注意是追加而不是改变原来的节点
  - 合并期间如果 emptying block 使用完了则再从 C1 中读取未合并的叶子节点。C0 和 C1 所有叶子节点都按以上合并完成后即完成一次合并

#### 3.3 插入举例

- 比如向 LSM 树中插入 A E L R U
- 首先会插入到内存中的 C0 树上，这里使用 AVL 树（ 自平衡二叉查找树 ），插入 A，先向磁盘日志文件追加记录，然后再插入 C0
  ![image](https://github.com/user-attachments/assets/3179b7d5-4467-426f-8321-36df07cb0963)
- 继续依次插入 E，L，R，U，同样先追加日志再写内存，旋转后如下（ 可以看到有序的数据被一次性写入磁盘队尾 ）
  ![image](https://github.com/user-attachments/assets/02241325-ffca-475e-aa1c-f95230d96b4c)
- 假设此时触发合并，则因为 C1 还没有树，所以 emptying block 为空，直接从 C0 树中依次找最小的节点。filling block 长度为 4，这里假设磁盘块大小为 4。开始找最小的节点，并放到 filling block 中
  ![image](https://github.com/user-attachments/assets/7da4695b-4377-4f24-b676-eeb28d9dd0a9)
- 以此类推，填满 filling block，注意填的时候要删掉内存中的值
  ![image](https://github.com/user-attachments/assets/0bdddfe0-07ab-4687-b543-05758b251739)
- 开始写入磁盘，C1 树，并继续插入 B，F，N，T，先分别写日志，然后插入到内存的 C0 树中
  ![image](https://github.com/user-attachments/assets/2f0e2328-bebf-48cb-aa98-019a3e2f5f2d)
- 假如此时进行合并，先加载 C1 的最左边叶子节点到 emptying block
  ![image](https://github.com/user-attachments/assets/b4c1016d-2e9c-4d88-b215-3effde985eb4)
- 接着对 C0 树的节点和 emptying block 进行合并排序，首先是 A 进入 filling block
  ![image](https://github.com/user-attachments/assets/7ef4e038-8609-49c0-a45f-42d3edd87c59)
- 然后是 B
  ![image](https://github.com/user-attachments/assets/29768958-fab8-4b5b-8a9c-084fcdc15101)
- 合并排序最终结果为
  ![image](https://github.com/user-attachments/assets/38edfe59-029e-4232-bd11-3877e4f70599)
- 将 filling block 追加到磁盘的新位置，将原来的节点删除掉
  ![image](https://github.com/user-attachments/assets/166361ff-09ac-4071-951b-fa0aab39682f)
- 继续合并排序，再次填满 filling block
  ![image](https://github.com/user-attachments/assets/9dfdfb6a-8124-4821-aef3-1ff9179edec7)
- 将 filling block 追加到磁盘的新位置，上一层的节点也要以磁盘块（ 或多个磁盘块 ）大小写入，尽量避开随机写。另外由于合并过程可能会导致上层节点的更新，可以暂时保存在内存，后面在适当时机写入
  ![image](https://github.com/user-attachments/assets/d1c72c5c-2341-4496-b9f1-407d8a951939)

## 4. 查询操作

- 查找总体思想是先找内存的 C0 树，找不到则找磁盘的 C1 树，然后是 C2 树，以此类推
- 假如要找 B，先找 C0 树，没找到
  ![image](https://github.com/user-attachments/assets/da00959f-6844-460d-9853-85ac38f07644)
- 接着找 C1 树，从根节点开始，然后找到 B
  ![image](https://github.com/user-attachments/assets/55e34226-fc97-4e96-a428-27790f416811)

## 5. 删除操作

- 删除操作为了能快速执行，主要是通过标记来实现，在内存中将要删除的记录标记一下，后面异步执行合并时将相应记录删除。注意，不操作磁盘的数据，磁盘 IO 太浪费时间了
- 比如要删除 U，假设标为 # 的表示删除，则 C0 树的 U 节点变为
  ![image](https://github.com/user-attachments/assets/7d2947fd-6bc2-4dd0-8f9d-9a67fc64fc5e)
- 而如果 C0 树不存在的记录，则在 C0 树中生成一个节点，并标为#，查找时就能在内存中得知该记录已被删除，无需去磁盘找了。比如要删除 B，那么没有必要去磁盘执行删除操作，直接在 C0 树中插入一个 B 节点，并标为 #
  ![image](https://github.com/user-attachments/assets/72f8d5e4-7384-44d0-b1a6-a0f17043aefc)
