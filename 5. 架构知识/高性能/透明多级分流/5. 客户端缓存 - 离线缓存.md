## 1. 离线缓存

- 离线缓存指的是在没有网络连接的情况下，浏览器仍然能够加载和显示之前已经缓存的网页或应用程序的内容。离线缓存可以提供更好的用户体验，使用户能够访问应用程序或网页的基本功能，即使在没有网络连接的情况下也能够正常工作
- 离线缓存通常使用浏览器的缓存存储功能，来存储网页的静态资源（如 HTML、CSS、JavaScript、图像等）。当用户首次访问网页时，浏览器会将网页的静态资源缓存到本地。在之后的访问中，如果用户处于离线状态，浏览器会尝试从本地缓存加载已经缓存的资源，而不是从服务器重新请求。这样，即使没有网络连接，用户仍然可以浏览和使用已经缓存的网页
- 离线缓存对于需要频繁访问的应用程序或网页非常有用，特别是在网络连接不稳定或不可靠的环境中，例如移动设备或边缘网络。它可以提供更好的用户体验，并确保应用程序或网页的基本功能仍然可用

## 2. Application Cache

[详细介绍](https://blog.csdn.net/weixin_44198965/article/details/89760924)

#### 2.1 基础介绍

- manifest 的技术已被 web 标准废弃，不再推荐使用此功能，取而代之的是 Service Workers 和 Cache API 技术，这些技术提供了更加灵活、可控的缓存策略，以及更好的离线应用支持，原因如下
  - 缓存更新问题：AppCache 的更新机制可能导致用户获取到过期或不正确的资源。并且即使只更改了一个小文件，也需要更新整个缓存，这会浪费用户的带宽和设备存储空间
  - 缓存资源不灵活：AppCache 只能缓存在 manifest 文件中指定的资源。如果需要动态缓存新的资源或者根据用户行为缓存资源，AppCache 无法满足需求
  - 隐式缓存：AppCache 会自动缓存与 manifest 文件相关联的所有页面，这可能导致开发者无意间缓存了不需要缓存的页面
  - 缺乏细粒度控制：AppCache 不允许开发者对缓存资源进行详细的控制，如何处理缓存更新以及如何响应特定的网络状态
  - 安全问题：AppCache 只支持在安全上下文（如 HTTPS）中使用，但其实现可能存在一些安全隐患
- HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有网络连接时进行访问
- 一旦应用被缓存，它就会保持缓存直到发生下列情况：
  - 用户清空浏览器缓存
  - manifest 文件被修改
  - 由程序来更新应用缓存
- 以 "#" 开头的是注释行，但也可满足其他用途。应用的缓存会在其 manifest 文件更改时被更新。一旦文件被缓存，则浏览器会继续展示已缓存的版本，即使您修改了服务器上的文件，比如编辑了一幅图片，或者修改了一个 JavaScript 函数，这些改变都不会被重新缓存。为了确保浏览器更新缓存，需要更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法
- 服务器负责管理维护 .appcache 文件，检查并及时更新，通过在响应中将 Content-Type 设置为"text/cache-manifest"，浏览器会将响应的内容视为应用程序缓存清单文件，进而按照缓存清单文件的规则进行处理
- 浏览器对缓存数据的容量限制可能不太一样（ 大部分浏览器设置的限制是每个站点 5 MB ）

#### 2.2 基础使用

- 使用方式在 html 标签中添加 mainfest 属性，属性值为自定义缓存的文件，例

  ```javascript
  <html mainfest="myApplication.appcache">
  ```

  - 每个指定了 manifest 的页面在用户对其访问时都会被缓存，即会缓存包含 manifest 清单的页面，即使不在 manifest 缓存清单中。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）

- 缓存内容写入 cache manifest 文件，它是简单的文本文件，可以告知浏览器被缓存的内容，以及不缓存的内容（ W3C 建议文件扩展名为 .appcache ），例

  ```
  // myApplication.appcache 文件

  CACHE MANIFEST
  # 2023-07-30 v1.0.0

  CACHE:   # 这一行可要可不要
  # 当 manifest 文件加载后，浏览器会从网站的根目录下载这三个文件
  # 然后，无论用户何时与因特网断开连接，这些资源依然是可用的
  /theme.css
  /logo.gif
  /main.js

  NETWORK:
  # 也可以使用星号来指示所有其他资源/文件都需要因特网连接
  login.php

  FALLBACK:
  /html/ /offline.html   # 第一个 URI 是资源，第二个是替补
  ```

  - CACHE MANIFEST（是必需的）：第一行 CACHE MANIFEST 是固定的格式，且必须要写在第一行，作为本文件标识。在此标题下列出的文件将在首次下载后进行缓存（ 文件位置根据文件在服务器的实际目录，确保路径正确 ）
  - CACHE（可有可无）：在此标题下列出的文件将在首次下载后进行缓存
  - NETWORK（可有可无）：在此标题下列出的文件需要与服务器的连接，且不会被缓存（ 注意不要把首页 index 放入 NETWORK 中禁止缓存，否则插件等无法使用 ）
  - FALLBACK（可有可无）：在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）

## 3. Cache Stroage

#### 3.1 基础介绍

- Cache Storage 是一种浏览器 API，它不是直接对数据进行缓存，而是用于在客户端缓存中存储和检索网络请求的响应数据，以便在后续的请求中直接使用缓存的响应，而不需要再次向服务器发送请求
- Cache Storage 主要用于缓存静态资源，例如 HTML、CSS、JavaScript 文件、图像和其他媒体文件等。它可以帮助提高网页的加载速度和性能，减少对服务器的请求次数，同时也可以使网页在离线状态下正常工作
- Cache Storage 提供了一个类似于字典的接口，可以通过键值对的方式操作缓存，每个缓存条目由一个唯一的键和与之关联的响应组成

#### 3.2 CacheStorage 常用 API

- 判断 Cache 对象是否存在
  - caches.has(cacheName)
    - 判断是否存在指定名称的 Cache 对象，返回一个 Promise 对象，缓存存在时 resolve 的布尔值为 true 否则为 false
- 创建 或 打开 Cache 对象
  - caches.open(cacheName)
    - 打开一个指定名称的 Cache 对象。如果 Cache 不存在，则会创建一个新的 Cache。返回一个 Promise 对象，可以使用 then() 方法来获取打开的 Cache 对象
- 匹配请求
  - caches.match(request, options)
    - 是一个便捷方法。其作用等同于在每个缓存上调用 cache.match() 方法（按照 caches.keys()返回的顺序 ）直到返回 Response 对象
- 删除 Cache 对象
  - caches.delete(cacheName)
    - 查找匹配 cacheName 的 Cache 对象，如果找到，则删除 Cache 对象并返回一个 resolve 为 true 的 Promise . 如果未找到 Cache 对象，则返回 false
- 获取所有 Cache 对象集合
  - caches.keys()
    - 返回一个 Promise 对象，它使用一个数组 resolve，该数组包含 CacheStorage 对象按创建顺序跟踪的所有命名 Cache 对象对应的字符串

#### 3.3 Cache 常用 API

- 存储或更新响应：

  - cache.put(request, response)
    - 将指定请求的响应存储到缓存中。可用于更新缓存中的响应。返回一个 Promise 对象，表示存储操作的完成状态
  - cache.add(request)
    - 接受一个 URL 作为参数，请求参数指定的 URL，并将返回的 response 对象添加到给定的 cache 中。返回一个 Promise 对象，表示添加操作的完成状态
  - cache.addAll(requests)
    - 一次性向缓存中添加多个请求的响应。它会发起多个网络请求并将响应存储到缓存中。返回一个 Promise 对象，表示添加操作的完成状态
  - cache.add 或 cache.addAll 不会缓存 Response.status 值不在 200 范围内的响应，而 cache.put 允许你存储任何请求/响应对。因此，cache.add 或 cache.addAll 不能用于不透明的响应，而 cache.put 可以
  - cache.add、cache.addAll 和 cache.put，即使响应主体仍在流式传输，一旦条目被记录到数据库中，浏览器就可以 resolve 返回的 promise
  - 通常，若只想 fetch() 一个或多个请求，然后直接添加结果到 cache 中。这种情况下，最好使用 cache.add() 或 cache.addAll()，因为它们是一个或者多个这些操作的便捷方法

    ```
    cache.add(url)

    // 等效于

    fetch(url).then(function (response) {
        if (!response.ok) {
          throw new TypeError('bad response status');
        }
        return cache.put(url, response);
    })
    ```

- 获取响应
  - cache.match(request, options)
    - 根据请求从缓存中获取匹配的响应。如果找到匹配的响应，则返回一个 Promise 对象，表示获取操作的完成状态。如果没有找到匹配的响应，则返回 undefined
  - cache.matchAll(request, options)
    - 根据请求和选项从缓存中获取所有匹配的响应。返回一个 Promise 对象，表示获取操作的完成状态。可以使用 options 对象来指定匹配的策略，如忽略查询字符串、忽略 Vary 头等
- 删除缓存
  - cache.delete(request, options)
    - 搜索 key 值为 request 的 Cache 条目。如果找到，则删除该 Cache 条目，并且返回一个 resolve 为 true 的 Promise 对象；如果未找到，则返回一个 resolve 为 false 的 Promise 对象
- 查找缓存集合
  - cache.keys(request, options)
    - 根据请求和选项获取缓存中所有匹配的键。返回一个 Promise 对象，表示获取操作的完成状态

#### 3.4 基础样例

- 简单来说，逻辑就是，首次注册或者更新 Service Worker 的时候，创建 或 打开 指定 Cache 对象，将需要离线缓存的请求数据放进去
- 当每次 fetch 请求数据时，若请求成功，则正常拿到数据，并将 Cache 对象身上的数据更新；若请求失败，则返回之前缓存过的数据

```
// 当浏览器检测到新的 Service Worker 文件时，会触发 install 事件
// 1. 当首次注册 Service Worker 文件时，浏览器会下载 Service Worker 文件，并在下载完成后触发 install 事件
// 2. 当已注册的 Service Worker 文件变化时，浏览器会重新下载新 Service Worker 文件，并在下载完成后触发 install 事件

this.addEventListener('install', function(event) {
   event.waitUntil(
      caches.open('v1').then(function(cache) {
          return cache.addAll([
            '/sw-test/',
            '/sw-test/index.html',
            '/sw-test/style.css',
            '/sw-test/app.js',
            '/sw-test/image-list.js',
            '/sw-test/star-wars-logo.jpg',
            '/sw-test/gallery/bountyHunters.jpg',
            '/sw-test/gallery/myLittleVader.jpg',
            '/sw-test/gallery/snowTroopers.jpg'
          ]);
      })
    );
});

this.addEventListener('fetch', function(event) {
    var response;
    event.respondWith(caches.match(event.request).catch(function() {
      return fetch(event.request);
    }).then(function(r) {
      response = r;
      caches.open('v1').then(function(cache) {
          cache.put(event.request, response);
      });
      return response.clone();
    }).catch(function() {
      return caches.match('/sw-test/gallery/myLittleVader.jpg');
    }));
});
```

## 4. Service Worker （ 也叫 sw 缓存 ）

[详情介绍](https://blog.csdn.net/huangpb123/article/details/89498418)，[详情介绍](https://www.jianshu.com/p/8c0fc2866b82)

#### 4.1 基础介绍

- Service Worker 是基于 Web Worker 的技术，它们共享一些相同的基本特性，如在后台执行任务、无法访问 DOM，需要通过 postMessage 来传递数据给其他文件等。但 Service Worker 针对特定场景进行了扩展，所以两者针对的场景不同，具体区别如下：
  - Service Worker：
    - 主要用于实现离线缓存、网络代理和推送通知等功能
    - 只能在 HTTPS 网站，或者本地的 localhost 环境下使用
    - 是一种可编程网络代理，允许您在浏览器与网络之间控制请求和响应
    - 有自己的生命周期，不依赖于网页，可以在网页关闭后继续运行
    - 不能直接操作 DOM
    - 可以作为 Web Worker 使用，但具有更多功能和限制
  - Web Worker：
    - 主要用于在后台执行计算密集型任务，如图像处理、大数据处理等，以避免阻塞主线程
    - 可以在 HTTP 和 HTTPS 网站，或者本地的 localhost 环境下使用
    - 不能访问网络请求和响应
    - 生命周期依赖于与其关联的网页，当网页关闭时，Web Worker 会被终止
    - 不能直接操作 DOM
    - 主要用途是在不影响用户界面的情况下运行耗时的任务
- 可以理解为一个介于客户端和服务器之间的一个代理服务器，在 Service Worker 中可以做很多事情，比如拦截客户端的请求、向客户端发送消息、向服务器发起请求等等，其中最重要的作用之一就是离线资源缓存
- 兼容性不大行，IE 和 Opera Mini 全面扑街，而主流浏览器中 Edge 17 以下不支持，Safair 和 IOS Safair 刚刚开始支持，而火狐和 Chrome 支持良好，所以大家可以使用，不过最好还是做一下判断

#### 4.2 生命周期

- 注册（Registration）：
  - 开发者需要在网页的 JavaScript 代码中注册 Service Worker。注册时，需要提供 Service Worker 文件的 URL。浏览器会在后台下载并尝试安装 Service Worker
  - register 方法中第一个参数表示 service-worker.js 相对于 origin 的路径，第二个参数是 Serivce Worker 的配置项，可选填，其中比较重要的是 scope 属性，用来指定想让 service worker 控制的内容的目录。 默认值为 service-worker.js 所在的目录。这个属性所表示的路径不能在 Service Worker 文件的路径之上
  ```javascript
  if ('serviceWorker' in navigator) {
  	navigator.serviceWorker
  		.register('/service-worker.js')
  		.then((registration) => {
  			console.log('Service Worker 注册成功：', registration)
  		})
  		.catch((error) => {
  			console.log('Service Worker 注册失败：', error)
  		})
  }
  ```
- 安装（Installation）：
  - 当浏览器成功下载 Service Worker 文件后，将触发安装过程。在这个阶段，通常会执行一些预缓存任务，例如缓存应用的静态资源（HTML、CSS、JavaScript、图片等）。安装过程中，可以监听 install 事件并定义相应的操作
  ```javascript
  self.addEventListener('install', (event) => {
  	event.waitUntil(
  		caches.open('my-cache').then((cache) => {
  			return cache.addAll([
  				/* 需要缓存的资源列表 */
  			])
  		}),
  	)
  })
  ```
- 激活（Activation）：
  - 如果安装成功且没有发生错误，Service Worker 将进入激活阶段。在这个阶段，可以执行一些清理工作，例如清除旧的缓存。激活过程中，可以监听 activate 事件并定义相应的操作。值得注意的是，如果网站上已经有一个激活的 Service Worker，新的 Service Worker 通常需要等待旧的 Service Worker 不再控制任何客户端后才能激活。但可以通过 self.skipWaiting() 方法来跳过等待，使新的 Service Worker 立即取代旧的 Service Worker
  ```javascript
  self.addEventListener('activate', (event) => {
  	event.waitUntil(
  		caches.keys().then((cacheNames) => {
  			return Promise.all(
  				cacheNames.map((cacheName) => {
  					if (cacheName !== 'my-cache') {
  						return caches.delete(cacheName) // 清除旧的缓存
  					}
  				}),
  			)
  		}),
  	)
  	self.clients.claim() // 立即接管所有客户端
  })
  ```
- 运行（Running）：

  - 当 Service Worker 成功激活后，它将进入运行状态。此时，Service Worker 可以监听和处理来自网页的各种事件，如 fetch、push 和 sync 等。在运行阶段，Service Worker 可以拦截和处理网络请求，实现离线缓存、推送通知等功能

  ```javascript
  self.addEventListener('fetch', (event) => {
  	event.respondWith(
  		caches.match(event.request).then((response) => {
  			if (response) {
  				return response // 从缓存中返回请求的资源
  			}
  			return fetch(event.request) // 否则从网络请求资源
  		}),
  	)
  })

  self.addEventListener('push', (event) => {
  	// 处理推送通知
  })

  self.addEventListener('sync', (event) => {
  	// 处理后台同步
  })
  ```

- 终止（Termination）：
  - 浏览器可能会在某些情况下终止 Service Worker，例如在内存不足时。当需要的时候，浏览器会自动重新启动 Service Worker，或者手动卸载
  ```javascript
  navigator.serviceWorker.getRegistrations().then(function (registrations) {
  	for (let registration of registrations) {
  		//安装在网页的service worker不止一个，找到我们的那个并删除
  		console.log(registration)
  		if (registration && registration.scope === 'http://localhost:8080/') {
  			registration.unregister()
  		}
  	}
  })
  ```
- 更新（Update）：
  - 当网站部署了新版本的 Service Worker 时，浏览器会在后台下载新的 Service Worker 文件，并尝试安装。如果新的 Service Worker 安装成功，将触发更新过程。新的 Service Worker 会等待旧的 Service Worker 不再控制客户端后进入激活状态，或者通过 self.skipWaiting() 方法立即激活。更新后的 Service Worker 接管网站后，将从头开始执行安装、激活、运行等生命周期阶段

## 5. 离线缓存（ sw 缓存 ） 和 Local Storage 的差异

- 存储容量：
  - 离线缓存：离线缓存的容量通常较大，不同浏览器的实际限制可能有所不同，但一般可以达到几十兆甚至更高。这使得离线缓存适合存储较大的网络资源，如图片、视频等
  - Local Storage：Local Storage 的存储容量通常较小，一般为每个域名 5MB 左右。这使得 Local Storage 不适合存储较大的网络资源
- 存储类型：
  - 离线缓存：离线缓存可以存储各种类型的网络资源，如 HTML、CSS、JavaScript、图片、视频等。这些资源可以通过 Service Worker 进行缓存和管理
  - Local Storage：Local Storage 只能存储字符串类型的键值对数据。对于非字符串类型的数据，需要进行序列化和反序列化操作
- 存取性能：
  - 离线缓存：离线缓存通过 Service Worker 进行资源的缓存和读取，这是一个基于 JavaScript 的 Worker 线程，与主线程（UI 线程）独立运行，因此不会阻塞主线程
  - Local Storage：Local Storage 的存取操作是同步的，这意味着在读写 Local Storage 时，主线程（UI 线程）会被阻塞。因此，频繁读写 Local Storage 可能会影响页面性能

## 6. 离线缓存（ sw 缓存 ）和 HTTP 缓存的差异

- 缓存控制
  - 离线缓存：由前端控制，可以更好的控制缓存
  - HTTP 缓存：由服务器端通过响应头来控制
- 控制粒度：
  - 离线缓存：Service Worker 提供了灵活的缓存控制，开发者可以针对不同的资源和请求策略进行精细化的控制。例如，可以实现预缓存、运行时缓存、缓存优先、网络优先等策略。此外，Service Worker 还支持后台更新和缓存清理等功能
  - HTTP 缓存：HTTP 缓存的控制粒度较低，主要通过服务器设置 HTTP 头来控制浏览器的缓存行为。虽然可以通过设置 Cache-Control、Expires 等 HTTP 头实现一定程度的缓存控制，但相较于 Service Worker，HTTP 缓存的控制粒度和灵活性较低
- 是否依赖网络连接：
  - 离线缓存：因为是否使用缓存由前端自己控制，所以离线状态下，不需要请求，可以正常加载资源
  - HTTP 缓存：本质还是依赖网络连接，需要由响应头来决定是否使用缓存的资源，但在离线状态下，浏览器无法与服务器通信，可能导致某些资源无法加载
