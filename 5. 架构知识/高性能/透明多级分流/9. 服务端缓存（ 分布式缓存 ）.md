## 1. 分布式缓存

- 相比起缓存数据在进程内存中读写的速度，一旦涉及网络访问，由网络传输、数据复制、序列化和反序列化等操作所导致的延迟要比内存访问高得多，所以对分布式缓存来说，处理与网络有相关的操作是对吞吐量影响更大的因素，往往也是比淘汰策略、扩展功能更重要的关注点
- 这决定了尽管也有 Ehcache、Infinispan 这类能同时支持分布式部署和进程内嵌部署的缓存方案，但通常进程内缓存和分布式缓存选型时会有完全不同的候选对象及考察点

## 2. 确定需求

- 我们决定使用哪种分布式缓存前，首先必须确认自己需求是什么
- 从访问的角度来说，如果是频繁更新但甚少读取的数据，通常是不会有人把它拿去做缓存的，因为这样做没有收益
- 对于甚少更新但频繁读取的数据，理论上更适合做复制式缓存
- 对于更新和读取都较为频繁的数据，理论上就更适合做集中式缓存

## 3. 复制式缓存

#### 3.1 原理

- 复制式缓存可以看作是 “能够支持分布式的进程内缓存”，它的工作原理与 Session 复制类似
- 缓存中所有数据在分布式集群的每个节点里面都存在有一份副本，读取数据时无须网络访问，直接从当前节点的进程内存中返回，理论上可以做到与进程内缓存一样高的读取性能
- 当数据发生变化时，就必须遵循复制协议，将变更同步到集群的每个节点中，复制性能随着节点的增加呈现平方级下降，变更数据的代价十分高昂

#### 3.2 JBossCache

- 复制式缓存的代表是 JBossCache，这是 JBoss 针对企业级集群设计的缓存方案，支持 JTA 事务，依靠 JGroup 进行集群节点间数据同步
- 以 JBossCache 为典型的复制式缓存曾有一段短暂的兴盛期，但今天基本上已经很难再见到使用这种缓存形式的大型信息系统了，JBossCache 被淘汰的主要原因是写入性能实在差到不堪入目的程度
- 它在小规模集群中同步数据尚算差强人意，但在大规模集群下，很容易就因网络同步的速度跟不上写入速度，进而导致在内存中累计大量待重发对象，最终引发 OutOfMemory 崩溃。如果对 JBossCache 没有足够了解的话，稍有不慎就要被埋进坑里

#### 3.3 Infinispan

- 为了缓解复制式同步的写入效率问题，JBossCache 的继任者 Infinispan 提供了另一种分布式同步模式（ 这种同步模式的名字就叫做 “分布式” ）
- 允许用户配置数据需要复制的副本数量，譬如集群中有八个节点，可以要求每个数据只保存四份副本，此时，缓存的总容量相当于是传统复制模式的一倍，如果要访问的数据在本地缓存中没有存储，Infinispan 完全有能力感知网络的拓扑结构，知道应该到哪些节点中寻找数据

#### 4. 集中式缓存

- 集中式缓存是目前分布式缓存的主流形式，集中式缓存的读、写都需要网络访问，其好处是不会随着集群节点数量的增加而产生额外的负担，其坏处自然是读、写都不再可能达到进程内缓存那样的高性能

#### 4.1 独立进程

- 集中式缓存还有一个必须提到的关键特点，它与使用缓存的应用分处在独立的进程空间中
- 其好处是它能够为异构语言提供服务，譬如用 C 语言编写的 Memcached 完全可以毫无障碍地为 Java 语言编写的应用提供缓存服务
- 但其坏处是如果要缓存对象等复杂类型的话，基本上就只能靠序列化来支撑具体语言的类型系统（ 支持 Hash 类型的缓存，可以部分模拟对象类型 ），不仅有序列化的成本，还很容易导致传输成本也显著增加
- 举个例子，假设某个有 100 个字段的大对象变更了其中 1 个字段的值，通常缓存也不得不把整个对象所有内容重新序列化传输出去才能实现更新，因此，一般集中式缓存更提倡直接缓存原始数据类型而不是对象
- 相比之下，JBossCache 通过它的字节码自审（ Introspection ）功能和树状存储结构（ TreeCache ），做到了自动跟踪、处理对象的部分变动，用户修改了对象中哪些字段的数据，缓存就只会同步对象中真正变更那部分数据

#### 4.2 Redis

- 如今 Redis 广为流行，基本上已经打败了 Memcached 及其他集中式缓存框架，成为集中式缓存的首选，甚至可以说成为了分布式缓存的实质上的首选，几乎到了不必管读取、写入哪种操作更频繁，都可以无脑上 Redis 的程度。也因如此，之前说到哪些数据适合用复制式缓存、哪些数据适合集中式缓存时，都在开头加了个拗口的 “理论上”
- 尽管 Redis 最初设计的本意是 NoSQL 数据库而不是专门用来做缓存的，可今天它确实已经成为许多分布式系统中无可或缺的基础设施，广泛用作缓存的实现方案
- 从数据一致性角度说，缓存本身也有集群部署的需求，理论上应该认真考虑一下是否能接受不同节点取到的缓存数据有可能存在差异，譬如
  - 刚刚放入缓存中的数据，另外一个节点马上访问发现未能读到
  - 刚刚更新缓存中的数据，另外一个节点访问在短时间内读取到的仍是旧的数据
  - 等等
- 根据分布式缓存集群是否能保证数据一致性，可以将它分为 AP 和 CP 两种类型。上面又一次出现了 “理论上”，是因为我们实际开发中通常不太会把追求强一致性的数据使用缓存来处理，可以这样做，但是没必要（ 可类比 MESI 等缓存一致性协议 ）。譬如，Redis 集群就是典型的 AP 式，有着高性能高可用等特点，却并不保证强一致性
- 而能够保证强一致性的 ZooKeeper、Doozerd、Etcd 等分布式协调框架，通常不会有人将它们当为 “缓存框架” 来使用，这些分布式协调框架的吞吐量相对 Redis 来说是非常有限的不过 ZooKeeper、Doozerd、Etcd 倒是常与 Redis 和其他分布式缓存搭配工作，用来实现其中的通知、协调、队列、分布式锁等功能

## 5. 配合使用

- 分布式缓存与进程内缓存各有所长，也有各有局限，它们是互补而非竞争的关系，如有需要，完全可以同时把进程内缓存和分布式缓存互相搭配，构成透明多级缓存，如下图所示
  ![image](https://github.com/user-attachments/assets/181bfb76-1676-4e50-85e1-679326a447a0)
- 先不考虑 “透明” 的话，多级缓存是很好理解的，使用进程内缓存做一级缓存，分布式缓存做二级缓存，如果能在一级缓存中查询到结果就直接返回，否则便到二级缓存中去查询，再将二级缓存中的结果回填到一级缓存，以后再访问该数据就没有网络请求了。如果二级缓存也查询不到，就发起对最终数据源的查询，将结果回填到一、二级缓存中去
- 尽管多级缓存结合了进程内缓存和分布式缓存的优点，但它的代码侵入性较大，需要由开发者承担多次查询、多次回填的工作，也不便于管理，如超时、刷新等策略都要设置多遍，数据更新更是麻烦，很容易会出现各个节点的一级缓存、以及二级缓存里数据互相不一致的问题
- 因此必须 “透明” 地解决以上问题，多级缓存才具有实用的价值。一种常见的设计原则是变更以分布式缓存中的数据为准，访问以进程内缓存的数据优先
- 大致做法是当数据发生变动时，在集群内发送推送通知（ 简单点的话可采用 Redis 的 PUB/SUB，求严谨的话引入 ZooKeeper 或 Etcd 来处理 ），让各个节点的一级缓存自动失效掉相应数据
- 当访问缓存时，提供统一封装好的一、二级缓存联合查询接口，接口外部是只查询一次，接口内部自动实现优先查询一级缓存，未获取到数据再自动查询二级缓存的逻辑
