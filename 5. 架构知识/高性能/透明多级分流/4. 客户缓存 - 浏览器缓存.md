## 1. cookie

#### 1.1 cookie 的作用

- Web 应用程序是使用 HTTP 协议传输数据的，HTTP 请求都是无状态的，一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接，因此服务器不知道客户端是谁，访问过多少次。但是我们的 Web 应用通常都需要知道发起请求的人是谁。为了解决这个问题，HTTP 协议设计了一个特殊的请求头：Cookie
- 服务端可以通过响应头（ set-cookie ）将少量数据响应给客户端，浏览器会遵循协议将数据保存，并在下次请求同一个服务的时候带上（ 浏览器也会遵循协议，只在访问符合 Cookie 指定规则的网站时带上对应的 Cookie 来保证安全性 ）

#### 1.2 Cookie 属性

- Name：
  - Cookie 的名称，用于区分不同的 Cookie。名称必须是唯一的，并且不能包含空格、逗号或分号等特殊字符
- Value：
  - Cookie 的值，用于存储 Cookie 的实际数据。通常是一个字符串，可以是任意类型的数据，如用户 ID、用户名等
- Domain：
  - Cookie 的作用域，指定了哪些网站可以访问该 Cookie。默认情况下，只有设置 Cookie 的网站才能访问它。可以通过设置 Domain 属性，使其在其他子域名下也可访问。
- Path：
  - Cookie 的路径，默认情况下，路径属性值为创建 Cookie 的页面所在的目录及其子目录，通过设置路径属性，可以限制 Cookie 在服务器上的特定目录中有效，从而进一步限制 Cookie 的作用范围，比如 path: '/a'，即只能在 www.abc.com/a 目录下访问
- Expires / Max-Age：
  - Cookie 的过期时间，用于设置 Cookie 的有效期。Expires 属性使用具体的日期和时间（如 "Tue, 19 Jan 2038 03:14:07 GMT"）设置过期时间，而 Max-Age 属性使用相对于当前时间的秒数设置过期时间。如果不设置这两个属性，Cookie 将在浏览器关闭时失效（即会话 Cookie）
  - 如果同时设置了 Expires 和 Max-Age，则 Max-Age 优先级更高，浏览器将以 Max-Age 为准计算 Cookie 的过期时间
- Secure：
  - 安全标记，用于指定 Cookie 是否只能通过 HTTPS 连接传输。当设置了 Secure 属性，Cookie 将只在 HTTPS 连接中传输，以增加安全性
- HttpOnly：
  - HttpOnly 标记，用于指定 Cookie 是否只能通过 HTTP(S) 请求访问，而不能通过客户端脚本（如 JavaScript）访问。设置 HttpOnly 属性可以防止跨站脚本（XSS）攻击
- SameSite：
  - SameSite 属性用于防止跨站请求伪造（CSRF）攻击。它有三个值：Strict（仅在同一站点请求时发送 Cookie）、Lax（在同一站点和跨站点的顶级导航请求中发送 Cookie）和 None（总是发送 Cookie，即使是跨站点请求）。默认值通常为 Lax
- 例
  ```javascript
  cookieName=cookieValue; Domain=example.com; Path=/; Expires=Tue, 19 Jan 2038 03:14:07 GMT; Secure; HttpOnly; SameSite=Strict
  ```
  - Name：cookieName
  - Value：cookieValue
  - Domain：example.com
  - Path：/（根路径，表示整个网站都可以访问该 Cookie）
  - Expires：Tue, 19 Jan 2038 03:14:07 GMT（设置了具体的过期时间）
  - Secure：表示只能通过 HTTPS 连接传输
  - HttpOnly：表示只能通过 HTTP(S) 请求访问，不能通过客户端脚本（如 JavaScript）访问
  - SameSite：Strict（表示仅在同一站点请求时发送 Cookie）

#### 1.3 Cookie 操作

- 获取 Cookie

  - 通过 document.cookie 属性获取所有 Cookie，不过只能获取 Name 和 Value，返回一个字符串，由多个 Cookie 组成，是 Name=Value 形式，被 '; ' 分割

  ```javascript
  function getCookies() {
  	const cookieString = document.cookie
  	const cookiesArray = cookieString.split('; ')
  	const cookies = {}

  	cookiesArray.forEach((cookie) => {
  		const [name, value] = cookie.split('=')
  		cookies[name] = value
  	})

  	return cookies
  }

  const allCookies = getCookies()
  console.log(allCookies)
  ```

- 设置 Cookie

  - 每次使用 document.cookie 设置一个新的 Cookie 时，都需要将其作为单独的赋值语句处理，可以设置除了 HttpOnly 以外的所有属性

  ```javascript
  // 设置第一个 Cookie
  document.cookie =
  	'name=value; Expires=Wed, 21 Oct 2021 07:28:00 GMT; Domain=example.com; Path=/some-path; Secure; SameSite=Lax;'

  // 设置第二个 Cookie
  document.cookie = 'userToken=abc123; Max-Age=86400; Domain=mywebsite.com; Path=/dashboard; Secure; SameSite=Strict;'
  ```

- 修改 Cookie

  - 可以简单地设置一个具有相同的名称、域和路径的新 Cookie，并为其提供更新后的值和属性，浏览器会自动覆盖具有相同名称、域和路径的旧 Cookie

  ```javascript
  // 假设当前的 Cookie 是这样的：
  document.cookie = 'userToken=abc123; Max-Age=86400; Domain=mywebsite.com; Path=/dashboard; Secure; SameSite=Strict;'

  // 修改 userToken 的值和属性：
  document.cookie = 'userToken=xyz789; Max-Age=172800; Domain=mywebsite.com; Path=/dashboard; Secure; SameSite=Lax;'
  ```

- 删除 Cookie

  - 通过设置 Cookie 的过期时间为 过去 或 现在，这将使浏览器自动删除该 Cookie。需要确保新 Cookie 具有相同的名称、域和路径

  ```javascript
  // 假设当前的 Cookie 是这样的：
  document.cookie = 'userToken=abc123; Path=/dashboard; Secure; SameSite=Strict;'

  // 删除 userToken Cookie：
  document.cookie = 'userToken=; Path=/dashboard; Expires=Thu, 01 Jan 1970 00:00:00 GMT;'
  // 或者将 Max-Age 属性设置为 0 或负数
  ```

- 注意
  - 因为浏览器的 Cookie 机制主要为了在服务端处理会话状态而设计的，所以客户端不需知道 Cookie 的属性，只需要访问 Cookie 的名称和值，而其他属性主要用于控制 Cookie 的作用范围和生命周期，它们不需在前端 JavaScript 中直接访问
  - 前端只可以获取 Name 和 Value，获取不到其他属性；但前端可以设置除了 HttpOnly 以外的所有属性

#### 1.4 cookie 特性

- cookie 具有保质期
  - 即有永久的也有临时的，每当发送请求的时候，都会根据域名来携带（请求头中）相应的 cookie，可通过设置 expires 、max-age 来设定保存日期，不设置的话默认是临时存储，即关闭浏览器就消失
- cookie 安全性
  - cookie 在本地可以被更改，用户可以随时清理 cookie，每次发送请求时以明文携带在请求头中，因此安全性差，建议敏感数据不存储在 cookie 中
- Cookie 存储大小受限制
  - Cookie 有个数和大小的限制，不同的浏览器每个域名下，有不同的 cookie 条数限制，20-50 条不等，大多数的浏览器限制大小一般为 4kb，超出会删除旧的 Cookie
- Cookie 受同源策略限制
  - 只能访问当前域名下的 Cookie，禁止跨域访问 Cookie
- Cookie 自动传送给服务器端
  - Cookie 在浏览器下次向同一服务器发起请求时被携带（请求头中）发送到服务器端，服务器获取到发送 Cookie 数据

## 2. Web Storage

#### 2.1 cookie 和 localStorage 以及 sessionStorage 的区别

1. 存储大小
   - cookie：一般不超过 4k
   - sessionStorage：5M 甚至更多
   - localStorage：5M 甚至更多
2. 数据有效期
   - cookie：一般由服务器生成，可以设置失效时间；若没有设置时间，关闭浏览器 cookie 失效，如果设置了时间，cookie 就会存储在硬盘中，过期失效
   - sessionStorage：仅在当前浏览器窗口关闭之前有效，关闭页面或者浏览器会被清除
   - localStorage：永久有效，窗口或者浏览器关闭也会一直保存，除非手动永久删除
3. 作用域
   - cookie：在所有同源窗口中都是共享的
   - sessionStorage：在同一个浏览器窗口是共享的（不同浏览器，即使是统一页面也不共享）
   - localStorage：在所有同源窗口中共享
4. 通信
   - cookie：cookie 在浏览器和服务器之间来回传递，如果使用 cookie 保存过多数据会造成性能问题
   - sessionStorage：仅在客户端（浏览器）中保存，不参与服务器的通信
   - localStorage：仅在客户端（浏览器）中保存，不参与服务器的通信
5. 应用场景
   - cookie：判断用户是否登录过网站，以便实现下次自动登录或记住密码；保存事件信息
   - sessionStorage：敏感账号一次性登录，单页面用的较多
   - localStorage：用于长期登录，适于长期保存在本地的数据
6. 存储类型
   - 都只能存储字符串类型

#### 2.2 细节

- Storage 存储数据也是以键值对的形式进行保存的，且任何格式在存储时都会转为字符串格式
- 如果开了不同的标签打开页面，sessionStorage 是否共享？
  - 通过点击链接（或者用了 window.open）打开的新标签页之间是属于同一个 session 的，但新开一个标签页总是会初始化一个新的 session，即使网站是一样的，它们也不属于同一个 session
- localStorage 和 sessionStorage 区别
  - localStorage 的生命周期是永久的，即如果不主动清除，存储的数据将一直被保存，而 sessionStorage 的生命周期为当前窗口或标签页，一旦窗口或标签页关闭，那么存储的数据将被清空
  - 同一浏览器的相同域名和端口的不同标签页间可以共享相同的 localStorage，但是不同标签页间无法共享 sessionStorage 的信息
- 如何监听 localStorage
  当同源页面的某个页面修改了 localStorage，其余的同源页面只要注册了 storage 事件，就会触发。注意，在用一个页面修改了，该自身页面并不会触发该事件（同源页面即两个页面拥有相同的协议，端口和域名）
  ```
  window.addEventListener("storage", () => {}）
  ```
- 如何实现多标签页共享 sessionStorage
  可以通过修改 localStorage，然后监听，发现修改时，把 sessionStorage 修改了
  ```
  window.addEventListener("storage", function(event){
    if(event.key == "token"){
      sessionStorage.setItem('token', event.newValue)
    }
  })
  ```
- 把用户数据放到 localStorage 安全吗（真的被问过）
  - 与 cookie 相比
    - 以前我们使用 cookie 进行身份验证，通常会被 xss 漏洞来获取 cookie，然后用这个 cookie 进行身份验证登录，后来为了防止通过 XSS 获取 Cookie 数据，浏览器支持了使用 HTTPONLY 来保护 Cookie 不被 XSS 攻击获取到，但是目前 localStorage 存储没有对 XSS 攻击有任何抵御机制，一旦出现 XSS 漏洞，那么存储在 localStorage 里的数据就极易被获取到
  - 不要存储敏感信息
    - 因为它对存储方式（除了 Opera 浏览器采用 BASE64 加密外（BASE64 也是可以轻松解密的），其他浏览器均采用明文存储数据）和存储时效（永久存在，除非主动删除），建议不要使用 localStorage 方式存储敏感信息，那怕这些信息进行过加密
  - 严格过滤输入输出
    - 对于本地存储，为了方便加载数据，常常会把数据存储在本地，等再次加载时，直接从本地读取数据显示在网页上。在某些情况下，在 localStorage 存储中写入或读取数据的时候，如果数据没有经过输入输出严格过滤，那么这些数据极可能被作为 HTML 代码进行解析，从而产生 XSS 攻击（这种情况很难实现）
  - 容易遭受跨目录攻击
    - localStroage 存储方式不会像 Cookie 存储一样可以指定域中的路径，在 localStroage 存储方式中没有域路径的概念。也就是说，如果同一个域下的任意路径存在 XSS 漏洞，整个域下存储的数据在知道存储名称的情况下都可以被获取到
    - 例，用户 xisigr 和 xhack 各自的 blog 链接虽然属于同一个域，但却有不同的路径，一个路径为 xisigr，另一个路径为 xhack。假设 xisigr 用户发现自己的路径下存在存储型 XSS 漏洞，那么就可以在自己的 blog 中加入获取数据代码，其中核心代码为 localStorage.getItem(“name”)，xhack 用户并不需要登录 blog,他只要访问 http://h.example.com/xisigr，本地存储数据就会被获取到

#### 2.3 cookie 和 localStorage 使用场景差别

- Cookie 适用于以下场景：
  1. 跨域传递数据：Cookie 可以在不同域名之间传递数据，而 LocalStorage 只能在同一域名下共享数据
  2. 与服务器进行交互：Cookie 会在每次 HTTP 请求中自动发送到服务器，用于实现用户身份验证和会话管理等功能
  3. 设置过期时间：Cookie 可以设置过期时间，可以在指定时间后自动失效
- LocalStorage 适用于以下场景：
  1. 客户端数据存储：LocalStorage 可以用于在客户端存储用户的个人设置、偏好等数据，以提供更好的用户体验
  2. 持久化存储：LocalStorage 的数据可以长期保存在浏览器中，即使用户关闭浏览器或重新启动电脑，数据也不会丢失
  3. 大量数据存储：LocalStorage 可以存储较大量的数据，而 Cookie 的存储容量较小

## 3. IndexDB

#### 3.1 为什么会出现 IndexDB

- 常用的优化性能方式就是本地存储一些不变的数据，从而提升页面渲染的速度，减少从服务器获取数据
- 现有的浏览器数据储存方案，都不适合储存大量数据
  - Cookie 的大小不超过 4KB，且每次请求都会发送回服务器
  - web Storage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引，主键等，没有事务管理
  - 上面两个都只能存储字符串类型数据

#### 3.2 IndexDB 是什么

- 是一个运行在浏览器的 **非关系型数据库**（不支持 SQL 查询语句），作为一个数据库，它存储的数据量就是没有上限的，一般存储大小是 250m 以上（受计算机硬件和浏览器厂商的限制）
- IndexedDB 是一个事务型的数据库系统，会将数据集作为个体对象存储，数据形式使用的是 JSON，而不是列数固定的表格来存储数据的
- 在 IndexDB 中，可以创建多个数据库，数据库中可以创建多张表，每张表中可以存储多条数据，当需要存储的数据复杂度高且数据量大时建议使用 IndexDB

#### 3.3 IndexDB 的特点

- **键值对存储**：IndexDB 内部采用对象仓库存放数据。所有类型的数据都可以直接存入，包括 Javascript 对象。在仓库中，数据以键值对的形式进行保存，每一个数据记录都有对应的主键，且主键是独一无二的，不能有重复，可以把表中的某一个字段设为索引，并可进行限制
- **异步（但不是完全的异步）**： IndexDB 操作时是异步操作，不会锁死浏览器，用户在操作 IndexDB 数据库时，可同时进行其他操作（页面渲染等），相比于 localStorage 的同步操作相比，有利于在大量数据进行读写操作时，避免影响网页的性能
- **支持事务**：IndexDB 支持事务，支持在数据库操作失败后，整个事务取消，数据库会回滚到之前的状态，有利于保证数据的安全与完整性
- **同源限制**：IndexDB 收到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能跨域访问
- **支持二进制储存**：IndexDB 不仅可以存储字符串，还可以储存二进制树（ArrayBuffer 对象和 Blob 对象）
- **储存空间大**：IndexDB 由于是数据库，所以存储量比一般方式大很多，一般来说不少于 250MB

#### 3.4 IndexDB 的基本概念

- IDBDatabase 对象（数据库）
  - 数据库是一系列相关数据的容器。每个域名（严格的说，是协议+域名+端口）都可以新建任意多个数据库，但他的版本的概念，同一时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或主键），只能通过升级数据库版本完成
- IDBObjectStore 对象（对象仓库）
  - 每个数据库包含若干个对象仓库。它类似于关系型数据库的表格
- IDBIndex（索引）
  - 为了加速数据的检索可以在对象仓库里面，为不同的属性建立索引
- IDTransaction 对象（事务）
  - 数据记录的读写和删除，都要通过事务完成。对象提供 error、abort 和 complete 三个监听事件监听操作结果（因为是异步操作）
- IDBRequest 对象（操作请求）
- IDBCursor（对象指针）
- IDBKeyRange 对象（主键集合）

#### 3.5 操作示例

其实核心主要就是，IndexDB 操作都是异步操作，所以基本上，每次都需要在 onerror 和 onsuccess 中进行下一步操作

- 定义数据库初始变量
  ```
  var db = null;   // 数据库对象
  var db_table = null;   // 数据库中某个表的实例
  var databaseName = 'indexDB';   // 数据库名称
  var version = 1;   // 数据库版本
  var tableData = [{   // 待存入数据
      id:1,
      name:'张一',
      age:  1,
    address:'西安'
  }]
  ```
- 打开数据库

  ```
  // 考虑兼容性，获取浏览器支持的 IndexDB 数据库
  window.indexDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;

  // 打开数据库
  var request = window.indexedDB.open(databaseName, version);

  // 数据仓库打开失败触发的回调
  request.onerror = function(error) {
    console.log('IndexDB打开失败',error);
  }

  // 数据仓库打开成功触发的回调
  request.onsuccess = function(res) {
    // 打开成功后用变量 db 存储数据库对象
      db = res.target.result;
  }

  // 数据仓库升级事件（第一次新建库是也会触发，因为数据仓库从无到有算是升级了一次）
  request.onupgradeneeded = function (res){
      db = res.target.result;
      // 在数据库中创建表 group，设置主键为 id
      db_table = db.createObjectStore('tableA', { keyPath: 'id' });
      // 创建索引 indexName 指向表中的 name 字段且设为唯一值，不能重复
      db_table.createIndex('indexName', 'name', { unique: false });
  }
  ```

- 存储数据

  - 写入数据需要新建一个事务，新建时必须指定表格名称和操作模式

  ```
  // 新建事务
  // @params 数据仓库的数组
  // @params 写入模式，readwrite写入操作，为空时表示只读
  // @objectStore对应数据库中的表
  var store = db.transaction(['tableA'], 'readwrite').objectStore('tableA');

  // add 方法添加数据
  // @params 需要添加的数据信息
  // 将预处理中建好的数据加入数据库
  var transaction = store.add(tableData);

  // 添加成功
  transaction.onsuccess = function (event) {
      console.log('数据添加成功',event);
  };

  // 添加失败
  transaction.onerror = function (event) {
      console.log('数据添加失败',event);
  };
  ```

- 读取数据

  - 读取数据也是通过事务完成的

  ```
  // 新建事务
  // @params 数据仓库的数组
  var store = db.transaction(['tableA']).objectStore('tableA');

  // get方法获取数据
  // @params 数据的主键
  var transaction = store.get(1);

  // 获取成功
  transaction.onsuccess = function (event) {
      if(event.target.result){
          console.log('数据获取成功',event);
      }
      else{
          console.log('未获取到数据');
      }
  };

  // 获取失败
  transaction.onerror = function (event) {
      console.log('数据获取失败',event);
  };
  ```

- 更新表中的数据

  - 更新数据要使用 IDBObject.put() 方法

  ```
  // 新建事务
  // @params 数据仓库的数组
  // @params 写入模式
  var store = db.transaction(['tableA']).objectStore('tableA');

  var transaction = store.get(1);

  transaction.onsuccess = function(event){
    let oldData = event.target.result;
    oldData.age = 30;
    // put 方法本质是根据主键更新数据
    // @params 新数据
    const update = store.put(oldData);
    update.onerror=function(err){
      console.log(err);
    }
    update.onsuccess = function(event){
      console.log('完成更新');
    }
  }
  ```

- 删除数据
  ```
  // 按主键删除数据
  var transaction = db.transaction(["tableA"], "readwrite").objectStore("tableA").delete("1");
  transaction.onsuccess = function(event) {
    // It's gone!
  };
  transaction.onerror = function(event) {
    // It's gone!
  };
  ```
- 使用索引

  ```
  // 新建事务
  // @params 数据仓库的数组
  var store = db.transaction(['tableA']).objectStore('tableA');

  // index 方法获取索引对象
  // get 方法获取数据
  // @params 数据的索引
  var request = store.index('indexName').get('张四');

  // 获取成功
  request.onsuccess = function(event) {
       console.log('通过索引获取数据成功',event);
  };

  // 获取失败
  request.onerror = function(event) {
      console.log('通过索引获取数据失败',event);
  };
  ```

- 使用指针遍历表中的所有值

  ```
  var objectStore = db.transaction("tableA").objectStore("tableA");

  // 第一种遍历方案
  objectStore.openCursor().onsuccess = function(event) {
      var cursor = event.target.result;
      if (cursor) {
        console.log("Name for SSN " + cursor.key + " is " + cursor.value.name);
        cursor.continue();
      }
      else {
        console.log("No more entries!");
      }
  };

  // 第二种遍历方式
  objectStore.getAll().onsuccess = function(event) {
    console.log("Got all objects" + event.target.result);
  };
  ```

  <img src="https://img-blog.csdnimg.cn/5f47b6fa3cfb4f5583d1d17a5192b693.png"> <br/>
  指定遍历的范围和方向

  ```
  // openCursor参数
  // params1 用来控制指针显示的范围，为null时不做任何限制
  // @params2 表示指针遍历的的方向
  //    "next": 光标显示所有记录，包括重复记录。它从键范围的下限开始向上移动（按键的顺序单调递增）
  //    "nextunique": 光标显示所有记录，不包括重复记录。如果存在多个具有相同键的记录，则仅检索第一个迭代的记录。它从键范围的下限开始向上移动
  //    "prev": 光标显示所有记录，包括重复记录。它从键范围的上限开始向下移动（按键的顺序单调递减）
  //    "prevunique": 光标显示所有记录，不包括重复记录。如果存在多个具有相同键的记录，则仅检索第一个迭代的记录。它从键范围的上限开始向下移动
  var index = objectStore.index("indexName");
  const range = IDBKeyRange.bound(1,10);//遍历id从1到10的数据
  index.openCursor(boundKeyRange).onsuccess = function(event) {
    var cursor = event.target.result;
    if (cursor) {
      cursor.continue();
    }
  };
  ```

#### 3.6 细节

- 虽然 IndexDB 是异步 api，但是当通过 postMessage() 与 Workers 之间进⾏数据传输 或 使⽤ IndexedDB 存储对象时，会在内部使⽤ **结构化克隆算法**（是 HTML5 规范定义的⽤于复制复杂 JavaScript 对象的算法，它通过递归输入对象来构建克隆，同时保持先前访问过的引用的映射，以避免无限遍历循环）
  - 如果对象过大，结构化克隆算法执行时会阻塞页面的渲染，让用户产生卡顿的感觉
  - 有三个方法来避免 UI 阻塞问题：
    - 避免巨型对象的直接写入
      - 可以把巨型对象分解成多个小对象，缩短单次写入的时长
    - 存储巨型对象前，先将对象转换为字节，这样避免了结构化克隆算法的执行
      - 类似前文 把函数转换为字符串， 可以利用 ArrayBuffer 将对象转换为二进制字节，后面读取的时候，再次转换回对象
    - 使用 webworker 技术，避免阻塞主线程

#### 3.7 使用场景

- 比如可以考虑把聊天记录，保存在 IndexDB 中
