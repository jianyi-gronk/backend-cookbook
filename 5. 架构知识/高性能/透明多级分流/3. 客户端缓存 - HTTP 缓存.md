## 1. HTTP 缓存

#### 1.1 无状态

- 无状态是指协议对事务处理没有上下文的记忆能力，每一个请求都是完全独立的，无状态这个特性非常重要
- 浏览器的缓存机制几乎是在万维网刚刚诞生时就已经存在，在 HTTP 协议设计之初，便确定了服务端与客户端之间 “无状态”（ Stateless ）的交互原则，即要求每次请求是独立的，每次请求无法感知也不能依赖另一个请求的存在，这既简化了 HTTP 服务器的设计，也为其水平扩展能力留下了广袤的空间
- 假如你做了一个简单的网页，其中包含了 1 个 HTML、2 个 Script 脚本、3 个 CSS、还有 10 张图片，这个网页成功展示在用户屏幕前，需要完成 16 次与服务端的交互来获取上述资源，由于网络传输各种等因素的影响，服务器发送的顺序与客户端请求的先后并没有必然的联系，按照可能出现的响应顺序，理论上最多会有 P(16,16) = 20,922,789,888,000 种可能性
- 如果 HTTP 协议不是设计成无状态的，这 16 次请求每一个都有依赖关联，先调用哪一个、先返回哪一个，都会对结果产生影响的话，那协调工作会有多么复杂

#### 1.2 缓存机制

- 但无状态并不只有好的一面，由于每次请求都是独立的，服务端不保存此前请求的状态和资源，所以也不可避免地导致其携带有重复的数据，造成网络性能降低
- **HTTP 协议的无状态性决定了它必须依靠客户端缓存来解决网络传输效率上的缺陷**
- HTTP 协议对此问题的解决方案便是客户端缓存，在 HTTP 从 1.0 到 1.1，再到 2.0 版本的每次演进中，逐步形成了现在被称为 “状态缓存”、“强缓存” 和 “协商缓存” 的 HTTP 缓存机制

## 2. 状态缓存

- 状态缓存所涉内容非常非常少
- HTTP 缓存中，状态缓存是指不经过服务器，客户端直接根据缓存信息对目标网站的状态判断，以前只有 301/Moved Permanently（ 永久重定向 ）这一种；后来在 RFC6797 中增加了 HSTS（ HTTP Strict Transport Security ）机制，用于避免依赖 301/302 跳转 HTTPS 时可能产生的降级中间人劫持，这也属于另一种状态缓存

## 3. 强缓存

- **强缓存不会向服务器发送请求，直接从缓存中读取资源**
- 在 chrome 控制台的 network 选项中可以看到该请求返回 200 的状态码，并且 size 显示 from disk cache 或 from memory cache 两种（ 缓存从内存或磁盘读取 ）
- **强缓存中，三个字段的优先级为 pragma > cache-control > expires**

#### 3.1 Expires

- Expires 是 HTTP/1.0 协议中开始提供的 Header，后面跟随一个截至时间参数，代表服务器返回文件有效期，如果当前系统时间大于了这个时间，就缓存失效
- 当服务器返回某个资源时带有该 Header 的话，意味着服务器承诺截止时间之前资源不会发生变动，浏览器可直接缓存该数据，不再重新发请求
- 示例：
  ```
  HTTP/1.1 200 OK
  Expires: Wed, 8 Apr 2020 07:28:00 GMT
  ```

#### 3.2 Expires 缺陷

- 受限于客户端的本地时间
  - 譬如，在收到响应后，客户端修改了本地时间，将时间前后调整几分钟，就可能会造成缓存提前失效或超期持有
- 无法处理涉及到用户身份的私有资源
  - 譬如，某些资源被登录用户缓存在自己的浏览器上是合理的，但如果被代理服务器或者内容分发网络缓存起来，则可能被其他未认证的用户所获取
- 无法描述 “不缓存” 的语义
  - 譬如，浏览器为了提高性能，往往会自动在当次会话中缓存某些 MIME 类型的资源，在 HTTP/1.0 的服务器中就缺乏手段强制浏览器不允许缓存某个资源
  - 以前为了实现这类功能，通常不得不使用脚本，或者手动在资源后面增加时间戳（ 譬如如 “xx.js?t=1586359920”、“xx.jpg?t=1586359350” ）来保证每次资源都会重新获取

#### 3.3 Pragma

- 关于 “不缓存” 的语义，在 HTTP/1.0 中其实预留了 “Pragma: no-cache” 来表达，是一个在 HTTP/1.0 中规定的通用首部
- 但 Pragma 参数在 HTTP/1.0 中并没有确切描述其具体行为，随后就被 HTTP/1.1 中出现过的 Cache-Control 所替代（ 设置为 no-cache 与 Cache-Control: no-cache 效果一致 ）
- 现在，尽管主流浏览器通常都会支持 Pragma，但行为仍然是不确定的，实际并没有什么使用价值

#### 3.4 Cache-Control

- Cache-Control 是 HTTP/1.1 协议中定义的强制缓存 Header，它的语义比起 Expires 来说就丰富了很多，如果 Cache-Control 和 Expires 同时存在，并且语义存在冲突（ 譬如 Expires 与 max-age / s-maxage 冲突 ）的话，规定必须以 Cache-Control 为准
- Cache-Control 的使用示例如下：
  ```
  HTTP/1.1 200 OK
  Cache-Control: max-age=600
  ```

#### 3.5 Cache-Control 标准参数

- Cache-Control 在客户端的请求 Header 或服务器的响应 Header 中都可以存在，它定义了一系列的参数，且允许自行扩展（ 即不在标准 RFC 协议中，由浏览器自行支持的参数 ），其标准的参数主要包括如下
- max-age 和 s-maxage：
  - max-age 后面跟随一个以秒为单位的数字，表明相对于请求时间（ 在 Date Header 中会注明请求时间 ）多少秒以内缓存是有效的，资源不需要重新从服务器中获取。相对时间避免了 Expires 中采用的绝对时间可能受客户端时钟影响的问题
  - s-maxage 中的 “s” 是 “Share” 的缩写，意味 “共享缓存” 的有效时间，即允许被 CDN、代理等持有的缓存有效时间，用于提示 CDN 这类服务器应在何时让缓存失效
- public 和 private：
  - 指明是否涉及到用户身份的私有资源，如果是 public，则客户端和代理服务器都可缓存，如果是 private，则只能由用户的客户端进行私有缓存
- no-cache 和 no-store：
  - no-cache 指明该资源不应该被缓存，哪怕是同一个会话中对同一个 URL 地址的请求，也必须从服务端获取，令强制缓存完全失效，但此时协商缓存机制依然是生效的
  - no-store 不强制会话中相同 URL 资源的重复获取，但禁止浏览器、CDN 等以任何形式保存该资源
- no-transform：
  - 禁止资源被任何形式地修改。譬如，某些 CDN、透明代理支持自动 GZip 压缩图片或文本，以提升网络性能，而 no-transform 就禁止了这样的行为，它要求 Content-Encoding、Content-Range、Content-Type 均不允许进行任何形式的修改
- min-fresh 和 only-if-cached：
  - 这两个参数是仅用于客户端的请求 Header
  - min-fresh 后续跟随一个以秒为单位的数字，用于建议服务器能返回一个不少于该时间的缓存资源（ 即包含 max-age 且不少于 min-fresh 的数字 ）
  - only-if-cached 表示客户端要求不必给它发送资源的具体内容，此时客户端就仅能使用事先缓存的资源来进行响应，若缓存不能命中，就直接返回 503/Service Unavailable 错误。
- must-revalidate 和 proxy-revalidate：
  - must-revalidate 表示在资源过期后，一定需要从服务器中进行获取，即超过了 max-age 的时间后，就等同于 no-cache 的行为
  - proxy-revalidate 用于提示代理、CDN 等设备资源过期后的缓存行为，除对象不同外，语义与 must-revalidate 完全一致
- 多参数搭配
  ![image](https://github.com/user-attachments/assets/0d556bd4-8489-4a22-ae3b-1f39dd0517a9)

## 4. 协商缓存

- **强制缓存优先于协商缓存进行，若强制缓存生效则直接使用缓存，若不生效则进行协商缓存**
- 强制缓存是基于时效性的，但其实多数情况下都并没有什么把握去承诺某项资源多久不会发生变化
- 协商缓存是基于变化检测的缓存机制，在一致性上会有比强制缓存更好的表现，但需要一次变化检测的交互开销，性能上就会略差一些
- **协商缓存中，三个字段的优先级为 ETag > Last-Modified**

#### 4.1 状态码

- 协商缓存向服务器发送请求，服务器会根据这个请求的 request header 的一些参数来判断是否命中协商缓存，如果命中，则返回 304 状态码并带上新的 response header 通知浏览器从缓存中读取资源
  - 协商缓存生效：返回 304 状态码和 Not Modified，浏览器继续使用本地缓存资源
  - 协商缓存失效：返回 200 状态码和新的请求结果

#### 4.2 Last-Modified / If-Modified-Since

- 代表的是文件的最后修改时间，是 HTTP/1.0 协议中开始提供的 Header
- 步骤
  - 第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中
  - 第二次发起请求的时候，请求头会携带上一次响应头中的 Last-Modified 的时间，并放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较
- 如果此时服务端发现资源在该时间后没有被修改过，就只要返回一个 304/Not Modified 的响应即可，无须附带消息体，达到节省流量的目的，如下所示：
  ```
  HTTP/1.1 304 Not Modified
  Cache-Control: public, max-age=600
  Last-Modified: Wed, 8 Apr 2020 15:31:30 GMT
  ```
- 如果此时服务端发现资源在该时间之后有变动，就会返回 200/OK 的完整响应，在消息体中包含最新的资源，如下所示：

  ```
  HTTP/1.1 200 OK
  Cache-Control: public, max-age=600
  Last-Modified: Wed, 8 Apr 2020 15:31:30 GMT

  Content
  ```

#### 4.3 Last-Modified 缺陷

- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
- 因为 Last-Modified 只能以秒计时，如果在一秒内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

#### 4.4 ETag / If-None-Match

- ETag 是服务器的响应 Header，是代表资源的 hash 码，用于告诉客户端这个资源的唯一标识，是 HTTP/1.1 协议中开始提供的 Header
- HTTP 服务器可以根据自己的意愿来选择如何生成这个标识，譬如 Apache 服务器的 ETag 值默认是对文件的索引节点（ INode ），大小和最后修改时间进行哈希计算后得到的
- 对于带有这个 Header 的资源，当客户端需要再次请求时，会通过 If-None-Match 把之前收到的资源唯一标识发送回服务端，通过请求头里面的 If-None-Match 与当前文件的 hash 码进行比较，如果相等则命中协商缓存，然后根据文件差异决定是否返回
- 如果此时服务端计算后发现资源的唯一标识与上传回来的一致，说明资源没有被修改过，就只要返回一个 304/Not Modified 的响应即可，无须附带消息体，达到节省流量的目的，如下所示：
  ```
  HTTP/1.1 304 Not Modified
  Cache-Control: public, max-age=600
  ETag: "28c3f612-ceb0-4ddc-ae35-791ca840c5fa"
  ```
- 如果此时服务端发现资源的唯一标识有变动，就会返回 200/OK 的完整响应，在消息体中包含最新的资源，如下所示：

  ```
  HTTP/1.1 200 OK
  Cache-Control: public, max-age=600
  ETag: "28c3f612-ceb0-4ddc-ae35-791ca840c5fa"

  Content
  ```

#### 4.4 ETag 强弱校验

- ETag 有强弱校验之分，弱校验 的 ETag 值开头是 “W/”，即指 weak
- 强校验
  - 强校验要求每个字节都相同才认为是同一个资源；而弱校验则把决定权交给开发者，根据需要区分的要素来生成相应的 ETag
  - 强校验 ETag 匹配表明两个资源表示的内容是逐字节相同的，并且所有其它实体字段（ 例如 Content-Language ）也未更改。强 ETag 允许缓存和重组部分响应，就像字节范围请求一样
- 弱检验
  - 弱校验 ETag 匹配仅表明这两种表示在语义上是等效的，这意味着出于实际目的它们是可互换的并且可以使用缓存的副本。但是，资源表示不一定逐字节相同，因此弱 ETag 不适用于字节范围请求
  - 大多数情况下，确保严格的字节级别的一致性是没有必要的。例如，如果我们开启了 HTTP 压缩，那么对于一个资源的响应，压缩前和压缩后的字节就是不一致的，但通常我们只关心压缩前的 ETag ，这时就需要使用弱校验的 ETag

#### 4.5 ETag 和 Last-Modified 的优劣点

- **Etag 是 HTTP 中一致性最强的缓存机制**，譬如，Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间；又或者如果某些文件会被定期生成，可能内容并没有任何变化，但 Last-Modified 却改变了，导致文件无法有效使用缓存，这些情况 Last-Modified 都有可能产生资源一致性问题，只能使用 Etag 解决
- **Etag 却又是 HTTP 中性能最差的缓存机制**，体现在每次请求时，服务端都必须对资源进行哈希计算，这比起简单获取一下修改时间，开销要大了很多
- Etag 和 Last-Modified 是允许一起使用的，服务器会优先验证 Etag，在 Etag 一致的情况下，再去对比 Last-Modified，这是为了防止有一些 HTTP 服务器未将文件修改日期纳入哈希范围内

#### 4.6 多资源场景

- 上面 HTTP 的协商缓存机制已经能很好地处理通过 URL 获取单个资源的场景，那 “多场景” 对应的是什么呢
  - 在 HTTP 协议的设计中，一个 URL 地址是有可能能够提供多份不同版本的资源
  - 譬如，一段文字的不同语言版本，一个文件的不同编码格式版本，一份数据的不同压缩方式版本，等等
- 因此针对请求的缓存机制，也必须能够提供对应的支持
  - 为此，HTTP 协议设计了以 Accept\*（ Accept、Accept-Language、Accept-Charset、Accept-Encoding ）开头的一套请求 Header
  - 和对应的以 Content-\*（ Content-Language、Content-Type、Content-Encoding ）开头的响应 Header
  - 这些 Headers 被称为 HTTP 的内容协商机制
- 与之对应的，对于一个 URL 能够获取多个资源的场景中，缓存也同样也需要有明确的标识来获知根据什么内容来对同一个 URL 返回给用户正确的资源
- 这个就是 Vary Header 的作用，Vary 后面应该跟随一组其他 Header 的名字，譬如：
  ```
  HTTP/1.1 200 OK
  Vary: Accept, User-Agent
  ```
  - 以上响应的含义是应该根据 MIME 类型和浏览器类型来缓存资源，获取资源时也需要根据请求 Header 中对应的字段来筛选出适合的资源版本

## 5. 其他细节

#### 5.1 缓存位置

- **强缓存和协商缓存都是放在磁盘中**

#### 5.2 刷新缓存失效

- 刷新页面可以分为三种：
  - 正常操作：地址栏输入 url，跳转链接，前进后退等；两种缓存都有效
  - 手动刷新：F5，点击刷新按钮，右击菜单刷新；仅协商缓存有效
  - 强制刷新：ctrl +f5 或 cmd + r；两种缓存策略都无效，重新请求资源。发送的请求头部均带有 Cache-control: no-cache（ 为了兼容，还带了 Pragma: no-cache ），服务器直接返回 200 和最新内容

#### 5.3 未设置缓存场景

- 对于这种情况，浏览器通常会采用一个启发式的算法，一般会取响应头中的 Date（ 服务器发送响应的时间 ）减去 Last-Modified（ 资源最后修改的时间 ）值的 10% 作为缓存时间
