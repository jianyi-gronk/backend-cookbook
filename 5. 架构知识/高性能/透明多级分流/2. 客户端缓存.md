## 1. 缓存类型

- 从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络
  - Service Worker > Memory Cache > Disk Cache > Push Cache

## 2. Service Worker

- Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能
- 使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全
- Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的
- Service Worker 实现缓存功能一般分为三个步骤：
  - 首先需要先注册 Service Worker
  - 然后监听到 install 事件以后就可以缓存需要的文件
  - 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据
- 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容

## 3. Memory Cache

- 表示不访问服务器，直接从内存中读取缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等
- 因为缓存的资源保存在内存中，所以读取速度较快，可是缓存持续性很短，会随着进程的释放而释放。一旦关闭 Tab 页面，内存中的缓存也就被释放了
- 一般来说，系统不会给内存分配较大的容量，因此内存缓存一般用于存储较小文件。同时内存缓存在有时效性要求的场景下也很有用（ 比如浏览器的隐私模式 ）
- 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存
  ![image](https://github.com/user-attachments/assets/de2ef2e8-602f-48ae-a086-16e486cab26f)
- 内存缓存中有一块重要的缓存资源是 preloader 相关指令（例如 \<link rel="prefetch"\> ）下载的资源。总所周知 preloader 的相关指令已经是页面优化的常见手段之一，它可以一边解析 js/css 文件，一边网络请求下一个资源
- 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control 是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验

## 4. Disk Cache

- 表示不访问服务器，直接从硬盘中读取缓存。与内存相比，硬盘的读取速度相对较慢，但硬盘缓存持续的时间更长，关闭进程之后，缓存的资源仍然存在。由于硬盘的容量较大，因此一般用于存储大文件
- **在浏览器中，浏览器会在 js 和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取；而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存**
- 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。**它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求，HTTP 缓存都是放在磁盘缓存**
- 并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache
- 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？
  - 对于大文件来说，大概率是不存储在内存中的，反之优先
  - 当前系统内存使用率高的话，文件优先存储进硬盘

## 5. Push Cache

- HTTP/2.0 中设计了新的缓存方式，服务器推送（ Push Server ），当以上三种缓存都没有命中时，它才会被使用
- 有别于强制缓存和协商缓存，它属于推送缓存
  - 这种新的缓存方式主要是为了解决客户端缓存时效性的问题，即还没有收到客户端的请求，服务器就把各种资源推送给客户端
  - 比如，客户端只请求了 a.html，但是服务器把 a.html、a.css、a.png 全部发送给客户端。这样的话，只需要一次请求，客户端就更新了所有文件的缓存，提高了缓存的时效性
- 它只在会话（ Session ）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令
- Push Cache 在国内能够查到的资料很少，这里推荐阅读 Jake Archibald 的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论：
  - 所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差
  - 可以推送 no-cache 和 no-store 的资源
  - 一旦连接被关闭，Push Cache 就被释放
  - 多个页面可以使用同一个 HTTP/2 的连接，也就可以使用同一个 Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的 tab 标签使用同一个 HTTP 连接
  - Push Cache 中的缓存只能被使用一次
  - 浏览器可以拒绝接受已经存在的资源推送
  - 可以给其他域名推送资源
