## 1. 重要性

- 容错性设计是分布式不能妥协的特性，因为分布式系统的本质是不可靠的，一个大的服务集群中，程序可能崩溃、节点可能宕机、网络可能中断，这些 “意外情况” 其实全部都在 “意料之中”
- 原本信息系统设计成分布式架构的主要动力之一就是为了提升系统的可用性，最低限度也必须保证将原有系统重构为分布式架构之后，可用性不出现倒退下降才行
- 如果服务集群中出现任何一点差错都能让系统面临 “千里之堤溃于蚁穴” 的风险，那分布式恐怕就根本没有机会成为一种可用的系统架构形式

## 2. 容错策略

- 要落实容错性设计这条原则，除了思想观念上转变过来，正视程序必然是会出错的，对它进行有计划的防御之外，还必须了解一些常用的容错策略和容错设计模式，作为具体设计与编码实践的指导
- **这里容错策略指的是 “面对故障，我们该做些什么”**
- 常见的容错策略可以分为两类：
  - 调用失败之后进行弥补：故障转移，快速失败，安全失败，沉默失败，故障恢复
  - 调用之前就考虑失败情况：并行调用，广播调用

## 3. 故障转移（ Failover ）

- 高可用的服务集群中，多数服务，尤其是那些经常被其他服务所依赖的关键路径上的服务，均会部署有多个副本。这些副本可能部署在不同的节点（ 避免节点宕机 ）、不同的网络交换机（ 避免网络分区 ）甚至是不同的可用区（ 避免整个地区发生灾害或电力、骨干网故障 ）中
- **故障转移是指如果调用的服务器出现故障，系统不会立即向调用者返回失败结果，而是自动切换到其他服务副本，尝试其他副本能否返回成功调用的结果**，从而保证了整体的高可用性
- **故障转移的容错策略应该有一定的调用次数限制**，譬如允许最多重试三个服务，如果都发生报错，那还是会返回调用失败。原因不仅是因为重试是有执行成本的，更是因为过度的重试反而可能让系统处于更加不利的状况。譬如有以下调用链：
  - Service A → Service B → Service C
  - 假设 A 的超时阈值为 100 毫秒，而 B 调用 C 花费 60 毫秒，然后不幸失败了，这时候做故障转移其实已经没有太大意义了
  - 因为即时下一次调用能够返回正确结果，也很可能同样需要耗费 60 毫秒时间，时间总和就已经触及 A 服务的超时阈值，所以在这种情况下故障转移反而对系统是不利的

## 4. 快速失败（ Failfast ）

- 还有另外一些业务场景是不允许做故障转移的，故障转移策略能够实施的前提是要求服务具备幂等性，**对于非幂等的服务，重复调用就可能产生脏数据，引起的麻烦远大于单纯的某次服务调用失败，此时就应该以快速失败作为首选的容错策略**
- 譬如，在支付场景中，需要调用银行的扣款接口，如果该接口返回的结果是网络异常，程序是很难判断到底是扣款指令发送给银行时出现的网络异常，还是银行扣款后返回结果给服务时出现的网络异常的
- 为了避免重复扣款，此时最恰当可行的方案就是尽快让服务报错，坚决避免重试，尽快抛出异常，由调用者自行处理

## 5. 安全失败（ Failsafe ）

- 在一个调用链路中的服务通常也有主路和旁路之分，并不见得其中每个服务都是不可或缺的，有部分服务失败了也不影响核心业务的正确性
- 譬如开发基于 Spring 管理的应用程序时，通过扩展点、事件或者 AOP 注入的逻辑往往就属于旁路逻辑，**典型的有审计、日志、调试信息，等等**（ 这些信息并不要求必须正确，也不影响其他业务逻辑代码 ）
- **属于旁路逻辑的另一个显著特征是后续处理不会依赖其返回值，或者它的返回值是什么都不会影响后续处理的结果**，譬如只是将返回值记录到数据库，并不使用它参与最终结果的运算
- 对这类逻辑，一种理想的容错策略是即使旁路逻辑调用实际失败了，也当作正确来返回，如果需要返回值的话，系统就自动返回一个符合要求的数据类型的对应零值，然后自动记录一条服务调用出错的日志备查即可，这种策略被称为安全失败

## 6. 沉默失败（ Failsilent ）

- 如果大量的请求需要等到超时（ 或者长时间处理后 ）才宣告失败，很容易由于某个远程服务的请求堆积而消耗大量的线程、内存、网络等资源，进而影响到整个系统的稳定
- **面对这种情况，一种合理的失败策略是当请求失败后，就默认服务提供者一定时间内无法再对外提供服务，不再向它分配请求流量**，将错误隔离开来，避免对系统其他部分产生影响，此即为沉默失败策略
- 和上面几个失败的区别是：**上面几个失败策略是在服务调用者中实现的，沉默失败是在服务提供者中实现的**

## 7. 故障恢复（ Failback ）

- 故障恢复一般不单独存在，而是作为其他容错策略的补充措施，一般在微服务管理框架中，**如果设置容错策略为故障恢复的话，通常默认会采用快速失败加上故障恢复的策略组合**
- 它是指当服务调用出错了以后，**将该次调用失败的信息存入一个消息队列中**，然后由系统自动开始异步重试调用
- 故障恢复策略一方面是尽力促使失败的调用最终能够被正常执行，另一方面也可以为服务注册中心和负载均衡器及时提供服务恢复的通知信息
- **故障恢复显然也是要求服务必须具备幂等性的**，由于它的重试是后台异步进行，即使最后调用成功了，原来的请求也早已经响应完毕，所以故障恢复策略一般用于对实时性要求不高的主路逻辑，同时也适合处理那些不需要返回值的旁路逻辑
- 为了避免在内存中异步调用任务堆积，故障恢复与故障转移一样，应该有最大重试次数的限制

## 8. 并行调用（ Forking ）

- 上面五种以 “Fail” 开头的策略是针对调用失败时如何进行弥补的，以下这两种策略则是在调用之前就开始考虑如何获得最大的成功概率
- 并行调用策略很符合人们日常对一些重要环节进行的 “双重保险” 或者 “多重保险” 的处理思路，它是指 **一开始就同时向多个服务副本发起调用**，只要有其中任何一个返回成功，那调用便宣告成功，这是一种 **在关键场景中使用更高的执行成本换取执行时间和成功概率** 的策略

## 8. 广播调用（ Broadcast ）

- 广播调用与并行调用是相对应的，都是同时发起多个调用，但并行调用是任何一个调用结果返回成功便宣告成功，广播调用则是 **要求所有的请求全部都成功**，这次调用才算是成功，任何一个服务提供者出现异常都算调用失败
- 广播调用通常会被用于实现 “刷新分布式缓存” 这类的操作

## 9. 容错策略对比

- 以上容错策略优缺点及应用场景对比
  ![image](https://github.com/user-attachments/assets/daa004cb-82d1-41c2-9dcf-5772464badd9)
