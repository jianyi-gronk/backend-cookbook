## 1. 重要性

- **认证、授权 和 凭证 可以说是一个系统中最基础的安全设计**，哪怕再简陋的信息系统，大概也不可能忽略掉 “用户登录” 功能
- 信息系统为用户提供服务之前，总是希望先弄清楚 “你是谁？”（ 认证 ）、“你能干什么？”（ 授权 ）以及 “你如何证明？”（ 凭证 ）这三个基本问题
- 然而，这三个基本问题又并不只是一个 “系统登录”，不仅仅是校验一下用户名、密码是否正确这么简单
  - 账户和权限信息作为一种必须最大限度保障安全和隐私，同时又要兼顾各个系统模块甚至系统间共享访问的基础主数据，它的存储、管理与使用都面临一系列复杂的问题
  - 对于某些大规模的信息系统，账户和权限的管理往往要由专门的基础设施来负责，譬如微软的活动目录（ AD ）或者轻量目录访问协议（ LDAP ），跨系统的共享使用甚至会用到区块链技术

## 2. 认证规范分类

- 尽管 “认证” 是解决 “你是谁？” 的问题，但这里的 “你” 并不一定是指人，也可能是指外部的代码，即第三方的类库或者服务，所以 **认证分为代码认证和用户认证**
- 本文主要讲的是用户认证

#### 2.1 代码认证

- 最初，对代码认证的重要程度甚至高于对最终用户的认证，譬如在早期的 Java 系统里，安全认证默认是特指 “代码级安全”，即是否信任要在你的电脑中运行的代码
- 这是由 Java 当时的主要应用形式 Java Applets 所决定的，类加载器从远端下载一段字节码，以 Applets 的形式在用户的浏览器中运行，由于 Java 操控计算机资源的能力要远远强于 JavaScript，因此必须先确保这些代码不会损害用户的计算机，否则就谁都不敢去用
- 这一阶段的安全观念催生了现在仍然存在于 Java 技术体系中的 “安全管理器”（ java.lang.SecurityManager ）、“代码权限许可”（ java.lang.RuntimePermission ）等概念
- 如今，对外部类库和服务的认证需求依然普遍，但相比起五花八门的最终用户认证来说，代码认证的研究发展方向已经很固定，基本上都统一到证书签名上

#### 2.2 用户认证

- 根据架构安全性的经验原则：**以标准规范为指导、以标准接口去实现**
- 安全涉及的问题很麻烦，但解决方案已相当成熟，对于 99%的系统来说，在安全上不去做轮子，不去想发明创造，严格遵循标准就是最恰当的安全设计
- 主流的三种认证方式
  - 通信信道上的认证：
    - 你和我建立通信连接之前，要先证明你是谁
    - 在网络传输（ Network ）场景中的典型是基于 SSL/TLS 传输安全层的认证
  - 通信协议上的认证：
    - 你请求获取我的资源之前，要先证明你是谁
    - 在互联网（ Internet ）场景中的典型是基于 HTTP 协议的认证
  - 通信内容上的认证：
    - 你使用我提供的服务之前，要先证明你是谁
    - 在万维网（ World Wide Web ）场景中的典型是基于 Web 内容的认证
- 本文主要讲的是 通信协议认证 和 通信内容认证
  - 通信协议认证：一般是当未授权用户访问保护区域的资源
  - 通信内容认证：一般是当未授权用户调用保护范围的服务

## 3. HTTP 认证

#### 3.1 认证方案

- 认证方案是指生成用户身份凭证的某种方法，这个概念最初源于 HTTP 协议的认证框架
- IETF 在 RFC 7235 中定义了 HTTP 协议的通用认证框架，要求所有支持 HTTP 协议的服务器，**在未授权的用户意图访问服务端保护区域的资源时，应返回 401 Unauthorized 的状态码**，同时应在响应报文头里附带以下两个分别代表网页认证和代理认证的 Header 之一，告知客户端应该采取何种方式产生能代表访问者身份的凭证信息：
  ```
  WWW-Authenticate: <认证方案> realm=<保护区域的描述信息>
  Proxy-Authenticate: <认证方案> realm=<保护区域的描述信息>
  ```
- 接收到该响应后，客户端必须遵循服务端指定的认证方案，在请求资源的报文头中加入身份凭证信息，由服务端核实通过后才会允许该请求正常返回，否则将返回 403 Forbidden 错误。请求头报文应包含以下 Header 项之一：
  ```
  Authorization: <认证方案> <凭证内容>
  Proxy-Authorization: <认证方案> <凭证内容>
  ```
- HTTP 认证框架提出认证方案是希望能把认证 “要产生身份凭证” 的目的与 “具体如何产生凭证” 的实现分离开来，无论客户端通过生物信息（ 指纹、人脸 ）、用户密码、数字证书抑或其他方式来生成凭证，都属于是如何生成凭证的具体实现，都可以包容在 HTTP 协议预设的框架之内
- HTTP 认证框架的工作流程如下图所示
  ![image](https://github.com/user-attachments/assets/00edb5c1-e4e5-4b13-afaa-948b857462a9)

#### 3.2 举例介绍

- 以最基础的认证方案 HTTP Basic 认证为例来介绍认证是如何工作的
- HTTP Basic 认证是一种主要以演示为目的的认证方案，也应用于一些不要求安全性的场合，譬如家里的路由器登录等。Basic 认证产生用户身份凭证的方法是让用户输入用户名和密码，经过 Base64 编码 “加密” 后作为身份凭证。譬如请求资源 GET /admin 后，浏览器会收到来自服务端的如下响应：
  ```
  HTTP/1.1 401 Unauthorized
  Date: Mon, 24 Feb 2020 16:50:53 GMT
  WWW-Authenticate: Basic realm="example from icyfenix.cn"
  ```
- 此时，浏览器必须询问最终用户，即弹出类似下图所示的 HTTP Basic 认证对话框，要求提供用户名和密码
  ![image](https://github.com/user-attachments/assets/0b844373-1e09-426c-90de-3e522d640cbf)
- 用户在对话框中输入密码信息，譬如输入用户名 icyfenix，密码 123456，浏览器会将字符串 icyfenix:123456 编码为 aWN5ZmVuaXg6MTIzNDU2，然后发送给服务端，HTTP 请求如下所示：
  ```
  GET /admin HTTP/1.1
  Authorization: Basic aWN5ZmVuaXg6MTIzNDU2
  ```
- 服务端接收到请求，解码后检查用户名和密码是否合法，如果合法就返回 /admin 的资源，否则就返回 403 Forbidden 错误，禁止下一步操作。注意 Base64 只是一种编码方式，并非任何形式的加密，所以 Basic 认证的风险是显而易见的

#### 3.3 其他认证

- 除 Basic 认证外，IETF 还定义了很多种可用于实际生产环境的认证方案，列举如下
  - Digest：
    - RFC 7616，HTTP 摘要认证，可视为 Basic 认证的改良版本，针对 Base64 明文发送的风险，Digest 认证把用户名和密码加盐（ 一个被称为 Nonce 的变化值作为盐值 ）后再通过 MD5/SHA 等哈希算法取摘要发送出去
    - 但是这种认证方式依然是不安全的，无论客户端使用何种加密算法加密，无论是否采用了 Nonce 这样的动态盐值去抵御重放和冒认，遇到中间人攻击时依然存在显著的安全风险
  - Bearer：
    - RFC 6750，基于 OAuth 2 规范来完成认证，OAuth2 是一个同时涉及认证与授权的协议
  - HOBA：
    - RFC 7486 ，HOBA（ HTTP Origin-Bound Authentication ）是一种基于自签名证书的认证方案
    - 基于数字证书的信任关系主要有两类模型：
      - 一类是采用 CA（ Certification Authority ）层次结构的模型，由 CA 中心签发证书
      - 另一种是以 IETF 的 Token Binding 协议为基础的 OBC（ Origin Bound Certificate ）自签名证书模型
- HTTP 认证框架中的认证方案是允许自行扩展的，并不要求一定由 RFC 规范来定义，只要用户代理（ User Agent，通常是浏览器，泛指任何使用 HTTP 协议的程序 ）能够识别这种私有的认证方案即可。因此，很多厂商也扩展了自己的认证方案
  - AWS4-HMAC-SHA256：亚马逊 AWS 基于 HMAC-SHA256 哈希算法的认证
  - NTLM / Negotiate：这是微软公司 NT LAN Manager（ NTLM ）用到的两种认证方式
  - Windows Live ID：微软开发并提供的 “统一登入” 认证
  - Twitter Basic：一个不存在的网站所改良的 HTTP 基础认证

## 4. Web 认证（ 表单认证 ）

#### 4.1 HTTP 认证缺陷

- IETF 为 HTTP 认证框架设计了可插拔（ Pluggable ）的认证方案，原本是希望能涌现出各式各样的认证方案去支持不同的应用场景
- 尽管上节列举了一些还算常用的认证方案，但目前的信息系统，尤其是在系统对终端用户的认证场景中，直接采用 HTTP 认证框架的比例其实十分低。因为 HTTP 是“超文本传输协议”，传输协议的根本职责是把资源从服务端传输到客户端，至于资源具体是什么内容，只能由客户端自行解析驱动
- 以 HTTP 协议为基础的认证框架也只能面向传输协议而不是具体传输内容来设计
  - 如果用户想要从服务器中下载文件，弹出一个 HTTP 服务器的对话框，让用户登录是可接受的
  - 但如果用户访问信息系统中的具体服务，身份认证肯定希望是由系统本身的功能去完成的，而不是由 HTTP 服务器来负责认证
- 这种依靠内容而不是传输协议来实现的认证方式，在万维网里被称为 “Web 认证”，由于实现形式上登录表单占了绝对的主流，因此通常也被称为 “表单认证"（ Form Authentication ）

#### 4.2 Web 认证

- 表单认证都没有什么行业标准可循，表单是什么样，其中的用户字段、密码字段、验证码字段是否要在客户端加密，采用何种方式加密，接受表单的服务地址是什么等，都完全由服务端与客户端的开发者自行协商决定
- 表单认证允许做出五花八门的页面，各种程序语言、框架或开发者本身都可以自行决定认证的全套交互细节，譬如，想要支持密码或扫码等多种登录方式、想要支持图形验证码来驱逐爬虫与机器人、想要支持在登录表单提交之前进行必要的表单校验，等等，这些需求十分具体，不具备写入标准规范的通用性，却具备足够的合理性，应当在实现层面去满足
- 同时，如何控制权限保证不产生越权操作、如何传输信息保证内容不被窃听篡改、如何加密敏感内容保证即使泄漏也不被逆推出明文，等等，这些问题已有通行的解决方案，明确定义在规范之中，也应当在架构层面去遵循
- 表单认证与 HTTP 认证不见得是完全对立的，两者有不同的关注点，可以结合使用。以 Fenix's Bookstore 的登录功能为例，页面表单是一个自行设计的 Vue.js 页面，但认证的整个交互过程遵循 OAuth 2 规范的密码模式

#### 4.3 WebAuthn 标准

- 2019 年 3 月，起草了世界首份 Web 内容认证的标准 “WebAuthn”，这个规范不关注界面该是什么样子、要不要验证码、是否要前端校验这些问题，甚至可以省掉表单界面，而是规范了识别方式
- WebAuthn 彻底抛弃了传统的密码登录方式，改为直接采用生物识别（ 指纹、人脸、虹膜、声纹 ）或者实体密钥（ 以 USB、蓝牙、NFC 连接的物理密钥容器 ）来作为身份凭证，从根本上消灭了用户输入错误产生的校验需求和防止机器人模拟产生的验证码需求等问题
- WebAuthn 采用非对称加密的公钥、私钥替代传统的密码，这是非常理想的认证方案
  - 私钥是保密的，只有验证器需要知道它，连用户本人都不需要知道，也就没有人为泄漏的可能
  - 公钥是公开的，可以被任何人看到或存储。公钥可用于验证私钥生成的签名，但不能用来签名，除了得知私钥外，没有其他途径能够生成可被公钥验证为有效的签名
  - 这样服务器就可以通过公钥是否能够解密来判断最终用户的身份是否合法
- WebAuthn 还一揽子地解决了传统密码在网络传输上的风险，无论密码是否客户端进行加密、如何加密，对防御中间人攻击来说都是没有意义的
- 更值得夸赞的是 WebAuthn 为登录过程带来极大的便捷性，不仅注册和验证的用户体验十分优秀，而且彻底避免了用户在一个网站上泄漏密码，所有使用相同密码的网站都受到攻击的问题，这个优点使得用户无须再为每个网站想不同的密码
- WebAuthn 规范涵盖了 “注册” 与 “认证” 两大流程

#### 4.4 WebAuthn 注册

- 先来介绍注册流程，它大致可以分为以下步骤：
  - 用户进入系统的注册页面，这个页面的格式、内容和用户注册时需要填写的信息均不包含在 WebAuthn 标准的定义范围内
  - 当用户填写完信息，点击 “提交注册信息” 的按钮后，服务端先暂存用户提交的数据，生成一个随机字符串（ 规范中称为 Challenge ）和用户的 UserID（ 在规范中称作凭证 ID ），返回给客户端
  - 客户端的 WebAuthn API 接收到 Challenge 和 UserID，把这些信息发送给验证器（ Authenticator ），验证器可理解为用户设备上 TouchID、FaceID、实体密钥等认证设备的统一接口
  - 验证器提示用户进行验证，如果支持多种认证设备，还会提示用户选择一个想要使用的设备。验证的结果是生成一个密钥对（ 公钥和私钥 ），由验证器存储私钥、用户信息以及当前的域名。然后使用私钥对 Challenge 进行签名，并将签名结果、UserID 和公钥一起返回客户端
  - 浏览器将验证器返回的结果转发给服务器
  - 服务器核验信息，检查 UserID 与之前发送的是否一致，并用公钥解密后得到的结果与之前发送的 Challenge 相比较，一致即表明注册通过，由服务端存储该 UserID 对应的公钥
- 流程图如下
  ![image](https://github.com/user-attachments/assets/8dad34d6-46a2-4e46-b77e-31bc332c5ef6)

#### 4.4 WebAuthn 登陆

- 登录流程与注册流程类似，登录流程大致可以分为以下步骤：
  - 用户访问登录页面，填入用户名后即可点击登录按钮
  - 服务器返回随机字符串 Challenge、用户 UserID
  - 浏览器将 Challenge 和 UserID 转发给验证器
  - 验证器提示用户进行认证操作。由于在注册阶段验证器已经存储了该域名的私钥和用户信息，所以如果域名和用户都相同的话，就不需要生成密钥对了，直接以存储的私钥加密 Challenge，然后返回给浏览器
  - 服务端接收到浏览器转发来的被私钥加密的 Challenge，以此前注册时存储的公钥进行解密，如果解密成功则宣告登录成功

## 5. 认证实现

- Java 其实也有自己的认证规范，第一个系统性的 Java 认证规范发布于 Java 1.3 时代，是由 Sun 公司提出的同时面向代码级安全和用户级安全的认证授权服务 JAAS（ Java Authentication and Authorization Service，Java 认证和授权服务 ），在 Java 1.3 处于扩展包中，Java 1.4 时纳入标准包
- 尽管 JAAS 已经考虑了最终用户的认证，但代码级安全在规范中仍然占更主要的地位，但是这个规范提出了很多在今天仍然活跃于主流 Java 安全框架中的概念，譬如一般把用户存放在 “Principal” 之中、密码存在 “Credentials” 之中、登录后从安全上下文 “Context” 中获取状态等常见的安全概念，都可以追溯到这一时期所定下的 API：
  - LoginModule（ javax.security.auth.spi.LoginModule ）
  - LoginContext（ javax.security.auth.login.LoginContext ）
  - Subject（ javax.security.auth.Subject ）
  - Principal（ java.security.Principal ）
  - Credentials（ javax.security.auth.Destroyable、javax.security.auth.Refreshable ）
- 在今时今日，实际活跃于 Java 安全领域的是两个不由 JSR 所规范的安全框架：Apache Shiro 和 Spring Security
- 相较而言，Shiro 更便捷易用，而 Spring Security 的功能则要复杂强大一些。只从目标上看，两个安全框架提供的功能都很类似，大致包括以下四类
  - 认证功能：以 HTTP 协议中定义的各种认证、表单等认证方式确认用户身份，这是本节的主要话题
  - 安全上下文：用户获得认证之后，要开放一些接口，让应用可以得知该用户的基本资料、用户拥有的权限、角色，等等
  - 授权功能：判断并控制认证后的用户对什么资源拥有哪些操作许可（ “授权” 部分 ）
  - 密码的存储与验证：密码是烫手的山芋，存储、传输还是验证都应谨慎处理（ “保密” 部分 ）
