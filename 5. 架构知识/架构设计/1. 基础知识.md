## 1. Object 类型

- 在企业级 Java 开发中（ 现在已经普及到各种语言 ），POJO、PO、DTO、VO、BO、DAO 是常见的架构设计概念，用于实现代码的分层和解耦

#### 1.1 POJO（ Plain Old Java Object，普通 Java 对象 ）

- 定义：普通的 Java 对象，不继承特定框架的类或实现特定接口
- 特点：
  - 不依赖任何框架（ 如 Spring、Hibernate ）
  - 没有强制要求实现接口或继承父类
  - 可以包含业务逻辑，但通常只作为数据载体
- 作用：强调简单性，用于表示领域模型中的基础对象

#### 1.2 PO（ Persistent Object，持久化对象 ）

- 定义：与数据库表直接映射的 Java 对象，通常与 ORM 框架（ 如 Hibernate、MyBatis ）配合使用
- 特点：
  - 字段与数据库表结构一一对应
  - 可能包含 ORM 框架的注解（ 如 @Entity、@Table ）
  - 用于数据库操作（ 增删改查 ）
- 作用：作为数据访问层（ DAO ）与数据库交互的载体

#### 1.3 Entity（ 实体对象 ）

- 定义：通常指代领域模型中的核心对象，与数据库表直接映射（ 如 JPA 的 @Entity ）
- 特点：
  - 包含 ORM 注解（ 如 @Entity, @Table, @Column ）
  - 与 PO（ Persistent Object ）几乎等同，但更强调领域驱动设计（ DDD ）
- 作用：直接操作数据库，与 ORM 框架（ Hibernate、JPA ）配合使用

#### 1.3 DAO（ Data Access Object，数据访问对象 ）

- 定义：抽象数据访问的接口，封装对数据库的操作
- 特点：
  - 提供 CRUD 方法（ 如 save(), findById() ）
  - 实现类依赖 ORM 框架（ 如 MyBatis 的 Mapper、JPA 的 Repository ）
  - 与 PO 紧密关联，操作数据库表
- 作用：分离业务逻辑与数据访问逻辑

#### 1.4 BO（ Business Object，业务对象 ）

- 定义：封装复杂业务逻辑的对象，可能聚合多个 PO 或 DTO
- 特点：
  - 包含业务方法和状态（ 如订单状态流转 ）
  - 可能调用多个 DAO 完成业务操作
  - 用于实现核心业务规则
- 作用：隔离业务逻辑与数据访问，提高可维护性

#### 1.5 DTO（ Data Transfer Object，数据传输对象 ）

- 定义：用于不同层（ 如 Controller 与 Service ）或系统间传输数据的对象
- 特点：
  - 通常只包含数据字段，没有业务逻辑
  - 可能聚合多个 PO 的数据以满足接口需求
  - 用于减少网络调用次数，提高传输效率
- 作用：解耦服务层与展示层，标准化数据传输

#### 1.6 VO（ Value Object，值对象 ）

- 定义：用于前端展示的定制化数据对象，与界面需求紧密相关
- 特点：
  - 字段可能与数据库表不一致（ 如格式化日期、组合字段 ）
  - 只读，通常不用于数据回传
  - 与 DTO 类似，但更专注于展示层
- 作用：隔离领域模型与前端界面，避免暴露敏感数据

#### 1.7 举例

- 现在有一个博客系统，数据库中存储了很多篇博客，我们会做如下设计：
  - 数据库表：表中的博客包括编号、博客标题、博客内容、博客标签、博客分类、博客状态、创建时间、修改时间等
  - PO/Entity：包括编号、博客标题、博客内容、博客标签、博客分类、博客状态、创建时间、修改时间等（ 与数据库表中的字段一样 ）
  - DAO：数据库增删改查的方法，例如新增博客、删除博客、查询所有博客、更新博客
  - BO：基本业务操作，如管理分类、管理标签、修改博客状态等，是我们常说的 service 层操作
  - DTO：在服务端数据传输的对象，编号、博客标题、博客内容、博客标签、博客分类、创建时间、上一篇博客编号、下一篇博客编号
  - VO：在客户端浏览器展示的页面数据，博客标题、博客内容、博客标签、博客分类、创建时间、上一篇博客 URL、下一篇博客 URL
- 数据流动：数据库 ↔ PO/Entity ↔ DAO ↔ BO ↔ Service ↔ DTO ↔ Controller ↔ VO ↔ 前端
- 使用原则：
  - 各层之间通过 DTO/VO 隔离，避免直接传递 PO/Entity
  - BO 负责业务逻辑；DAO 仅操作数据库；VO 仅用于展示，不参与业务逻辑
