## 1. 架构的设计要素

- 所谓架构，一种通俗的说法就是 “最高层次的规划，难以改变的决定”，这些规划和决定奠定了事物未来发展的方向和最终的蓝图
- 而软件架构即 “有关软件整体结构与组件的抽象描述，用于指导大型软件系统各方面的设计”
- 软件架构的核心三要素有，可扩展，高性能，高可用，除此之外，还有，伸缩性，安全性，可维护，可观测性 等

## 2. 核心要素

#### 2.1 高性能

- 性能是网站架构设计的一个重要方面，任何软件架构设计方案都必须考虑可能带来的性能问题。也正因为性能问题几乎无处不在，所以优化网站性能的手段也非常多：
  - 浏览器端：可以通过浏览器缓存、页面压缩传输、合理布局页面、减少 Cookie 传输等手段，甚至可以使用 CDN 加速功能
  - 应用服务器端：可以使用服务器本地缓存和分布式缓存，也可以通过异步操作方式来加快响应，在高并发请求的情况下，可以将多台应用服务器组成一个集群共同对外服务，提高整体处理能力，改善性能
  - 数据库服务器端：可用使用索引、缓存、SQL 性能优化等手段，还可以使用 NoSQL 数据库来优化数据模型、存储结构等
- 衡量网站性能有一系列指标，重要的有响应时间、TPS、系统性能计数器等，通过这些指标以确定系统设计是否达到目标

#### 2.2 高可用

- 可用性即能够不间断提供服务的时间。几乎所有网站都承诺 7×24 小时可用，但事实上任何网站都不可能达到完全的 7×24，总会有一些故障时间，扣除这些故障时间，就是网站的可用时间。一些大型网站可以做到 4 个 9 以上的可用性，也就是 99.99%
- **网站高可用的主要手段就是冗余**，应用部署在多台服务器上同时提供服务，数据存储在多台服务器上相互备份，任何一台服务器都不会影响应用的整体可以，通常的实现手段即把多台服务器通过负载均衡设备组成一个集群
- 衡量一个系统架构设计是否满足高可用的目标，就是假设系统中任何一台或者多台服务器宕机时，以及出现各种不可预期的问题时，系统整体是否依然可用

#### 2.3 可扩展

- 不同于其他架构要素主要关注非功能性需求，网站的扩展性架构直接关注网站的功能需求。网站快速发展，功能不断扩展，如何设计网站的架构使其能够快速响应需求变化，是网站可扩展架构的主要目标
- 衡量网站架构扩展性好坏的主要标准就是在网站增加新的业务产品时，是否可以实现对现有产品透明无影响，不同产品之间是否很少耦合等
- 网站可扩展架构的主要手段是事件驱动架构和分布式服务
- 事件驱动通常利用消息队列实现，通过这种方式将消息生产和处理逻辑分隔开
- 服务器服务则是将业务和可复用服务分离开来，通过分布式服务框架调用。新增加产品可用通过调用可复用的服务来实现自身的业务逻辑，而对现有产品没有任何影响

#### 2.4 伸缩性

- 大型网站需要面对大量用户的高并发访问和存储海量数据，网站通过集群的方式将多台服务器组成一个整体共同提供服务。所谓伸缩性是指通过不断向集群中加入服务器的手段来缓解不断整体上市用户并发访问压力和不断增长的数据存储需求
- 衡量架构伸缩性的主要标准就是是否可用多台服务器构建集群，是否容易向集群中添加新的服务器。加入新的服务器后是否可以提供和原来的服务器无差别的服务。集群中可容纳的总服务器数量是否有限制

#### 2.5 安全性

- 互联网是开发的，任何人在任何地方都可以访问网站。网站的安全架构就是保护网站不受恶意访问和攻击，保护网站的重要数据不被窃取
- 衡量网站安全架构的标准就是针对现存和潜在的各种攻击和窃密手段，是否有可靠的应对策略

#### 2.6 可维护

- 从软件的整个生命周期来看，维护阶段绝对占大头。但大部分人都喜欢挖坑，不喜欢填坑。因此有必要，在刚开就把坑开的足够好。有三个原则：
  - 可操作性：便于运维团队无痛接手，尽量实现自动化
  - 简洁性：便于团队新人开发平滑上手，消除额外复杂度的最好工具是合理的抽象，并尽量消除各种复杂度。如，层次化抽象
  - 可演化性：便于后面需求快速适配，避免耦合过紧，将代码绑定到某种实现上。简单易懂的系统通常比复杂系统更容易修改

## 3. 高并发场景

- 理解上高并发只是应对于特殊场景，而不是系统的架构设计要素
- **高并发实现的四板斧（ 就是 高性能 和 高可用 的实现 ）：缓存，限流，容错，降级**
- 高并发场景本质就是 高性能 + 高可用，能快速处理请求，和避免系统故障
  - 其中 **缓存 属于高性能的范围**，高性能的指标经常和高并发的指标紧密相关
  - 其中 **限流，熔断降级 属于高可用的范围**，是为了防止故障蔓延，增强容错性，保证系统的可用性

## 4. 秒杀系统设计

- 短时间内，大量用户涌入，集中读和写有限的库存
- 解决思路：层层拦截，将请求尽量拦截在系统上游，避免将锁冲落到数据库上
- 第一层：
  - 客户端优化产品层面，用户点击 “查询” 或者 “购票” 后，按钮置灰，禁止用户重复提交请求
  - 或者 JS 层面，进行节流，限制用户在 x 秒之内只能提交一次请求，比如微信摇一摇抢红包
  - 第一层基本可以拦截 80%的请求
- 第二层：
  - 站点层面的请求拦截（ nginx 层，写流控模块 ），对 uid 进行请求计数和去重，甚至不需要统一存储计数，直接站点层内存存储。这样计数会不准，但最简单，比如 guava 本地缓存
  - 比如 1 个 uid，5 秒只准透过 1 个请求，这样又能拦住 99% 的 for 循环请求。对于 5s 内的无效请求，统一返回错误提示或错误页面
  - 这个方式拦住了写 for 循环发 HTTP 请求的程序员，但是如果有些黑客控制了 10w 个手机，手里有 10w 个 uid，同时发请求（ 先不考虑实名制的问题，小米抢手机不需要实名制 ），这下怎么办，站点层按照 uid 限流拦不住了
- 第三层：
  - 服务层拦截方案一：写请求放到队列中，每次只透有限的写请求到数据层，如果成功了再放下一批，直到库存不够，队列里的写请求全部返回 “已售完”
  - 服务层拦截方案二：采用漏斗机制，只放一倍的流量进来，多余的返回 “已售完”，把写压力转换成读压力。读请求，用 cache，redis 单机可以抗 10W QPS，用异步线程定时更新缓存里的库存值
  - 还有提示 “模糊化”，比如火车余票查询，票剩了 58 张，还是 26 张，你真的关注么，其实只关心有票和无票
- 第四层：
  - 数据库层浏览器拦截了 80%，站点层拦截了 99.9% 并做了页面缓存，服务层又做了写请求队列与数据缓存，每次透到数据库层的请求都是可控的。 db 基本就没什么压力了，通过自身锁机制来控制，避免出现超卖
- 总结：
  - 尽量将请求拦截在系统上游（ 越上游越好 ）
  - 读多写少的多使用缓存（ 缓存抗读压力 ）

## 5. 前端架构

- 基础规范体系：
  - 建设一套标准的，可执行的约束规范，主要分为技术规范和研发流程规范
  - 技术规范包括：分支管理规范，编码规范（ 命名规范，文档注释规范，代码风格规范，目录结构规范 等 ），Commit 规范，MR 提交规范，CR 规范，变更合入规范 等
  - 研发流程规范包括：需求评审规范，技术评审规范，RD 自测规范，复盘规范，事故通报规范 等
- 前端工程化：
  - 利用工程化的思想和方法来优化前端开发流程，提升开发效率和代码质量
  - 主要包括自动化构建、模块化开发、代码规范检查、自动化测试、持续集成和部署等方面。例如，使用 Webpack 进行模块打包，使用 Babel 进行代码转译，使用 ESLint 进行代码规范检查，使用 Jest 进行单元测试等
- 研发提效体系：
  - 主要包括：组件库，BFF，低代码平台搭建，探索 ProCode，LowCode，NoCode 等模式
- 交付质量体系：
  - 主要包括：质量，安全，性能，可测性
  - 确保产品或功能交付的质量和稳定性。这包括制定和执行严格的测试策略，并在流水线上进行充分的测试等，实施灰度发布和监控机制等
- 交付效率体系：
  - 主要包括：需求管理，研发产能，持续交付
  - 这包括
    - 将需求和代码分支的绑定，创建需求的时候，自动建分支
    - 优化测试部署流水线
    - 优化上线流程，比如合入主分支后自动发布上线流程，并且自动推进需求进展
- 稳定性体系：
  - 主要包括：容灾，监控告警，压测播测
  - 关注产品运行稳定性。这包括实施线上监控和报警系统、灾备和容灾方案、持续优化和调优系统性能等。例如，对线上报错进行统计和警告，即时通知值班同学，并给出完善的日志，帮助研发快速定位到问题
