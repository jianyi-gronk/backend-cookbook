## 1. 什么是 IoC（ Inversion of Control，控制反转 ）

- IoC：控制反转，即由用户管理 Bean 转变为框架管理 Bean，且 Spring 框架托管创建的 Bean 放在 IoC Container 中
- Spring Bean：类似是定义的一个组件，而这个组件的作用就是实现某个功能的，这里所定义的 bean 就相当于给了一个更为简便的方法来调用这个组件去实现你要完成的功能

#### 1.1 和传统程序区别

- 传统程序设计下，都是主动去创建相关对象然后再组合起来：
  ![image](https://github.com/user-attachments/assets/23134af7-ab7a-49a6-af5c-29cf39f1506f)
- 当有了 IoC/DI 的容器后，在客户端类中不再主动去创建这些对象了，而是通过配置，去交给容器处理：
  ![image](https://github.com/user-attachments/assets/3a331e93-a6b7-4fbc-b97e-0f622006f9b1)

#### 1.2 IoC 和 DI 关系

- IoC 是设计思想，DI 是实现方式
- DI（ Dependency Injection，依赖注入 ）：
  - 组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中
  - 依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台
  - 通过依赖注入机制，只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，不需要关心具体的资源来自何处，由谁实现

#### 1.3 Ioc 配置方式

- IoC 是通过配置告诉容器应该如何管理 Bean，总共有三种配置方式，xml 配置，Java 配置 和 注解，目前的主流方式是 注解 + Java 配置
- xml 配置：
  - 将 bean 的信息配置 .xml 文件里，通过 Spring 加载文件来创建 bean。这种方式出现很多早前的 SSM 项目中，将第三方类库或者一些配置工具类都以这种方式进行配置，主要原因是由于第三方类不支持 Spring 注解
  - 优点：可以使用于任何场景，结构清晰，通俗易懂
  - 缺点：配置繁琐，不易维护，枯燥无味，扩展性差
- Java 配置
  - 将类的创建交给 JavcConfig 类来完成，Spring 只负责维护和管理，采用纯 Java 创建方式。其本质上就是把在 XML 上的配置声明转移到 Java 配置类中
  - 优点：适用于任何场景，配置方便，因为是纯 Java 代码，扩展性高，十分灵活
  - 缺点：由于是采用 Java 类的方式，声明不明显，如果大量配置，可读性比较差
- 注解
  - 通过在类上加注解的方式，来声明一个类交给 Spring 管理，Spring 会自动扫描带有 @Component，@Controller，@Service，@Repository 这四个注解的类，然后帮我们创建并管理，前提是需要先配置 Spring 的注解扫描器
  - 优点：开发便捷，通俗易懂，方便维护
  - 缺点：具有局限性，对于一些第三方资源，无法添加注解，只能采用 XML 或 JavaConfig 的方式配置

## 2. 依赖注入方式

- 方式有三种：setter 方式注入，构造函数注入（ Construct 注入 ），注解注入

#### 2.1 setter 方式

- 在 XML 配置方式中，用 property 标签，同时在 userService 中通过 setXxx 注入
- XML 配置
  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans.xsd">
      <!-- services -->
      <bean id="userService" class="org.study.springframework.service.UserServiceImpl">
          <property name="userDao" ref="userDao"/>
          <!-- additional collaborators and configuration for this bean go here -->
      </bean>
      <!-- more bean definitions for services go here -->
  </beans>
  ```
- 除了修改配置，userService 还需要引入 userDao

  - 第一步，需要 new UserServiceImpl() 创建对象, 所以需要默认构造函数
  - 第二步，调用 setUserDao() 函数注入 userDao 的值, 所以需要 setUserDao()函数

  ```java
  public class UserServiceImpl {
    /**
     * user dao impl.
      */
    private UserDaoImpl userDao;

    /**
     * init.
      */
    public UserServiceImpl() {
    }

    /**
     * set dao.
      *
      * @param userDao user dao
      */
    public void setUserDao(UserDaoImpl userDao) {
      this.userDao = userDao;
    }
  }
  ```

#### 2.2 构造函数

- 在 XML 配置方式中，不是用 property 标签，而是 constructor-arg 标签，同时不是通过 setXxx，而是通过构造函数参数注入
- XML 配置
  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans.xsd">
      <!-- services -->
      <bean id="userService" class="tech.pdai.springframework.service.UserServiceImpl">
          <constructor-arg name="userDao" ref="userDao"/>
          <!-- additional collaborators and configuration for this bean go here -->
      </bean>
      <!-- more bean definitions for services go here -->
  </beans>
  ```
- 除了修改配置，userService 还需要引入 userDao

  - 本质上是通过 new UserServiceImpl(userDao) 注入依赖

  ```java
  public class UserServiceImpl {
    /**
     * user dao impl.
      */
    private final UserDaoImpl userDao;

    /**
     * init.
      * @param userDaoImpl user dao impl
      */
    public UserServiceImpl(UserDaoImpl userDaoImpl) {
        this.userDao = userDaoImpl;
    }
  }
  ```

#### 2.3 注解注入

- 以 @Autowired（ 自动注入 ）注解注入为例
- 修饰符有三个属性：Constructor，byType，byName，默认按照 byType 注入
  - constructor：通过构造方法进行自动注入，spring 会匹配与构造方法参数类型一致的 bean 进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的 bean，那么 spring 会优先将 bean 注入到多参数的构造方法中
  - byName：被注入 bean 的 id 名必须与 set 方法后半截匹配，并且 id 名称的第一个单词首字母必须小写，这一点与手动 set 注入有点不同
  - byType：查找所有的 set 方法，将符合符合参数类型的 bean 注入
- 只需要改 userService

  ```java
  @Service
  public class UserServiceImpl {

      /**
        * user dao impl.
        */
      @Autowired
      private UserDaoImpl userDao;
  }
  ```
