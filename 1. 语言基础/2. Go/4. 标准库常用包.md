## 1. strconv 包

- string conversion 缩写，其主要作用是实现字符串和基本数据类型（ 如整数、浮点数、布尔值等 ）之间的相互转换
- 常用函数
  - strconv.Itoa：用于将一个整数转换为对应的十进制字符串表示
  - strconv.FormatInt：可以将整数转换为指定进制（ 如二进制、八进制、十六进制等 ）的字符串表示
  - strconv.Atoi：用于将十进制字符串转换为整数
  - strconv.ParseInt：可以将指定进制的字符串转换为整数，并且可以指定整数的位数（ 如 8 位、16 位、32 位、64 位等 ）
  - strconv.FormatFloat：用于将浮点数转换为字符串，可以指定输出的格式（ 如精度、是否使用科学计数法等 ）
  - strconv.ParseFloat：用于将字符串转换为浮点数，可以指定浮点数的位数（ 如 32 位、64 位等 ）
  - strconv.FormatBool：用于将布尔值转换为字符串 "true" 或 "false"
  - strconv.ParseBool：用于将字符串 "true"、"false"、"1"、"0" 等转换为布尔值

## 2. time 包

## 2. sync 包

#### 2.1 sync.Map

- sync.Map：并发安全的 Map
  - 不需要 make 就能使用
  - 还内置了 Store、Load、LoadOrStore、Delete、Range 等操作方法，自行体验
- 普通 map，如果在 2 个 Goroutine 分别读写，会报错

  ```go
  func unsafeMap(){
    var wg sync.WaitGroup
    m := make(map[int]int)
    wg.Add(2)
    go func() {
      defer wg.Done()
      for i := 0; i < 10000; i++ {
        m[i] = i
      }
    }()

    go func() {
      defer wg.Done()
      for i := 0; i < 10000; i++ {
        fmt.Println(m[i])
      }
    }()
    wg.Wait()
  }

  /*
    0
    fatal error: concurrent map read and map write

    goroutine 7 [running]:
    runtime.throw({0x10a76fa, 0x0})
   */
  ```

- 使用并发安全的 sync.Map

  ```go
  func safeMap() {
    var wg sync.WaitGroup
    var m sync.Map
    wg.Add(2)
    go func() {
      defer wg.Done()
      for i := 0; i < 10000; i++ {
        m.Store(i, i)
      }
    }()

    go func() {
      defer wg.Done()
      for i := 0; i < 10000; i++ {
        fmt.Println(m.Load(i))
      }
    }()
    wg.Wait()
  }
  ```

#### 2.2 sync.Once

- 很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等
- init 函数是当所在的 package 首次被加载时执行，但若迟迟未被使用，则既浪费了内存，又延长了程序加载时间
- sync.Once 被用于控制变量的初始化，可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的，这个变量的读写满足如下三个条件：
  - 当且仅当第一次访问某个变量时，进行初始化（ 写 ）
  - 变量初始化过程中，所有读都被阻塞，直到初始化完成
  - 变量仅初始化一次，初始化完成后驻留在内存里
- 基础样例
  ```go
  var loadOnce sync.Once
  var x int
  for i:=0;i<10;i++{
    loadOnce.Do(func() {
      x++
    })
  }
  fmt.Println(x)
  ```

#### 2.3 sync.Cond

- 条件变量 sync.Cond 基于互斥锁/读写锁，用来协调想要访问共享资源的 goroutine
- 创建实例
  ```go
  // NewCond 创建 Cond 实例时，需要关联一个锁
  func NewCond(l Locker) *Cond
  ```
- 广播唤醒所有
  ```go
  // Broadcast 唤醒所有等待条件变量 c 的 goroutine，无需锁保护
  func (c *Cond) Broadcast()
  ```
- 唤醒一个协程
  ```go
  // Signal 只唤醒任意 1 个等待条件变量 c 的 goroutine，无需锁保护
  func (c *Cond) Signal()
  ```
- 等待
  ```go
  func (c *Cond) Wait()
  ```
