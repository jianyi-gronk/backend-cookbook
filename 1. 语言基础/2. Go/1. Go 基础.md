## 1. Go 入门

- src/utils/add.go

  ```go
  package calc

  func Add(a, b int) int {
    return a + b
  }
  ```

- src/main.go

  ```go
  package main

  import (
    "fmt"
    "utils"
  )

  func main() {
    a := 1
    b := 1
    res := calc.Add(a, b)
    fmt.Printf("%d + %d = %d\n", a, b, res) // 1 + 1 = 2
  }
  ```

- 然后通过 go run 启动项目，注意，更新代码后，需要重新启动才能让改动生效

#### 1.1 package

- package 是包，每个 **文件夹** 通常是一个包，默认包名就是文件夹名，文件夹下所有的 .go 文件全部都是同一个包
- main 包整个项目的入口，你可以在指定任意一个文件夹当作程序的入口，然后把里面所有文件第一行改成 package main，也可以把项目根目录当作 main 包

#### 1.2 import

- import 关键字代表引入其他地方的包，可以是当前项目的，也可以是别人写的
- 这里 import "fmt" 引入的就是 go 原生的 fmt 包，专门用来输出文本的，而 main/clac 就是自己写的包
- 可以给 import 的包起别名，如果只想引用（ 比如只想调用后面说的 init 函数 ），可以起别名为 "\_"
  ```go
  import (
    _ "xxx"
  )
  ```

#### 1.3 导出

- add.go 中的 Add 函数名**首字母必须大写**，只有大写的才是 Public 权限，外面的包才能访问，否则只能自己文件夹下代码才能访问
- add.go 的改名为 addyyy.go 也可以，查找 calc 包的时候，并不会根据 add.go 这个文件名来查找，而是根据文件夹名来查找，一个文件夹下的所有文件都属于同一个包，所以函数变量自然不能重复
- main 中调用 calc.Add(1, 2) 时，calc 是包， 必须跟 add.go 中的 package 处的包名一致，否则报错

#### 1.4 main 函数

- main 入口函数，每个项目只有一个 main 函数，通常在 main 包中
- 基础样例
  ```go
  func main() {
    fmt.Println("Hello, World!")
  }
  ```

#### 1.5 init 函数

- init 函数没有参数和返回值，引入包的时候，该包内每个文件中的 init 函数都会被自动执行
- **需注意，init 会在 main 之前执行**
- 多个 init 函数的执行顺序
  - **同一个包内的 init 函数会按照源文件的文件名排序，然后依次执行每个文件中的 init 函数**
  - **每个文件可以定义多个 init 函数，这些 init 函数会按照它们在文件中出现的顺序依次执行**
- 基础样例

  ```go
  func init() {
      fmt.Println("This is the first init function.")
  }

  func init() {
      fmt.Println("This is the second init function.")
  }

  func main() {
      fmt.Println("This is the main function.")
  }


  /*
    This is the first init function.
    This is the second init function.
    This is the main function.
   */
  ```

## 2. Go mod

- 是个包管理工具，例如 java 的 maven，javascript 的 npm

#### 2.1 内容介绍

- go.mod 的内容比较容易理解
  - 第一块：模块的引用路径
  - 第二块：项目使用的 go 版本
  - 第三块：项目所需的直接依赖包及其版本
  - 第四块（ 可选 ）：忽略指定版本的依赖包
  - 第五块（ 可选 ）：由于在国内访问 golang.org/x 的各个包都需要翻墙，因此可以在 go.mod 中使用 replace 替换成 github 上对应的库
- 举例

  ```
  // 也可以写成 moudle module-test，但是可引用性较差
  //   此时如果要在其他项目中引用这个模块，需要手动配置 Go 的模块代理或者直接指定本地路径，否则 Go 工具链无法自动找到该模块的代码
  //   写成 github.com/xxx，其他开发者可以直接通过 go get github.com/xxx 获取
  module github.com/test/module-test

  go 1.14

  require (
    example.com/apple v0.1.2
    example.com/banana v1.2.3
    example.com/banana/v2 v2.3.4
    example.com/pear // indirect
    example.com/strawberry // incompatible
  )

  exclude example.com/banana v1.2.4
  replace（
    golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac = > github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac
    golang.org/x/net v0.0.0-20180821023952-922f4815f713 = > github.com/golang/net v0.0.0-20180826012351-8a410e7b638d
    golang.org/x/text v0.3.0 = > github.com/golang/text v0.3.0
  )
  ```

#### 2.2 使用方法

- go mod init：初始化 go mod， 生成 go.mod 文件，后可接参数指定 module 名，上面已经演示过
- go mod download：手动触发下载依赖包到本地 cache（ 默认为$GOPATH/pkg/mod 目录 ）
- go mod graph：打印项目的模块依赖结构
- go mod tidy ：添加缺少的包，且删除无用的包
- go mod verify ：校验模块是否被篡改过
- go mod why：查看为什么需要依赖
- go mod vendor ：导出项目所有依赖到 vendor 下

#### 2.3 写入方法

- 有两种方法：
  - 你只要在项目中有 import 并使用或者使用下划线强制占用，然后 go build 时 go module 就会自动下载并添加
  - go mod tidy

## 3. go 项目结构

#### 3.1 非微服务项目

- Go 官方并没有定义标准的项目结构分层，但社区维护了一个 project-layout 仓库，其中包含了一个通用的项目结构示例
  ```bash
  project/
  ├── api/
  │   ├── handler/         # API请求处理程序
  │   ├── middleware/      # API中间件
  │   └── router.go        # 路由定义
  ├── cmd/
  │   ├── app/             # 应用程序入口点
  │   └── cli/             # 命令行接口入口点
  ├── config/              # 配置文件和配置相关代码
  ├── internal/            # 私有应用程序和库代码
  │   ├── model/           # 数据库模型
  │   ├── repository/      # 数据库访问层
  │   ├── service/         # 业务逻辑层
  │   └── util/            # 工具函数
  ├── migrations/          # 数据库迁移文件
  ├── pkg/                 # 可公共使用的库代码
  ├── scripts/             # 构建、安装等脚本
  ├── test/                # 测试相关代码
  ├── web/                 # Web前端相关代码
  ├── .gitignore           # Git忽略文件列表
  ├── LICENSE              # 项目许可证
  ├── README.md            # 项目说明文件
  └── go.mod               # Go模块定义文件
  ```

#### 3.2 微服务项目

- 使用 go-zero 框架的项目可以通过 goctl 工具自动生成符合 go-zero 规范的项目结构、代码文件和配置文件。如果使用 dubbo-go，则可以通过 dubboctl 工具
- 单体仓库目录结构如下
  ```bash
  project/
  ├── api_gateway
  │   ├── api
  │   ├── etc
  │   ├── internal
  │   │   ├── config
  │   │   ├── handler
  │   │   ├── logic
  │   │   ├── svc
  │   │   └── types
  ├── demo.sql
  ├── go.mod
  ├── go.sum
  ├── README.md
  └── service
      ├── comment
      │   ├── comment.go
      │   ├── comment.proto
      │   ├── commentservice
      │   ├── etc
      │   ├── internal
      │   ├── model
      │   └── pb
      └── user
          ├── etc
          ├── internal
          ├── model
          ├── pb
          ├── user.go
          ├── user.proto
          └── userservice
  ```

#### 3.3 DDD 项目

- DDD 项目结构
  ```bash
  server/
  ├── README.md               # 项目文档
  ├── application             # 业务调度层
  │   ├── event               # 微服务事件推送或订阅
  │   │   ├── publish         # 事件发布
  │   │   └── subscribe       # 事件订阅
  │   └── service             # 用于连接 Controller 和 Domain，进行三方接口调用等其他操作
  ├── domain                  # 领域服务层（领域逻辑和领域对象，主要的业务逻辑，采用充血模型）
  │   ├── aggregate01         # Aggregate 聚合根目录
  │   │   ├── entity          # entity 实体、VO 值对象以及工厂模式（Factory）相关
  │   │   ├── event           # 事件实体以及与事件活动相关的业务逻辑代码
  │   │   ├── repository      # 持久化领域对象，通常仅包括仓储接口，仓储实现应放到基础架构层实现
  │   │   └── service         # 领域服务代码，一个领域服务是多个实体组合出来的一段业务逻辑
  │   ├── aggregate02
  │   └── ...
  ├── go.mod                  # 依赖文件
  ├── infrastructure          # 基础设施层
  │   ├── api                 # 第三方 API/SDK
  │   ├── configs             # 配置参数变量
  │   ├── database            # 初始化数据库
  │   ├── mq                  # 消息队列连接和配置
  │   ├── persistence         # 数据持久化（Domain 层 repository 的具体实现，数据库 CRUD 操作）
  │   └── pkg                 # 工具函数
  │       ├── common          # 与业务相关包
  │       └── utils           # 公共基础包
  ├── interfaces              # 接口层
  │   ├── assembler           # 实现 DTO 数据传输对象与 Domain Entity 之间的相互转换和数据交换，从表示层（Presentation Layer）向领域层（Domain Layer）进行数据传递
  │   ├── controller          # 控制器路由函数
  │   └── dto/vo              # 可包含多个领域对象的属性：DTO（Data Transfer Object）主要关注数据的传输，通常用于面向服务或接口设计，用于在系统的不同部分之间传递数据。VO（View Object）则更常用于用户界面 UI 层，用于呈现数据给用户
  └── main.go                 # 主入口
  ```
