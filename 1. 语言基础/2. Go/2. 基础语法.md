## 1. 基础语法

#### 1.1 声明变量

- 第一种方式：通过 var

  ```go
  var name string // 结构为 var 变量名 类型
  name = "s" // 赋值

  var p = name // 或根据赋值自动判断类型，因为 name 是字符串类型，所以 p 也是字符串类型

  // 多变量声明，int 类型不赋值自动赋值为 0，比如 d e f
  var a, b, c = 1, 2, 3
  var d, e, f int

  // 一次声明多个类型不同的变量
    var (
      k int
      l string
    )

  var m, n, o = "a", 1, true // 也可以同时直接赋值
  ```

- 第二个方式：通过 :=，但只能在函数内部使用

  ```go
  q := "as" //直接声明并赋值（ 必须是初次声明才有冒号 ）
  h, i, j := 1, 2, 3 // 多个变量一次性声明并赋值
  ```

#### 1.2 声明常量

- 通过 const 声明

  ```go
  const A int = 1
  const B = 1
  const C, D, E = 1, 1, 1

  const (
    Success = 0
    UnKonw  = 1
    Error   = 2
  )
  ```

#### 1.3 if else

```go
if 20<0 {...} else {...}
```

#### 1.4 switch

- 和 c++ 类似，有两个不同点
  - 第一个不同点：不需要给每个 case 都手动加入 break
  - 第二个不同点：switch 后可以不跟变量
- 基础样例
  ```go
  func switchDemo(number int) {
    switch {
      case number >= 90:
        ...
      case number >= 60:
        ...
      default:
        ...
    }
  }
  ```

#### 1.5 循环

- go 中只有 for，没有 while

  ```go
  nums := []int{1, 2, 3, 4, 5, 6}

  for i := 0; i < len(nums); i++ {
    fmt.Println(i)
  }

  for i < len(num) {
    fmt.Println(a)
    a++
  }

  // map 的 range 是随机的
  for index, value := range nums {
    fmt.Printf("key: %v , value: %v\n", index, value)
  }

  // 死循环
  for { ... }
  ```

#### 1.6 指针

- 和 C++ 类似
- 基础用法

  ```go
  func swap(x *int, y *int) {
    var temp int
    temp = *x
    *x = *y
    *y = temp
  }

  a := 100
  b := 200

  swap(&a, &b)
  ```

- 多维指针
  ```go
  var ptr *int      // 一维
  var pptr **int    // 二维
  var ppptr ***int  // 三维
  ```

#### 1.7 类型转换

- 类型(value)
  ```go
  // 比如 string()，用于将其他一些基本数据类型转换为 string 类型，有使用范围
  //   例如将 byte 切片（[]byte）、rune 切片（[]rune）、int、float 等
  //   可以直接和字符串有对应关系的数据类型进行转换
  string(value)
  ```

#### 1.8 类型断言

- 类型断言主要用于判断 interface{} 和 any 类型，如果是，则将其转换为该具体类型；如果不是，则可以通过返回的布尔值判断并处理错误情况
  ```go
  value.(string)
  ```
- interface{} 和 any 效果一样，但是 interface{} 是从语言诞生就有，any 是从 Go 1.18 之后才有

#### 1.9 延迟调用

- 延迟调用语句叫 defer 语句，它在函数返回时才会被调用，如果有多个 defer 语句那么它会被逆序执行
  ```go
  defer fmt.Println("see you next time!")
  ```
- 涉及到 defer 的操作
  - 并发时释放共享资源锁
  - 延迟释放文件句柄
  - 延迟关闭 tcp 连接
  - 延迟关闭数据库连接

#### 1.10 panic

- panic 可以手动触发崩溃宕机
  ```go
  panic("人工创建的运行时异常")
  ```
- recover 可以拦截崩溃，只有在 defer 代码块中才会有效果，通常可以在其中打印异常日志，关闭资源，跳过异常数据部分，然后继续运行下去，不然线上容易出现大面积雪崩
  ```go
  func divisionIntRecover(a, b int) (ret int) {
    defer func() {
      if err := recover(); err != nil {
        // 打印异常，关闭资源，退出此函数
        fmt.Println(err)
        ret = -1
      }
    }()
    return a / b
  }
  ```

## 2. 函数

- 基础用法

  ```go
  // 多个参数，多个返回值
  func funReturnMany(a, b int, c string) (string, int, int) {
    return c, b, a
  }

  // 提前声明函数返回值
  func funReturnName() (res int) {
    //var res 省掉了
    res = 1 + 1
    // 这里不用再定义返回值
    return
  }
  ```

- 引用传递

  ```go
  // 参数引用传递
  func change(a, b *int){
    tmp := *a
    *a = *b
    *b = tmp
  }

  a, b := 1, 2
  change(&a, &b)
  ```

- 参数不确定

  ```go
  // 参数数量不确定，可以用一个变量去接受所有
  func sum(t ...int) (res int) {
    for _, v := range t {
      res += v
    }
    return res
  }
  fmt.Println(sum(1, 2, 3, 4, 5))

  // 参数类型也不确定，可以使用 interface{} 或 any 获取
  func sumNum(t ...interface{}) (res float64){
    for _,tmp := range t{
      switch v :=tmp.(type) {
      case int:
        res += float64(v)
      case float64:
        res+= v
      }
    }
    return res
  }
  ```

## 3. 引用类型

- go 语言中的引用类型有，切片 slice、字典 map、接口 interface、函数 func 以及 通道 channel
- 所有的引用类型定义时都必须要用 make 申请空间，初值是 nil

#### 3.1 map

- 基础用法

  ```go
  var m map[string]string
  m = make(map[string]string)

  n := make(map[string]string)

  // 使用字面量初始化
  t := map[string]int{
    "a": 1,
  }

  // 赋值
  m["a"] = "b"
  // 遍历
  for key := range m {
    fmt.Println("key:", key, ",value:", m[key])
  }
  // 删除元素
  delete(m, "name")
  ```

- 并发场景

  ```go
  // map 在并发读的时候没问题，但是并发写不行（ 线程不安全 ），会发生竞态问题
  // 此时需要使用 sync.Map
  var scene sync.Map
  scene.Store("name", "coding3min")

  v, ok := scene.Load("name")
  if ok {
    fmt.Println(v)
  }
  ```

#### 3.2 数组和切片

- Go 数组和切片都是从 c 语言中延续过来的设计，其中切片是在数组之上的抽象数据类型
- 数组特性
  - 数组中是固定长度的连续空间（ 内存区域 ）
  - 数组中所有元素的类型是一样的
- 数组基础用法

  ```go
  // 声明 10 个 int 长度的数组
  var a1 [10]int

  /// 初始化
  var b1 = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}

  // 多维
  var arr [3][3]int
  // 赋值
  arr = [3][3]int{
    {1, 2, 3},
    {2, 3, 4},
    {3, 4, 5},
  }
  ```

- 切片特性
  - 可以声明一个空切片（ 默认值为 nil ），然后再增加值的过程中动态的改变切片值大小
  - 每个切片，在声明或扩建时会分配一段连续的空间，称为容量 cap，是不可见的。真正在使用的只有一部分连续的空间，称为长度 len，是可见的
  - 每次 新增元素 时，如果发现 cap 已经不足以给 len 使用，就会重新分配原 cap 两倍的容量，把原切片里已有内容全部迁移过去。新分配的空间也是连续的，不过不一定直接在原切片内存地址处扩容，也有可能是新的内存地址
  - 也可以把部分元素截取出来，且截取出现的元素依然是同一块内存
- 切片基础用法

  ```go
  // 声明空切片
  var sliceTmp []int

  // 追加元素
  sliceTmp = append(sliceTmp, 4)
  sliceTmp = append(sliceTmp, 5)

  // 遍历切片
  for _,v := range slice1{
    fmt.Println(v)
  }

  // 普通切片的声明方式，长度和容量是一致的，比如下面例子 len 和 cap 默认为 3
  slice1 := []int{1, 2, 3}
  // 也可以自己控制 len 和 cap
  slice2 = make([]int, 2, 5) // 2 是长度 5 是容量

  // 可以截取第一个元素，len 为 1，cap 还是 10，修改会影响原数组
  slice3 := slice1[0:1]
  ```

## 4. 结构体与接口

#### 4.1 结构体

- go 中没有类，而是将结构体看成类
- 结构体基础用法

  ```go
  type people struct {
    name string // 如果字段名首字母是小写，那么只能被同一个包的代码访问和使用
    Age number // 如果字段名首字母是大写，那么可被同一个包之外的代码访问和使用
  }

  // 这样写法，结构体是值传递，会复制一份结构体的副本，函数内部对这个副本的修改不会影响到原始结构体
  func (p people) setName1() {
    p.name = "Alice"
  }

  func (p *people) setName2() {
    p.name = "Bob"
  }

  p1 := people{}
  p1.setName1()
  p2 := &people{}
  P2.setName2()

  fmt.Println(p1.name) // 输出为空
  fmt.Println(p2.name) // 输出 Bob
  ```

- 注意，**结构体字段通常都是首字母大写，不然可能会出现作为参数传递给函数，但是函数拿不到字段的问题**
- 注意，**结构体字段是否是指针的形式需要考虑，如果是指针，那么在序列化时，会把指针放入字符串结果，如果传递该字符串到其他机器则可能拿不到值**

#### 4.2 匿名字段

- 结构体可以包含匿名字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字
- **如果匿名字段是结构体，则其字段会被提升到外部结构体的层次，因此可以直接访问匿名字段的成员**
- 基础样例

  ```go
  type Server struct {
    IP   string
    Port int
  }

  type Config struct {
    Server
    string
  }

  func main() {
    // 创建 Config 结构体的实例
    cfg := Config {
      string: "Hello, World!",
      Server: {IP: "127.0.0.1", Port: 8080},
    }

    // 访问匿名字段
    fmt.Println(cfg.string)
    fmt.Println(cfg.Server.IP)

    // 也可以直接访问匿名字段的成员
    fmt.Println(cfg.IP)
  }
  ```

#### 4.3 结构体标签

- 结构体标签需要使用反引号 ` 来包裹，可以在运行时通过反射机制获取并处理。虽然内容可以自定义，但通常它是由以空格分隔的键值对组成，并且键和值之间使用冒号分隔，值需要用双引号包裹
- 常用场景
  - 序列化，可以指定字段在 JSON 或 XML 数据中的名称
  - 映射，可以指定字段在数据库表中的列名，或者指定字段和配置文件中键的映射关系
- 结构体标签用于序列化

  ```go
  // 使用结构体标签 json，然后进行 JSON 序列化时，字段会被序列化为 json 键对应的值
  type User struct {
    FirstName string `json:"first_name"`
    LastName  string `json:"last_name"`
  }

  func main() {
    u := User{FirstName: "John", LastName: "Doe"}
    jsonData := json.Marshal(u)
    fmt.Println(string(jsonData)) // {"first_name":"John","last_name":"Doe"}
  }
  ```

- 结构体标签用于映射

  ```go
  import (
    "fmt"
    "github.com/BurntSushi/toml"
  )

  // Config 定义配置结构体
  type Config struct {
      Server struct {
          IP   string `toml:"ip"` // 用于和 toml 文件数据进行映射
          Port int    `toml:"port"`
      } `toml:"server"`
  }

  func main() {
    tomlData := `
      [server]
      ip = "127.0.0.1"
      port = 8080
    `
    var config Config
    // 解析 TOML 文件的数据到 config
    if _, err := toml.Decode(tomlData, &config); err != nil {
        fmt.Println("Error decoding TOML:", err)
        return
    }

    // 解析后的配置信息
    fmt.Printf("Server IP: %s, Port: %d\n", config.Server.IP, config.Server.Port)
  }
  ```

#### 4.4 接口

- 同 java 一样，可以把一堆有共性的方法定义在里面，控制结构体实现哪些方法
- 接口基础用法

  ```go
  type humanInterface interface {
    eat() string
    play() string
  }

  type man struct {
    name string
  }

  // 给结构体添加了和接口一样的方法，只要完全实现接口中的方式，默认这就实现接口（ 隐式 ）
  func (p man) eat() string {
    return "eat banana"
  }
  func (p man) play() string {
    return "play game"
  }

  // 把结构体赋值给接口来实现它，接口实例 = new(类型)，如果只实现了接口中的部分方法，则会报错
  var human humanInterface
  human = new(man)
  fmt.Println(human.eat())
  fmt.Println(human.play())

  // 多态用法
  func humanDoWhat(p humanInterface) {
    fmt.Println(p.eat())
    fmt.Println(p.play())
  }

  w := woman{"lisa"}
  m := man{"coding3min"}
  humanDoWhat(w)
  humanDoWhat(m)
  ```

## 5. 异常处理

- 在 go 语言里是没有 try catch 的概念的，因为 try catch 会消耗更多资源，而且不管从 try 里面哪个地方跳出来，都是对代码正常结构的一种破坏
- go 语言的设计思想中主张
  - 如果一个函数可能出现异常，那么应该把异常作为返回值，没有异常就返回 nil
  - 每次调用可能出现异常的函数时，都应该主动进行检查，并做出反应，这种 if 语句术语叫卫述语句
- 异常处理基础用法

  ```go
  func divisionInt(a, b int) (int, error) {
    if b == 0 {
      return -1, errors.New("除数不能为0")
    }

    return a / b, nil
  }

  a, b := 4, 0
  res, err := divisionInt(a, b)
  if err != nil {
    fmt.Println(err.Error())
    return
  }
  ```

- errors 实现了一个叫 error 的接口，这个接口里就一个 Error 方法且返回一个 string，可以自定义结构体实现这个方法，同时可以扩充自定义 error 的结构体字段
