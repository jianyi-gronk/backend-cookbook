## 1. 并发特性

- 以前写并发的程序一般是用多线程来实现，自己维护一个线程池，在恰当的时候创建、销毁、分配资源。而 go 在并发方面为我们提供了一个语言级别的支持，用 goroutine 和 channel 相互配合
- goroutine 也就是 go 协程，协程同线程的关系，有些类似于线程同进程的关系，Go 程序运行时会自动调度和管理，系统能智能地将 goroutine 中的任务合理地分配给 CPU，让这些任务尽量并发运作

#### 1.1 goroutine 和线程对比

- 从实现对比
  - 从资源上讲，线程的栈内存大小一般是固定为 2MB，虽然这个数值可以设置，但是太大了浪费，太小了容易不够用，而 goroutine 栈内存是可变的，初始一般为 2KB，随着需求可以扩大达到 1GB，所以 goroutine 十分的轻量级
  - 从调度上讲，线程的切换需要 CPU 寄存器 和 内存 的数据交换，从而切换不同的线程上下文，而 goroutine 的调度则比较轻量级，由自身的调度器完成
- 从使用对比
  - 比线程更轻量级，可以创建十万、百万不用担心资源问题
  - 和线程不同，goroutine 没有唯一的 id，所以我们没办法专门针对某个协程进行操作
  - 和 channel 搭配使用，实现高并发，goroutine 之间传输数据更方便
  - 如果访问同一个数据块，要小心数据竞态问题、共享锁还是互斥锁的选择问题、并发操作的数据同步问题

#### 1.2 goroutine 用法

- 只需要在函数前加一个 go 关键字就可以，当该函数执行完毕时，这个新的 goroutine 也就结束了

  ```go
  func quickFun(){
    fmt.Println("maybe you can's see me!")
  }

  // Go 程序从 main 包的 main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine
  func main(){
    // 创建了一个 goroutine，它会和 main 主线程会同时运行
    go quickFun()
    // 也可以匿名函数
    go func() {
      fmt.Println("hello ")
      // 如果该函数具有返回值，那么返回值会被丢弃
      return false
    }()
    fmt.Println("hey")

    // main 运行结束会暴力终止所有协程，所以让它多等待 1 秒
    time.Sleep(time.Second)
  }
  ```

#### 1.3 并发等待

- 可以通过 sync.WaitGroup 让主线程等待 goroutine 执行完之后继续执行，具体步骤如下
  - 在父协程中创建一个 WaitGroup 实例，比如名称为：wg
  - 调用 wg.Add(n) ，其中 n 是等待的 goroutine 的数量
  - 在每个 goroutine 运行的函数中执行 defer wg.Done()
  - 调用 wg.Wait() 阻塞主逻辑
  - 直到所有 goroutine 执行完成
- 基础用法

  ```go
  func main() {
    var wg sync.WaitGroup
    wg.Add(2)
    go say2("hello", &wg)
    go say2("world", &wg)
    wg.Wait()
    fmt.Println("over!")
  }

  func say2(s string, waitGroup *sync.WaitGroup) {
    defer waitGroup.Done()
    fmt.Println(s)
  }
  ```

## 2. channel

- go 中理念是不要通过共享内存来通信，而应通过通信来共享内存
- channel 是 goroutine 之间互相通讯的东西，goroutine 之间用来发消息和接收消息。其实，就是在做 goroutine 之间的内存共享

#### 2.1 声明和赋值

- channel 是类型相关的，也就是说一个 channel 只能传递一种类型的值，这个类型需要在 channel 声明时指定
- channel 是一个引用类型，初始值为 nil，对于值为 nil 的通道，不论具体是什么类型，它们所属的接收和发送操作都会永久处于阻塞状态
- channel 有大小，如果没有声明，则默认是无缓冲的（ 此时大小是 0，不是 1 ）也就是说必须有其他 goroutine 接收，不然就会阻塞在那，可在 make 的第二个参数里指定 channel 缓冲大小
- 基础用法

  ```go
  var a chan int
  a = make(chan int)

  b := make(chan float64)

  c := make(chan int, 100)
  ```

#### 2.2 使用

- 一个协程内使用 channel 同时发送和接收

  ```go
  func pendingForever() {
    a := make(chan int)
    a <- 1   // 将数据写入 channel
    z := <-a // 从 channel 中读取数据
    fmt.Println(z)
  }

  // 有且只有一个协程时，无缓冲的通道，会发生死锁，因为先发送会阻塞在发送，先接收会阻塞在接收处
  ```

- 不同协程内发送和接收

  ```go
  func standard() {
    // 如上声明了一个有缓冲的通道，在缓冲大小允许的范围内不需要阻塞等待接收
    chanInt := make(chan int, 10)
    go func() {
      // 需要使用 defer 在发送端关闭通道（ 因为接收端不知道数据是否传完 ），防止程序异常时未正常关闭
      defer close(chanInt)
      var produceData = []int{1, 2, 3}
      // 实际使用中数据往往是连续不断发送的
      for _, v := range produceData {
        chanInt <- v
      }
      // 因为有缓冲，不阻塞，所以发送端发送完毕后主动关闭通道
      // 虽然通道已经关闭，接收端依然可以接收，接收完自行结束
    }()
    // range chan 可以不断接收数据，直到通道关闭，假如不关闭会永远阻塞，直接报死锁错误
    for v, ok := range chanInt {
      fmt.Println(v)
      // 第二个返回值是 bool 值，可判断 channel 是否关闭
      if (!ok) {
        fmt.Println("chanInt is closed")
      }
    }
  }

  /*
    注意：
      同一个通道只能关闭一次，重复关闭会panic
      如果传入nil,如 close(nil) 会 panic
   */
  ```

- 特殊情况读取 channel 值

  ```go
  func goroutineLeak() {
    chanInt := make(chan int)
    defer close(chanInt)
    go func() {
      for {
        // 在 channel 关闭后，读取的是 int 默认值 0
        res := <-chanInt
        fmt.Println(res)
      }
    }()
    chanInt <- 1
    chanInt <- 1
  }

  func goroutineLeakNoClosed() {
    chanInt := make(chan int)
    go func() {
      for {
        // 在 channel 关闭前，会一直阻塞接受处，不会拿到默认值
        res := <-chanInt
        fmt.Println(res)
      }
    }()
  }
  ```

- 可以用 channel 阻塞主线程
  ```go
  func main() {
    done := make(chan struct{})
    defer close(done)
    go func() {
      ...
      done <- struct{}{}
    }()
    // 阻塞主线程结束，直到向 done 传入数据
    <-done
  }
  ```

#### 2.3 死锁场景

- 在并发中出现通道死锁只有两种情况：
  - 数据要发送，但是没有人接收
  - 数据要接收，但是没有人发送

#### 2.4 goroutine 泄漏

- goroutine 终止的场景有三个，当都没有满足时，goroutine 就会一直运行下去
  - 当一个 goroutine 完成了它的工作
  - 由于发生了没有处理的错误
  - 有其他的协程告诉它终止
- goroutine 会导致内存、cpu 占用越来越多

## 3. 并发安全

- 并发安全，就是多个并发体在同一段时间内访问同一个共享数据，共享数据能被正确处理。最好只要涉及到共享变量统统使用 channel，因为 channel 源码中使用了互斥锁，所以它是并发安全的
- 并发安全问题常见于控制商品减库存，控制余额增减等情况，解决办法有
  - 互斥锁：让访问某个临界区的时候，只有一个 goroutine 可以访问
  - 原子操作：让某些操作变成原子的

#### 3.1 不安全样例

- 比如扩容操作的话可能存在同时申请并赋值的情况，导致漏掉某次扩容增加的数据

  ```go
  var s []int

  func appendValue(i int) {
    s = append(s, i)
  }

  func main() {
    // 10000 个协程同时添加切片
    for i := 0; i < 10000; i++ {
      go appendValue(i)
    }
    time.Sleep(2)
    fmt.Println(len(s)) // 结果小余 10000
  }
  ```

#### 3.2 互斥锁

- 对共享变量 s 的写入操作加互斥锁，保证同一时刻只有一个 goroutine 修改内容

  ```go
  var s []int
  var lock sync.Mutex

  appendValueSafe := func(i int) {
    lock.Lock()
    s = append(s, i)
    lock.Unlock()
  }

  // 10000 个协程同时添加切片
  for i := 0; i < 10000; i++ {
    go appendValueSafe(i)
  }
  time.Sleep(2)
  fmt.Println(len(s))
  ```

#### 3.3 读写锁

- 并发读不互斥可以同时，在一个写锁获取时，其他所有锁都等待，即读读不互斥、读写互斥、写写互斥

  ```go
  rwlock sync.RWMutex

  // 读锁
  rwlock.RLock()
  rwlock.RUnlock()

  // 写锁
  rwlock.Lock()
  rwlock.Unlock()
  ```

#### 3.4 原子操作

- 注意，基本类型并发也不是安全的

  ```go
  func main() {
    x := 0
    // 10000 个协程同时添加切片
    for i := 0; i < 10000; i++ {
      go func() {
        x++
      }
    }
    time.Sleep(2)
    fmt.Println(x) // 结果小余 10000
  }
  ```

- 因为此处的 x++ 操作并不是原子的，都是先取当前值，加 1，再赋值，会出现覆盖的情况
