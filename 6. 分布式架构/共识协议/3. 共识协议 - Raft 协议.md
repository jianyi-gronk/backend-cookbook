## 1. 节点状态

- Leader（ 领导者 ）：集群中只有一个，负责处理客户端写请求、管理日志复制和不断地发送心跳消息通知其他节点
- Candidate（ 参选者 ）：候选人向其他节点发送 RequestVote RPC 消息通知其他节点投票，如果赢得大多数选票则晋升为 Leader
- Follower（ 追随者 ）：接受和处理 Leader 的消息；当与 Leader 心跳超时时就推荐自己当候选人

## 2. Leader 选举

- 一开始，所有节点都是 Follower 状态，我们认为这些处于 Follower 状态的节点叫 Follower（ 追随者 ），如下图所示：
  ![image](https://i-blog.csdnimg.cn/blog_migrate/08a5e034160ca47542eb8cd51acb78ba.png)
- 当所有的 Follower 都无法感知到 leader 存在时，这是他们会变成一个 candidate（ 参选者 ），candidate 可以向其他节点发起投票，其他节点反馈投票结果，即是同意还是驳回，如果此次投票获得了大部分节点的同意，则 candidate 成为了新的 leader，这个过程就叫 Leader Election（ Leader 选举 ），如下图所示
  ![image](https://i-blog.csdnimg.cn/blog_migrate/e647b8834330d814a10df085fbb8c3af.png)
- Leader 选出来之后，任何改变都需要通过 Leader 来传达，做法是：
  - 每一次变更都会作为一个 entry 加入到 Leader 节点日志中，这时 entry 的状态是未提交状态（ uncommitted ），所以这并不会改变节点的当前值
  - 为了能够提交 entry，首先需要做的是将 entry 复制到所有 Follower 节点，然后 leader 开始等待直到大部分节点都写入成功了 entry 为止
  - 最后 leader 提交 entry，节点值发生变更，并通知所有 Follower entry is committed，最后所有节点都达到了一致的状态
- 上述过程叫做日志复制，整个过程如下：
  ![image](https://i-blog.csdnimg.cn/blog_migrate/f867273ba837d83b3b490cc8334e46c0.png)

#### 2.1 超时场景

- Raft 协议种存在两个超时设置用来控制选举过程
- 第一个超时设置是选举超时（ election timeout ），选举超时用来设置一个节点从 Follower 变成一个 candidate 所需要等待的时间，这个等待时间控制在 150ms 到 300ms 之间，这个等待时间是随机的，随机是为了尽量避免产生多个 candidate，给选主过程制造麻烦。candidate 产生如下图所示
  ![image](https://i-blog.csdnimg.cn/blog_migrate/42c8cb8960cf5a0850835fd7e9d98df7.png)
  - 当 3 个节点都设置 election timeout 时，节点 a 跑得比其他其他节点快些成为第一个 candidate，并开始发起第一轮选举。节点首先给自己先投一票，然后向其他节点发送 Request Vote 消息
  - 如果其他节点收到消息后发现并没有进行过此次投票，则他就会为 candidate 进行一次投票并重置 election timeout，一旦 candidate 获得了大多数选票（ “大多数” 可以保证每一轮选举只有一个 candidate 会获胜 ），则他就会变成 leader，如下图所示：
    ![image](https://i-blog.csdnimg.cn/blog_migrate/7c3fe55ef6de54caba0401a059f7ffac.png)
- 节点 a 成为 leader 后，会间隔指定时间发送 Append Entries 消息给他的 Follower，间隔时间是由心跳超时控制的（ heartbeat timeout，即第二种超时类型 ），Follower 收到消息后会重置等待时间，这样就能阻止 Follower 成为 candidate。心跳检测过程如下：
  ![image](https://i-blog.csdnimg.cn/blog_migrate/789466d7f004210440dbbc2732b32246.png)
  - 这个过程会一直持续下去直到一个 Follower 停止接收 heatbeats，并且成为 candidate 为止

#### 2.2 多参选者场景

- 上文我们提到在 Follower 转变成 candidate 过程中会随机分配一个 election timeout 给每个节点，这样做可以尽量避免产生多个 candidate，但并不能保证一定不出现 2 个 candidate 的情况。当出现了 2 个节点成为 candidate，此时需要如何确保选主顺畅呢？
- 假设节点 a、b、c 同时成为 candidate，并且各自发起了新一轮的选举，选举过程如下
  ![image](https://i-blog.csdnimg.cn/blog_migrate/8bf58528eabfc63b621b12c6ba06a19a.png)
  - 从图中我们可以看到，a 节点获取了 2 张选票，比其他 candidate 多，但很可惜，由于仍没有满足大多数原则（ vote count 需 > 4/2 ），此论选举失败，在休眠一段时间后，节点会再次重试从 Follower -> candidate -> leader 的选举过程，直到产生 Leader 为止

## 3. 日志复制

- 一旦我们选出了主，那么主就有责任将系统发生的所有变更复制到所有节点。主会使用和心跳相同的 Append Entries 消息用来复制。首先，客户端发起写入值变更，主会在下一个心跳到来时发送变更日志到 Follower，当主收到大多数 Follower 确认后，提交变更 entry，然后向客户端返回成功
- 比如 set a = 5：
  ![image](https://i-blog.csdnimg.cn/blog_migrate/3dccf9f1286270a1c67747456deeb954.png)

## 4. 网络分区

- Raft 牛逼之处在于网络分区（ 比如节点部署在不同机房，不同网段 ）下仍然可以确保节点数据一致
- 假设有 5 个节点（ a，b，c，d，e ）组成的网络，a，b 位于一个机房，c，d，e 位于另一个机房，此时的 leader 是 a 节点。由于网络故障造成 2 个机房节点通信失败，位于一个机房的 c，d，e 发现 leader 心跳不再了，则发起了选主过程，假如节点 c 获得了多数选票成为了新的 Leader，此时 5 个节点同时存在 2 Leader（ 老 leader a 节点 和 新 leader c 节点 ），如图所示：
  ![image](https://i-blog.csdnimg.cn/blog_migrate/45810f14ea269f0a036cc204a4e878e1.png)
- 接着，我们新增一个客户端节点，该节点尝试修改 a 的值为 3，由于节点 a 无法与 c，d，e 通信，在做日志复制时无法得到大多数的应答，那么这条 entry 将一直是 uncommited 状态。而另个客户端尝试修改节点 c 的值为 8，由于他可以获得大多数的应答，所以这次操作 entry 可以正常提交
  ![image](https://i-blog.csdnimg.cn/blog_migrate/448a6eaa7d7f972531b156f76ac59962.png)
- 现在网络故障恢复了，节点 a 和 b 都会广播心跳并携带，此时节点 b 发现了更高的 election term，则自动将自己降级为 follower，且 a 和 b 同时需要回滚他们为提交的 entries，并且匹配 new leader 的日志，如下图所示：
  ![image](https://i-blog.csdnimg.cn/blog_migrate/eaa438a7dbdf1d33ea6afad3583843fc.png)
