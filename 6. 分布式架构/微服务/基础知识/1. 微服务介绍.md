## 1. 微服务

#### 1.1 基础介绍

- 是一种基于分布式思想的软件开发架构，它将一个大型应用程序拆分为多个独立的、可独立部署的小型服务
- 这些小型服务具有自己的业务逻辑和数据存储，每个服务专注于解决特定的业务问题，具有良好的模块化和独立性
- 微服务架构的实施复杂性较高，需要考虑 **服务拆分**、**服务通信**、**分布式一致性** 等问题，还有各种 **服务治理** 操作

#### 1.2 相比于单体架构的优缺点

- 优点：
  - 模块化和解耦：
    - 微服务架构将应用程序划分为多个独立的服务，每个服务负责一个特定的功能
    - 这种模块化和解耦有助于提高代码可维护性，降低了不同团队之间的协作成本
  - 可扩展性：
    - 在微服务架构中，每个服务可以根据需求独立扩展
    - 这意味着可以根据业务需求灵活地调整系统资源，提高系统的可扩展性
  - 独立部署和快速迭代：
    - 微服务允许每个服务独立部署，这使得开发团队可以更快地迭代和发布新功能或修复错误，不需要重新部署整个应用程序
  - 技术栈灵活性：
    - 由于每个微服务都是独立的，可以根据具体需求选择最适合的技术栈，而不受整个应用程序的限制
  - 容错性：
    - 在微服务架构中，故障可以被隔离在单个服务上，而不会影响整个系统。这有助于提高系统的可用性和稳定性
- 缺点：
  - 分布式系统的复杂性：
    - 微服务架构需要解决分布式系统的诸多挑战，如数据一致性、网络延迟、服务调用链路的追踪等。这可能导致系统的整体复杂性上升
  - 数据一致性和事务管理：
    - 在微服务架构中，数据通常分散在各个服务中，需要解决跨服务的数据一致性和事务管理问题。这可能需要引入分布式事务解决方案，如两阶段提交（ 2PC ）或者基于消息的最终一致性事务
  - 部署和运维复杂性：
    - 由于微服务架构涉及多个独立的服务，部署和运维的复杂性可能会增加。尽管容器化技术（ 如 Docker ）和编排工具（ 如 Kubernetes ）有助于简化部署和运维，但仍然需要相应的技能和知识来管理这些工具
  - 测试复杂性：
    - 微服务架构的测试可能比单体架构更复杂，因为需要考虑到服务间的交互和集成。此外，由于服务的独立部署，可能需要更多的端到端测试来确保系统的稳定性
  - 通信性能开销：
    - 微服务之间通过网络进行通信，相较于单体架构内部的函数调用，网络通信会引入额外的延迟和性能开销

## 2. 服务拆分

#### 2.1 遵循原则

- 服务粒度：
  - 在划分服务时，要权衡服务的粒度，合适的粒度可以根据业务需求和团队经验来确定
  - 过于粗粒度的服务可能导致功能重叠和耦合，过于细粒度的服务可能导致管理和通信成本增加
- 高内聚、低耦合：
  - 服务之间应保持低耦合，即尽量减少服务之间的依赖关系
  - 同时，服务内部应具有高内聚性，即服务内部的组件和功能应紧密相关
- 单一职责原则（Single Responsibility Principle，简称 SRP）：
  - 每个服务应遵循单一职责原则，即一个服务只负责一个功能，这能减少服务间的耦合
- 重用和解耦：
  - 尽量将可复用和通用的功能抽象为单独的服务，例如 认证、日志处理 等
- 服务自治性：
  - 每个服务应具备一定程度的自治性，能够独立地进行开发、部署和运维
- 可扩展性和可维护性：
  - 在进行服务划分时，要考虑服务的可扩展性和可维护性
  - 例如考虑业务的变化和发展。随着业务的演进，服务的边界和职责可能会发生变化

#### 2.2 划分方法

- 领域驱动设计（ Domain-Driven Design，简称 DDD ）：
  - 领域驱动设计是一种面向业务领域的软件开发方法，将系统按照业务功能和领域进行划分
  - 在进行微服务划分时，可以遵循 DDD 的原则，将系统划分为多个限界上下文（ Bounded Context ），每个上下文对应一个微服务
  - 这样可以保证每个服务负责一个独立的业务功能，易于理解和维护
- 事件风暴（ Event Storming ）：
  - 事件风暴是一种协作式的建模方法，通过识别业务事件、命令和聚合来发现业务领域的边界
  - 在进行服务划分时，可以采用事件风暴方法，识别出业务流程中的关键事件和实体，以及它们之间的关系。这有助于找出合适的服务边界，实现高内聚、低耦合的服务架构
- 垂直划分：
  - 垂直划分是指按照业务功能进行服务划分
  - 例如，一个电商系统可以划分为订单服务、商品服务、用户服务等
  - 这样的划分方法有助于减少服务间的耦合，提高服务的独立性和可维护性
- 水平划分：
  - 水平划分是指将通用功能抽象为单独的服务，如认证服务、日志处理服务等
  - 需要注意的是，在进行水平划分时，要确保通用功能的独立性，避免过度依赖其他服务
  - 这样可以提高系统的解耦程度和复用率
- 团队和组织结构：
  - 根据团队的组织结构、沟通方式和技能水平来划分微服务
  - 康威定律（ Conway's Law ）指出，软件系统的设计和组织结构是相互影响的，因此在进行服务划分时，可以考虑团队的组织结构

#### 2.3 领域驱动设计（ DDD ）—— 关键概念和规则

- 限界上下文（ Bounded Context ）：
  - 限界上下文是指在特定场景下，一组有意义的领域模型和业务功能的边界
  - 在 DDD 中，将系统划分为多个限界上下文，每个上下文对应一个独立的业务功能或领域
  - 限界上下文之间可以通过上下文映射（ Context Mapping ）来定义它们之间的关系，例如合作、共享内核、客户/供应商等
- 实体（ Entity ）：
  - 实体是具有唯一标识（ 如 ID ）的领域对象，它们具有连续性和变化性
  - 实体通常对应于业务领域中的核心概念，如用户、订单、产品等。
- 值对象（ Value Object ）：
  - 值对象是不具有唯一标识的领域对象，它们仅通过属性值来定义其等价关系
  - 值对象通常用于表示领域概念中的属性或度量，如地址、金额、日期等
- 聚合（ Aggregate ）：
  - 聚合是一组相关的实体和值对象的集合，它们共同组成一个完整的业务概念
  - 聚合定义了领域模型的边界和一致性保证，同时提供一个根实体（ Aggregate Root ）作为访问和操作聚合内部对象的入口点
- 领域事件（ Domain Event ）：
  - 领域事件是表示业务领域中发生的重要事件的对象，它们通常包含事件的名称、发生时间、相关数据等信息
  - 领域事件可以用于解耦领域模型之间的依赖关系，通过事件驱动架构（ Event-Driven Architecture ）来实现异步、分布式的系统
- 领域服务（ Domain Service ）：
  - 领域服务是用于实现跨多个聚合或实体的业务逻辑的操作
  - 领域服务通常对应于业务领域中的一些动作或过程，如支付、发货、审批等
- 应用服务（ Application Service ）：
  - 应用服务是提供对外接口（ 如 API、UI ）的操作，负责协调领域服务、实体和聚合之间的交互，以实现具体的业务功能
  - 应用服务通常不包含业务逻辑，而是将业务逻辑委托给领域层
- 基础设施层（ Infrastructure Layer ）：
  - 基础设施层是用于实现技术细节和支持功能的组件，如数据库、消息队列、缓存等。基础设施层为领域模型和应用服务提供通用的技术支持，以实现持久化、通信等功能

#### 2.4 领域驱动设计（ DDD ）—— 实际业务场景举例

- 假设为一个在线书店开发一个软件系统，在这个业务领域中，有许多核心概念，如书籍、订单、用户、评论等
- 识别限界上下文（ Bounded Context ）： 首先，可以将在线书店系统划分为多个限界上下文，如
  - 用户管理（User Management）
  - 商品目录（Product Catalog）
  - 订单处理（Order Processing）
  - 评论管理（Review Management）
- 定义实体（ Entity ）和值对象（ Value Object ）： 在每个限界上下文中，可以识别出实体和值对象
  - 用户管理：实体 - 用户（User），值对象 - 地址（Address）
  - 商品目录：实体 - 书籍（Book），值对象 - 作者（Author）、价格（Price）
  - 订单处理：实体 - 订单（Order）、订单项（Order Item），值对象 - 金额（Amount）
  - 评论管理：实体 - 评论（Review），值对象 - 评分（Rating）
- 设计聚合（ Aggregate ）： 对于每个限界上下文，可以设计聚合来组织实体和值对象
  - 用户管理：用户聚合（User Aggregate）包括用户实体和地址值对象
  - 商品目录：书籍聚合（Book Aggregate）包括书籍实体、作者值对象和价格值对象
  - 订单处理：订单聚合（Order Aggregate）包括订单实体、订单项实体和金额值对象
  - 评论管理：评论聚合（Review Aggregate）包括评论实体和评分值对象
- 领域服务（ Domain Service ）： 根据业务需求，可以定义领域服务来实现跨聚合或实体的业务逻辑
  - 用户管理：注册、登录、修改个人信息等
  - 商品目录：搜索书籍、查看书籍详情等
  - 订单处理：创建订单、支付订单、取消订单等
  - 评论管理：添加评论、查看评论等
- 应用服务（ Application Service ）： 对于每个限界上下文，可以定义应用服务来协调领域服务、实体和聚合之间的交互
  - 用户管理：提供用户注册、登录、修改个人信息等 API 接口
  - 商品目录：提供搜索书籍、查看书籍详情等 API 接口
  - 订单处理：提供创建订单、支付订单、取消订单等 API 接口
  - 评论管理：提供添加评论、查看评论等 API 接口

## 3. 服务通信

#### 3.1 通信方式

- 同步通信：
  - 微服务之间通过请求-响应的方式进行通信，例如 RESTful API 和 RPC
  - 通信过程中，请求方需要等待响应方的返回结果，因此可靠性较高，但可能会出现请求排队、线程阻塞等问题，从而影响系统的响应速度和并发性能
- 异步通信：
  - 微服务之间通过消息队列进行异步通信，例如 Kafka 和 RabbitMQ
  - 通信过程中，发送方向消息队列发送消息，接收方从消息队列中消费消息，消息传输以异步的方式进行，不需要等待接收方的响应
  - 由于解耦性高，消息队列还可以支持发布-订阅模式，消息得以广播到多个服务中，助于构建高可伸缩的系统
  - 不过异步通信也可能导致延迟较高，以及可靠性和容错性较差等问题
- 事件驱动架构（EDA）：
  - 微服务之间通过发布-订阅模式进行通信，例如 Apache Kafka 和 AWS SNS/SQS
  - 通信过程中，发布者发布事件，订阅者订阅事件，事件传递以异步的方式进行
  - 通过 EDA，不同服务之间可以实现松耦合通信，提高系统的可伸缩性和弹性
  - 但需要谨慎处理网络分区等极端情况，以避免出现一致性等问题

#### 3.2 三者区别

- 这三种通信方式各有优缺点，可以根据具体业务需求和可用技术进行选择和结合。例如，同步通信适用于低延迟、高可靠的交互，异步通信适用于大数据处理和高性能扩展，EDA 适用于事件驱动、松耦合的场景。同时，在实际应用中，也需要注意通信的负载和响应速度等问题，以满足业务的性能和稳定性要求

#### 3.3 三者使用场景

- 低延迟场景：
  - 若要求实时高效的数据交换，需要尽可能缩小 请求 到 响应 的时间窗口，此时选择同步通信更为合适
- 高吞吐量场景：
  - 若要求高效的消息传输，需要支持高并发和大数据量传输，且强调服务之间的松耦合性，则选择消息队列（ 异步通信 ）更为合适
- 高可靠、数据一致性场景：
  - 若需要确保每个操作和消息都被发送且正确接收到，即保障系统的基本可靠性和数据一致性，则选择同步通信更为合适
- 多个服务之间的通信：
  - 若有多个服务需要共享同一份数据或事件，或者多个服务需要响应同一份消息，则选择消息队列（ 异步通信 ）或者事件驱动（ EDA ）更为合适
- 对接外部系统：
  - 若需要对接外部数据源、第三方系统或者不同语言共存的服务，则需基于标准协议和规范来进行同步通信，例如 RESTful API 和 gRPC 等
