- 软件研发中任何一项技术、方法、架构都不可能是银弹

## 1. 目的

- **微服务最主要的目的是对系统进行有效的拆分，实现物理层面的隔离，微服务的核心价值就是拆分之后的系统能够让局部的单个服务有可能实现敏捷地卸载、部署、开发、升级，局部的持续更迭**
- 反对以 “获得更好的性能” 为主要目的，将系统重构为微服务架构的，性能有可能会作为辅助性的理由，但仅仅为了性能而选择分布式的话，那应该是 40 年前 “原始分布式时代” 所追求的目标
- 现代的单体系统同样会采用可扩缩的设计，同样能够集群部署，更重要的是云计算数据中心的处理能力几乎可以认为是无限的，那能够通过扩展硬件的手段解决问题就尽量别使用复杂的软件方法，因为硬件的成本能够持续稳定地下降，而软件开发的成本则不可能
- 而且，性能也不会因为采用了微服务架构而凭空提升。把系统拆成多个微服务，一旦在某个关键地方依然卡住了业务流程，其整体的结果往往还不如单体，没有清晰的职责划分，导致扩展性失效，多加机器往往还不如单机。前面这句话将性能替换为代码质量、生产力等词语往往也同样适用
- 软件系统选择微服务架构，通常比较常见的、合理的驱动力来自研发团队的外部、内部两方面

#### 1.1 外部因素

- 当意识到没有什么技术能够包打天下
  - 举个具体例子，某个系统选用了处于 Tiobe 排行榜榜首多年的 Java 语言来开发，也会遇到很多想做但 Java 却不擅长的事情
  - 譬如想去做人工智能，进行深度学习训练，发现大量的库和开源代码都离不开 Python；想要引入分布式协调工具时，发现近几年 ZooKeeper 已经有被后起之秀 Golang 的 Etcd 蚕食替代的趋势；想要做集中式缓存，发现无可争议的首选是 ANSI C 编写的 Redis，等等
  - 很多时候为异构能力进行的分布式部署，并不是你想或者不想的问题，而是没有选择、无可避免的
- 当个人能力因素成为系统发展的明显制约
  - 对于北上广深的信息技术企业这个问题可能不会成为主要矛盾，在其他地区，不少软件公司即使有钱也很难招到大量的靠谱的高端开发者。此时，无论是引入外包团队，抑或是让少量技术专家带着大量普通水平的开发者去共同完成一个大型系统，微服务都是一个更有潜力的选择
  - 在单体架构下，没有什么有效阻断错误传播的手段，系统中 “整体” 与 “部分” 的关系没有物理的划分，系统质量只能靠研发与项目管理措施来尽可能地保障，少量的技术专家很难阻止大量螺丝钉式的程序员或者不熟悉原有技术架构的外包人员在某个不起眼的地方犯错并产生全局性的影响，不容易做出整体可靠的大型系统
  - 这时微服务可以作为专家掌控架构约束力的技术手段，由高水平的开发、运维人员去保证关键的技术和业务服务靠谱，其他大量外围的功能即使不靠谱，甚至默认它们必定不靠谱，也能保证系统整体的稳定和局部的容错、自愈与快速迭代
- 当遇到来自外部商业层面对内部技术层面提出的要求
  - 对于那些以 “自产自销” 为主的互联网公司来说这一点体验不明显，但对于很多为企业提供信息服务的软件公司来说，甲方的要求往往才是具决定性的推动力
  - 技术、需求上困难也许能变通克服，但当微服务架构变成大型系统先进性的背书时，甲方的招投标文件技术规范明文要求系统必须支持微服务架构、支持分布式部署，那就没有多少讨价还价的余地
- 等等

#### 1.2 内部因素

- 变化发展特别快的创新业务系统往往会自主地向微服务架构靠近
  - 需求喊着 “要试错！要创新！要拥抱变化！”，开发喊着 “资源永远不够！活干不完！”，运维喊着 “你见过凌晨四点的洛杉矶吗！”，对于那种频繁更新的系统，如果团队本身能力能够支撑在合理的代价下让功能有快速迭代的可能，让代码能避免在类库层面的直接依赖而导致纠缠不清，让系统有更好的可观测性和回弹性（自愈能力），需求、开发、运维肯定都是很乐意接受微服务的，毕竟此时大家的利益一致，微服务的实施也会水到渠成。
- 大规模的、业务复杂的、历史包袱沉重的系统也可能主动向微服务架构靠近
  - 这类系统最后的结局不外乎三种
  - 第一种是日渐臃肿，客户忍了，系统持续维持着，直到谁也替代不了却又谁也维护不了远古代码
  - 第二种是日渐臃肿，客户忍不了了，痛下决心，宁愿付出一段时间内业务双轨运行，忍受在新、旧系统上重复操作，期间业务发生震荡甚至短暂停顿的代价，也要将整套旧系统彻底淘汰掉
  - 第三种是日渐臃肿，客户忍不了，系统也很难淘汰。此时迫于外部压力，微服务会作为一种能够将系统部分地拆除、修改、更新、替换的技术方案被严肃地论证，若在重构阶段有足够靠谱的技术人员参与，该大型系统的应用代码和数据库都逐渐分离独立，直至孵化出一个个可替换可重生的微服务，微服务的先驱 Netflix 曾在多次演讲中介绍说自己公司属于第三种的成功案例
- 等等

## 2. 前提

- **系统的架构趋同于组织的沟通结构**。微服务的前提条件首要还是该先解决非技术方面的问题，准确地说是人的问题。分布式不是一项纯粹的技术性工作，如果不能满足以下条件，就应该尽量避免采用微服务

#### 2.1 前提一

- **决策者与执行者都能意识到康威定律在软件设计中的关键作用**
- 康威定律尝试使用社会学的方法去解释软件研发中的问题，其核心观点是 “沟通决定设计”
  - 如果技术层面紧密联系在一起的特性，在组织层面上强行分离开来，那结果会是沟通成本的上升，因为会产生大量的跨组织的沟通
  - 如果技术层面本身没什么联系的特性，在组织层面上强行安放在一块，那结果会是管理成本的上升，因为成员越多越不利于一致决策的形成
- 这些社会学、管理学的规律决定了假如产品和组织能够经受住市场竞争，长期发展的话，最终都会自发地调整成组织与产品互相匹配的状态。哪些特性在团队内部沟通，哪些特性需要跨团队的协作，将最终都会在产品中分别映射成与组织结构一致的应用内、外部的调用与依赖关系
- 尽管稍微有工作经验的员工和管理者只要稍微思考一下都能理解康威定律所描述的现象，但是为了推进软件架构的微服务化而配合地调整组织架构，通常不是一件容易的事情
- 架构不仅仅是个技术问题，更是一种社交活动，甚至还可能会涉及利益的重新分配
  - 譬如，产品在技术上的拆装重构相对容易，但为了做到组织与产品对齐，将某个组织的一部分权利、职能和人员拆分出来，该组织的领导愿不愿意？将两个团队合并成一个新的团队，总会有一个团队负责人要考虑该怎么安置？
  - 这些问题不仅需要执行者有良好的社交能力，还需要更上层的决策者充分理解架构演变同步调整组织结构的必要性，为微服务化打破局部的利益藩篱

#### 2.2 前提二

- **组织中具备一些对微服务有充分理解、有一定实践经验的技术专家**
- 作为一个普通的服务开发者，作为一个螺丝钉式的程序员，微服务架构是友善的。可是，微服务对架构者是满满的恶意，对架构能力要求已提升到史无前例的程度。即使对微服务最乐观的支持者也无法否认它在架构方面带来了额外的复杂性
- 对于普通开发者：
  - 对于开发业务逻辑的普通程序员，即使代码出现缺陷也可以被快速修复升级，甚至有可能在 Kubernetes 的帮助下自动回弹，哪怕不能自愈，最起码错误也会被系统自动地隔离，而不至于影响全局弄崩整个系统
  - 开发业务的普通程序员可以不去深究跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展这些系统性的问题，它们被隐藏于软件架构的最底层，被掩埋在基础设施之下
- 对于架构者：
  - 与此相对的另外一面，靠谱的软件架构应该要由深刻理解微服务的技术专家来设计建造，健壮的基础设施也离不开有经验的运维专家的持续运维，Kubernetes、Istio、Spring Cloud、Dubbo 等现成的开源工具能在此过程发挥很大的作用，但它们本身也具备不低的复杂性。如果整个团队中缺乏能够在微服务架构中撑起系统主干的技术和运维专家，强行进行微服务化并不会有任何好处，至少收益不足以抵消复杂性增加而导致的成本
  - 这些技术专家不需要很多（ 能多当然更好 ），但是一定必须有，如今在软件职场中阿里、腾讯等大厂出来的程序员受到追捧，除了本身企业带来的光环外，有大型系统浸染的经验，更有可能是技术专家也是其中主要原因之一
- 微服务对普通程序员友善的背后，预示着未来的信息技术行业很可能也会出现 “阶级分层” 的现象，由于更先进的软件架构已经允许更平庸的开发者也同样能写出可运行、可用于生产的软件产品，同时又对精英开发者提出更多、更复杂的技术要求，长此以往，在开发者群体中会出现比现在还要显著的马太效应
- 如果把整个软件业界这个看作一个巨大组织的话，它也应会符合康威定律，软件架构的趋势将导致开发者的分层，从如今所有开发者都普遍被认为是 “高智商人群” 的状态，转变为大部分工业化软件生产工人加上小部分软件设计专家的金字塔结构

#### 2.3 前提三

- **系统应具有以自治为目标的自动化与监控度量能力**
- 微服务是由大量松耦合服务互相协作构成的系统，将自动化与监控度量作为它的建设前提是顺理成章的
- 2014 年提出的微服务系统的三个技术前提都跟自动化与监控度量有关，分别是：
  - 环境预置（ Rapid Provisioning ）：即使不依赖云计算数据中心的支持，也有能力在短时间内迅速地启动好一台新的服务器
  - 基础监控（ Basic Monitoring ）：监控体系有能力迅速捕捉到系统中出现的技术问题（ 如异常、服务可用性变化 ）和业务问题（ 如订单交易量下降 ）
  - 快速部署（ Rapid Application Deployment ）：有能力通过全自动化的部署管道，将服务的变更迅速部署到测试或生产环境中
- 近年来，许多公司都构建起了 DevOps 文化，虚拟化与开发运维自动化有了长足发展，2014 年要专门强调的 “前提条件” 对今天的系统来说都算不上有什么困难。而更希望强调的重点是 “以自治为目标”，因为如果不是朝这个方向去努力的话，自动化最终会导向一个套娃式的悖论：
  - 即使所有运维都实现了自动化，同时有一个监控系统来随时恢复出现故障的服务，然而这个监控系统本身也需要被监控。如果启用另一个监控系统，同样这个监控系统需要被监控
  - 最终，不论自动化实现了多少层，顶层仍然必须是人，只有人能确保整体运维的连续性，所以永远也无法达到完全的自动化。而且，这些自动化与监控措施本身也会消耗资源，也会带来更高的复杂性
- 微服务自动化的最终目的是构筑一个可持续的生态系统。用一个具体的场景加以说明：
  ![image](https://github.com/user-attachments/assets/9367c089-c32e-4173-a628-f7a5cdda09ba)
  - 如果将微服务比作水族馆里养的鱼，为了维持鱼的生存，管理员需要不断向水族馆内添加各种自动化设施：人工照明、氧化剂、水过滤器、加热器，等等。这些设施最终仍然需要人花费精力去照料维护，本身就耗费了大量成本
  - 如果我们换一种思路，通过种植海洋植物以提供氧气、通过藻类过滤水质、通过放养螺类来清理鱼缸等等。这样的水族馆就不再是依靠人工维护才能存在的水族馆了，它变成了一个小型的湖泊或海洋，理想状态下，这里的鱼类可以不需要人的干预就能长期存活
- 以生态自治为目标的自动化，并不是指要达到如此高的自动化程度之后才能开始微服务，只要满足与系统规模和目标相匹配的自动化能力，建设微服务的不同时期，由不同程度的人力去参与运维完全是合情合理的
- 退一步说，即使在信息化水平最高的大型互联网企业中，完全的生态自治在当前技术水平下仍然是一个过于理想化、难以全面落地的目标，不过，只有朝着这个目标去发展自动化与监控度量，才能避免屠龙少年最终变成恶龙，避免自动化与度量监控反过来成为人与系统的负担

#### 2.4 前提四

- **复杂性已经成为制约生产力的主要矛盾**
- 对于小型系统，单体架构就是最好的架构。系统进行任何改造的根本动力都是 “这样做收益大于成本”，一般情况下，引入新技术在解决问题之前会就带来复杂度的提升，反而导致生产力下降。只有在业务已经发展到一定的程度，单体架构与微服务架构的生产力曲线已经到达交叉点，此时开始进行微服务化才是有收益的
  ![image](https://github.com/user-attachments/assets/b8d1b8b2-ec6b-42dc-ba3d-8cb7a9f9d90b)
- 关于复杂性、生产力的性价比问题并不难理解，然而现实中很多架构师却不得不在这上面主动去犯错。新项目在立项之初，往往都会定下令人心动的目标愿景，远景规划在战略上是有益的，可是多数技术决策都属于战术范畴，应该依据现实情况而不是远景规划去做决定。遗憾的是管理者、乃至技术架构师都不能真正地接受演进式设计，尤其不能接受一个具有良好设计的系统，应该是能够被报废的，潜意识中总会希望系统建设能够一步到位，至少是 “少走几步能到位”

## 3. 主动犯错

- 有的时候，虽然架构师知道微服务可能并不是相对最好的选择，但仍然会 “主动犯错”
- “主动犯错”，举个例子，试想你就是一名架构师
  - 项目立项中坚持要选择单体架构，此时你就要考虑到日后评审时，别的团队说他的产品采用了微服务，架构上比你的先进
  - 考虑到招聘人员时，程序员听见你这里连微服务都没用，觉得制约了自己的发展前景
  - 考虑到项目成功火爆了，几个月后你再提出进行微服务化，老板听了心里觉得你水平的确不行，之前采用单体是错误决定，导致现在要返工
  - 等等

## 4. 服务边界

- 当今软件业界，对 “识别微服务的边界” 其实已取得了较为一致的观点，也找到了指导具体实践的方法论，即领域驱动设计（ Domain-Driven Design，DDD ）
- 本文尽量规避了 DDD 中需要专门学习才能理解的概念，如 界限上下文、语境映射、通用语言、领域和子域、聚合、领域事件 等等。而会从业务之外的其他角度，从非功能性、研发效率等方面来探讨微服务的粒度与拆分
- 系统设计是一种创作，而不是应试，不可能每一位架构师设计的服务粒度全都相同，微服务的大小、边界不应该只有唯一正确的答案或绝对的标准，但是应该有个合理的范围，笔者称其为微服务粒度的上下界。我们可以分析如果微服务的粒度太小或者太大会出现哪些问题，从而得出服务上下界应该定在哪里

#### 4.1 服务下界

- 可能是受微服务名字中 “微” 的影响，不少人提倡过微服务越小越好，最好做到一个 REST Endpoint 就对应于一个微服务，这种极端的理解肯定是错误的，如果将微服务粒度定的过细，会受到以下几个方面的反噬
- 从性能角度看
  - 一次进程内的方法调用（ 仅计算调用，与方法具体内容无关 ），耗时在零（ 按方法完全内联的场景来计算 ）到数百个时钟周期（ 按最慢的虚方法调用无内联缓存要查虚表的场景来计算 ）之间
  - 一次跨服务的方法调用里，网络传输、参数序列化和结果反序列化都是不可避免的，耗时要达到毫秒级别，你可以算一下这两者有多少个数量级的差距
  - “透明的分布式通信” 是不存在的，因此，服务粒度大小必须考虑到消耗在网络上的时间与方法本身执行时间的比例，避免设计得的过于琐碎，客户端不得不多次调用服务才能完成一项业务操作，譬如，将字符串处理这样的功能设计为一个微服务便是不合适的，这点要求微服务从功能设计上看应该是完备的
- 从数据一致性角度看
  - 每个微服务都有自己独立的数据源，如果多个微服务要协同工作，我们可以采用很多办法来保证它们处理数据的最终一致性，但如果某些数据必须要求保证强一致性的话，那它们本身就应当聚合在同一个微服务中，而不是强行启用 XA 事务来实现
  - 因为参与协作的微服务越多，XA 事务的可用性就越差，这点要求微服务从数据一致性上看应该是内聚的
- 从服务可用性角度看
  - 服务之间是松散耦合的依赖关系，微服务架构中无法也不应该假设被调用的服务具有绝对的可用性，服务可能因为网络分区、软件重启升级、硬件故障等任何原因发生中断
  - 如果两个微服务都必须依赖对方可用才能正常工作，那就应当将其合并到同一个微服务中（ 注意这是 “彼此依赖对方才能工作”，单向的依赖是必定存在的 ），这条要求微服务从依赖关系上看应该是独立的
- 综合以上，可以得出第一个结论：**微服务粒度的下界是它至少应满足独立——能够独立发布、独立部署、独立运行与独立测试，内聚——强相关的功能与数据在同一个服务中处理，完备——一个服务包含至少一项业务实体与对应的完整操作**

#### 4.2 服务上届

- 如果微服务的粒度太大，会出现什么问题呢
  - 从技术角度讲，并不会有什么问题，每个能正常工作的单体系统都能满足独立、内聚、完备的要求，世界上又有那么多运行良好的单体系统。微服务的上界并非受限于技术，而是受限于人，更准确地说，受限于人与人之间的社交协作
- “为进度给项目增加人力，如同用水去为油锅灭火”。因为 软件项目中的沟通成本 = n × (n-1)/2，n 为参与项目的人数。为了更直观地理解这个式子，已经算好了一组数字：
  - 15 人参与的项目，沟通成本大约是 5 个人时的 10 倍，150 人参与的项目，沟通成本大约是 5 个人时的一千倍
  - 不妨回想一下自己在公司的工作体验，不可能有 150 人的团队而不划分出独立小组来管理的，除非这些人都从事流水线式的工作，协作时完全不需要沟通
- 有了以上铺垫，应该更能理解前面的许多人为何采用 “2 Pizza Team” 作为微服务团队规模的 “量词” 了，两个 Pizza 能喂饱的人数大概就是 6-12 人，符合软件开发中团队管理的理想规模。而软件的架构与组织的架构要保持一致，所以微服务的上界应该与 2 Pizza Team 能够开发的最大程序规模保持一致
- 2 Pizza Team 能开发多大规模的程序呢
  - 人员数量固定的前提下，这个不仅与开发者的能力水平相关，更是与研发模式和周期相关
  - 如果你的软件产品是瀑布开发，可能需要一个月、两个月迭代一次；如果采用 Scrum，可能会一周、两周完成一次冲刺；如果追求日构建、精益，甚至可能一天、两天就会集成构建出一个小版本，以上不同的研发方法，都会产生相应规模的上界
- 综合以上，可以得出了第二个结论：**微服务粒度的上界是一个 2 Pizza Team 能够在一个研发周期内完成的全部需求范围**

#### 4.3 根据实际情况

- 在上下界范围内，架构师会根据业务和团队的实际情况来灵活划定微服务的具体粒度
  - 譬如下界的完备性要求微服务至少包含一项完整的服务，不超过上界的前提下，这个微服务包含了两项、三项业务操作是否合理，那需要根据这些操作本身是否有合理的逻辑关系来具体讨论
  - 又譬如上界要求单个研发周期内能处理掉一个微服务的全部需求，不超过下界的前提下，一个周期就能完成分属于两个、三个微服务的全部需求时，是缩短研发周期更合理，还是允许这个周期内同时开发几个微服务，也可以根据实际情况具体讨论
