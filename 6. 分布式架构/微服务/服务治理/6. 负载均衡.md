## 1. 负载均衡

- 负载均衡目的是提高系统的性能、可伸缩性和可用性。可以避免单个服务实例被过载，使得系统能够更好地应对高并发和大流量情况
- 目前 Dubbo 内置了如下负载均衡算法如下，可通过调整配置项启用，默认为 Weighted Random
  ![image](https://github.com/user-attachments/assets/e0a2f12b-c3f2-47f5-bfeb-95c532b3e22e)
- 具体实现上，Dubbo 提供的是客户端负载均衡，即由 Consumer 通过负载均衡算法得出需要将请求提交到哪个 Provider 实例

## 2. 随机与轮询（ 真实框架不用 ）

#### 2.1 随机（ Random ）

- 随机算法随机地将请求发送给后端服务实例，没有固定的顺序和权重
- 相比于轮询算法，随机算法可以更加均匀地分配请求，适用于后端服务实例的规模不均衡的场景

#### 2.2 轮询（ Round ）

- 轮询是最简单的负载均衡算法，请求依次按顺序分发给不同的后端服务实例
- 当有新的请求到达时，负载均衡器按照某种顺序选择下一个可用实例，并将请求发送到该实例上
- 轮询的优点是简单、公平，适用于后端服务实例的规模相对均衡的场景
- 但很少有框架使用它，因为不会考虑到服务节点的实时状态、性能差异或负载情况，因此可能导致某些节点过载而其他节点闲置

#### 2.3 IP 哈希（ IP Hash ）

- IP 哈希算法根据请求的来源 IP 地址计算哈希值，然后将请求发送给对应的服务实例
- 使用 IP 哈希算法可以使得同一 IP 的请求始终被路由到同一个服务实例上，适用于需要保持会话状态的场景

## 3 加权随机（ Weighted Random ）

- 加权随机，按权重设置随机概率
- 调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重
- 但是存在存在慢的提供者累积请求的问题，比如第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上

## 4. 权重轮询（ Weighted Round ）

#### 4.1 基础介绍

- 权重轮询是在轮询算法的基础上增加了权重的概念，根据每个服务实例的权重来分配请求
- 权重可以根据服务实例的性能、配置和处理能力等因素来设置，高权重的实例会获得更多的请求
- 权重轮询的优点是可以根据实例的能力来动态调整负载分配
- 同样存在慢的提供者累积请求的问题，并且在加权轮询过程中，如果某节点权重过大，会存在某段时间内调用过于集中的问题

#### 4.2 具体实现

- 上述说的调用过于集中，例如 ABC 三节点有如下权重：{ A: 3, B: 2, C: 1 } 那么按照最原始的轮询算法，调用过程将变成：A A A B B C
- 因此 Dubbo 借鉴 Nginx 的平滑加权轮询算法，对此做了优化，调用过程如下图
  ![image](https://github.com/user-attachments/assets/db07fc28-0d2e-4f9e-8b9e-d5b7f045594d)
- 可以发现经过合计权重（3+2+1）轮次后，循环又回到了起点，整个过程中节点流量是平滑的，且哪怕在很短的时间周期内，概率都是按期望分布的

## 5. 最少活跃优先 + 加权随机（ LeastActive ）

- 加权最少活跃调用优先，活跃数越低，越优先调用。相同活跃数的进行加权随机
- 活跃数指调用前后计数差（ 指定提供者：请求发送数 - 响应返回数 ），表示指定提供者的任务堆积量，活跃数越低，代表该提供者处理能力越强
- 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大；相对的，处理能力越强的节点，处理更多的请求

## 6. 最短响应优先 + 加权随机（ Shortest Response ）

- 加权最短响应优先，在最近一个滑动窗口中，响应时间越短，越优先调用。相同响应时间的进行加权随机
- 使得响应时间越快的提供者，处理更多的请求
- 但是可能会造成流量过于集中于高性能节点的问题
- 这里的响应时间 = 某个提供者在窗口时间内的平均响应时间，窗口时间默认是 30s

## 7. 一致性哈希（ Consistent Hash ）

- 一致性 Hash，相同参数的请求总是发到同一提供者
- 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动
- 普通 Hash 算法的哈希表大小变化时，键 n 和 槽 m 需要重新映射，为了平均槽内键的数量 n / m，因为键和槽之间的映射是由模运算定义的
- 一致性 Hash 是特殊的 Hash 算法，将缓存键均匀分布在各个分片中，即使部分分片崩溃或不可用

## 8. P2C（ Power of Two Choice ）

- Power of Two Choice 算法简单但是经典，主要思路如下：
  - 对于每次调用，从可用的 provider 列表中做两次随机选择，选出两个节点 providerA 和 providerB
  - 比较 providerA 和 providerB 两个节点，选择其 “当前正在处理的连接数” 较小的那个节点

## 9. 自适应负载均衡（ Adaptive ）

- 依然是基于 P2C 算法
  - 从备选列表中做两次随机选择，得到 providerA 和 providerB
  - 比较 providerA 和 providerB 的 load 值，选择较小的那个
- load 对于备选后端机器 x 来说，若距离上次被调用的时间大于 2 \* timeout，则其 load 值为 0。否则按照公式计算
  ![image](https://github.com/user-attachments/assets/5337c05c-fbe5-4dd0-ac47-59b65cb3e568)
  - cpuLoad img
    - 该指标在 provider 端机器获得，并通过 invocation 的 attachment 传递给 consumer 端
  - rt
    - 为一次 rpc 调用所用的时间，单位为毫秒
  - timeout
    - 为本次 rpc 调用超时剩余的时间，单位为毫秒
  - weight
    - 是设置的服务权重
  - currentProviderTime
    - provider 端在计算 cpuLoad 时的时间，单位是毫秒
  - currentTime
    - 为最后一次计算 load 时的时间，初始化为 currentProviderTime，单位是毫秒
  - multiple
    ![image](https://github.com/user-attachments/assets/9b19acb4-a255-4a0b-8964-6e418a2aa548)
  - lastLatency
    ![image](https://github.com/user-attachments/assets/937c1cec-3514-4640-976e-ca0f79f0cd57)
  - beta
    - 平滑参数，默认为 0.5
  - ewma
    ![image](https://github.com/user-attachments/assets/7f629c75-8849-4c41-b175-f2fc15d457ca)
    - 为 lastLatency 的平滑值
  - inflight
    ![image](https://github.com/user-attachments/assets/2a0f025b-ea45-4064-8621-9f22478f3cac)
    - 为 consumer 端还未返回的请求的数量
