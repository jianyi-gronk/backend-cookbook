## 1. Nginx

- **Nginx 适合做网关的基础组件，但是功能对于世纪业务场景来说不太完善，需要通过类似 APISIX 这样封装之后的组件去充当网关**

#### 1.1 基础概念

- Nginx 是一个 轻量级 / 高性能 的反向代理 Web 服务器，它是由 C 语言写的，所以速度非常快、性能非常优秀
- **它的主要功能就是反向代理、负载均衡、配置 SSL 证书、防盗链、解决跨域问题、缓存、限流、动静资源分离等等**
- 从一个网络发送一个信息到另一个网络，需要经过一个 “关口”，即网关。网关可以自行决定允不允许让消息通过，或者决定是否替你转发和接收消息、把消息分发给其他人，或者帮你的消息添加和预处理一些信息，或者替你直接回答消息等等功能

#### 1.2 常用命令

```
nginx -s stop       快速关闭 Nginx，可能不保存相关信息，并迅速终止web服务
nginx -s quit       平稳关闭 Nginx，保存相关信息，有安排的结束web服务
nginx -s reload     因改变了 Nginx相关配置，需要重新加载配置而重载
nginx -s reopen     重新打开日志文件
nginx -c filename   为 Nginx 指定一个配置文件，来代替缺省的
nginx -t            不运行，仅仅测试配置文件。Nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件
nginx -v            显示 Nginx 的版本
nginx -V            显示 Nginx 的版本，编译器版本和配置参数
```

## 2. 常见应用

#### 2.1 反向代理

- 代理服务器和客户端在一边就是正向代理，和服务端在一边就是反向代理
- 用户端无法通过公网直接访问到后台服务器上的应用程序，但是可以直接访问 nginx 网关，再由 nginx 分发到不同的服务器上，用户端并不知道真正提供服务的服务器是谁，也不知道它的具体 ip 地址和端口，所以称之为反向代理
- 基础实现一个反向代理的 nginx 服务器

  ```
  # 运行用户
  # user somebody;

  # 启动进程,通常设置成和cpu的数量相等
  worker_processes  1;

  # 全局错误日志
  error_log  D:/Tools/nginx-1.10.1/logs/error.log;
  error_log  D:/Tools/nginx-1.10.1/logs/notice.log  notice;
  error_log  D:/Tools/nginx-1.10.1/logs/info.log  info;

  # PID文件，记录当前启动的nginx的进程ID
  pid        D:/Tools/nginx-1.10.1/logs/nginx.pid;

  # 工作模式及连接数上限
  events {
    worker_connections 1024;    # 单个后台worker process进程的最大并发链接数
  }

  # 设定http服务器，利用它的反向代理功能提供负载均衡支持
  http {
    # 设定mime类型（ 邮件支持类型 ），类型由 mime.types 文件定义
    include       D:/Tools/nginx-1.10.1/conf/mime.types;
    default_type  application/octet-stream;

    # 设定日志
    log_format  main  '[$remote_addr] - [$remote_user] [$time_local] "$request"'
                      '$status $body_bytes_sent "$http_referer"'
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log    D:/Tools/nginx-1.10.1/logs/access.log main;
    rewrite_log     on;

    # sendfile 指令指定 nginx 是否调用 sendfile 函数（ zero copy 方式 ）来输出文件，
    #   对于普通应用，必须设为 on
    #   如果用来进行下载等应用磁盘 I/O 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，降低系统的 uptime
    sendfile        on;
    #tcp_nopush     on;

    # 连接超时时间
    keepalive_timeout  120;
    tcp_nodelay        on;

    # gzip 压缩开关
    #gzip  on;

    # 设定实际的服务器列表
    upstream zp_server1{
      server 127.0.0.1:8089;
    }

    # HTTP 服务器
    server {
      # 监听 80 端口，80 端口是知名端口号，用于 HTTP 协议
      listen       80;

      # 定义使用 www.xx.com 访问
      server_name  www.helloworld.com;

      # 首页
      index index.html

      # 指向 webapp 的目录
      root D:\01_Workspace\Project\github\zp\SpringNotes\spring-security\spring-shiro\src\main\webapp;

      # 编码格式
      charset utf-8;

      # 代理配置参数
      proxy_connect_timeout 180;
      proxy_send_timeout 180;
      proxy_read_timeout 180;
      proxy_set_header Host $host;
      proxy_set_header X-Forwarder-For $remote_addr;

      # 反向代理的路径（ 和 upstream 绑定 ），location 后面设置映射的路径
      location / {
          proxy_pass http://zp_server1;
      }

      # 静态文件，nginx 自己处理
      location ~ ^/(images|javascript|js|css|flash|media|static)/ {
          root D:\01_Workspace\Project\github\zp\SpringNotes\spring-security\spring-shiro\src\main\webapp\views;
          #过期30天，静态文件不怎么更新，过期可以设大一点，如果频繁更新，则可以设置得小一点。
          expires 30d;
      }

      # 设定查看 nginx 状态的地址
      location /NginxStatus {
          stub_status           on;
          access_log            on;
          auth_basic            "NginxStatus";
          auth_basic_user_file  conf/htpasswd;
      }

      # 禁止访问 .htxxx 文件
      location ~ /\.ht {
        deny all;
      }

      # 错误处理页面（可选择性配置）
      # error_page   404              /404.html;
      # error_page   500 502 503 504  /50x.html;
      # location = /50x.html {
      #   root   html;
      # }
    }
  }
  ```

#### 2.2 负载均衡

- 通常后端项目并会开启多个应用程序，这时候就需要 nginx 来选择将所有的请求分发给不同的程序应用，这个过程就是负载均衡，nginx 中已经提供了几种常见的负载均衡算法
- 轮询
  ```
  upstream bck_testing_01 {
    # 默认所有服务器权重为 1
    server 192.168.250.220:8080
    server 192.168.250.221:8080
    server 192.168.250.222:8080
  }
  ```
- 加权轮询
  ```
  upstream bck_testing_01 {
    server 192.168.250.220:8080   weight=3
    server 192.168.250.221:8080              # default weight=1
    server 192.168.250.222:8080              # default weight=1
  }
  ```
- 最少连接

  ```
  upstream bck_testing_01 {
    least_conn;

    # with default weight for all (weight=1)
    server 192.168.250.220:8080
    server 192.168.250.221:8080
    server 192.168.250.222:8080
  }
  ```

- 加权最少连接

  ```
  upstream bck_testing_01 {
    least_conn;

    server 192.168.250.220:8080   weight=3
    server 192.168.250.221:8080              # default weight=1
    server 192.168.250.222:8080              # default weight=1
  }
  ```

- 普通 Hash

  ```
  upstream bck_testing_01 {
    hash $request_uri;

    # with default weight for all (weight=1)
    server 192.168.250.220:8080
    server 192.168.250.221:8080
    server 192.168.250.222:8080
  }
  ```

- IP Hash

  ```
  upstream bck_testing_01 {
      ip_hash;

      # with default weight for all (weight=1)
      server 192.168.250.220:8080
      server 192.168.250.221:8080
      server 192.168.250.222:8080
  }
  ```

#### 2.3 解决跨域问题

- 只要在 nginx 配置中添加相关配置，nginx 就会在分发每个请求前，再请求中加上跨域相关配置的请求头，再分发给后端应用，对于前端来说，可以实现无感知的跨域
  ```
  location / {
    #允许跨域请求的域，* 代表所有
    add_header 'Access-Control-Allow-Origin' *;
    #允许请求的header
    add_header 'Access-Control-Allow-Headers' *;
    #允许带上cookie请求
    add_header 'Access-Control-Allow-Credentials' 'true';
    #允许请求的方法，比如 GET,POST,PUT,DELETE
    add_header 'Access-Control-Allow-Methods' *;
    if ($request_method = 'OPTIONS') {
        return 204;
    }
    proxy_pass http://192.168.1.12:8080;
  }
  ```

#### 2.4 限流

- nginx 提供了两个用来限制 IP 的连接和并发的配置 limit_req_zone 和 limit_req
  - limit_req_zone 用来限制单位时间内的请求数，即速率限制，采用的漏桶算法
  - limit_req 用来限制同一时间连接数，即并发限制
- limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
  - 第一个参数：$binary*remote_addr 表示通过 remote_addr 这个标识来做限制，“binary*”的目的是缩写内存占用量，是限制同一客户端 ip 地址
  - 第二个参数：zone=one:10m 表示生成一个大小为 10M，名字为 one 的内存区域，用来存储访问的频次信息
  - 第三个参数：rate=1r/s 表示允许相同标识的客户端的访问频次，这里限制的是每秒 1 次，还可以有比如 30r/m 的
- limit_req zone=one burst=5 nodelay;
  - 第一个参数：zone=one 设置使用哪个配置区域来做限制，与上面 limit_req_zone 里的 name 对应
  - 第二个参数：burst=5，重点说明一下这个配置，burst 爆发的意思，这个配置的意思是设置一个大小为 5 的缓冲区当有大量请求过来时，超过了访问频次限制的请求可以先放到这个缓冲区内
  - 第三个参数：nodelay，如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回 503，如果没有设置，则所有请求会等待排队
- 以漏桶算法，举例
  ```
  http {
    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
    server {
      location /search/ {
        limit_req zone=one burst=5 nodelay;
      }
    }
  }
  ```
- 令牌桶算法
  - Nginx 默认不直接实现令牌桶算法，需要通过结合其他 Nginx 模块或外部工具来实现类似功能
