## 1. 实现 Web 和 Nodejs 的 PRC 调用思路

#### 1.1 通信尽可能使用语言原生库

- 性能和效率：
  - Dubbo 等 RPC 框架通常用于高性能的服务间通信。原生库通常比第三方封装库更轻量级，因为它们省去了额外的封装和抽象层，直接使用原生库可能会带来更低的延迟和更高的吞吐量，在一个对性能要求极高的系统中，更倾向于使用精简和经过优化的原生解决方案，而不是使用第三方库
- 控制和灵活性：
  - 使用原生库可以让开发者有更多的控制权，比如可以更细粒度地处理网络连接、超时、重试逻辑等。在定制化需求较多的分布式系统中，这种控制往往是必需的
- 依赖性和稳定性：
  - 依赖于外部库会引入额外的依赖性风险。例如，第三方库可能不再维护，或者新版本中带来了不向后兼容的变更。对于一个企业级的框架来说，维护者往往会倾向于控制更多的组件以保证整体的稳定性
- 兼容性和标准化：
  - RPC 框架需要确保与各种语言和环境的兼容性。使用原生库可以帮助确保与语言和平台的规范对齐，减少因第三方库更新或差异导致的兼容性问题
- 轻量化部署：
  - 减少第三方库的使用可以减小应用程序的体积，尤其是在微服务架构中，这会带来轻量化部署的优势

#### 1.2 确定协议

- 确定 RPC 通信需要兼容哪些协议，Triple，gRPC，Thrift 等等，比如 Dubbo 兼容 Triple 协议和 gRPC 协议
- 确定需要兼容的不同协议的相同点
  - 可插拔的序列化和压缩
  - 单向 RPC 调用和三种类型的流式 RPC 调用
  - 超时设置
  - 头信息（ Headers ）和尾信息（ Trailers ）
  - 由 Status、Message 组成的错误信息
- 抽出这些特性，通过围绕这些通用概念组织 API，并避免引用协议本身

## 2. Web 实现 RPC 调用（ Client 端 ）

#### 2.1 实现通信选型

- Web 端有两个原生请求库：AJAX 和 Fetch，最终选择使用 Fetch 进行通信
  - ajax 使用 XMLHttpRequest 对象，需要编写更多的代码来处理请求和响应，这是一个浏览器提供的 API，可以执行异步请求，ajax 在传统的 JavaScript 项目中用得比较多，并且常与旧版本的 JavaScript 库（ 例如 jQuery 的 $.ajax() ）结合使用
  - fetch 提供了更简洁的 API，使用 Promises，可以使用更简洁的链式语法和 async/await 来处理异步代码，同时提供了丰富的 API，提供了对 HTTP 请求的更现代和强大的控制，如中断请求的 AbortController
- 如何拿到当前的 Fetch
  ```
  const fetch = options.fetch ?? globalThis.fetch;
  ```
  - 用户可以通过参数 options 传入自定义的 fetch api，也可以通过 globalThis 拿到环境中的 fetch
  - 这样做的好处是当当前浏览器环境下不存在 fetch api，用户也可以去传入自定义 fetch
  - globalThis 是在 ECMAScript 2020 规格中引入的一个标准化的全局对象，提供了一个统一的全局对象，使开发者无需关心代码运行在哪个环境中，都可以使用 globalThis 访问全局作用域
    - 例如在浏览器中是 window，在 Node.js 中是 global，而在 Web Workers 中是 self

#### 2.2 Web 的限制

- 无论是 AJAX 还是 Fetch，都无法主动去指定是基于 HTTP1 还是 HTTP2 协议
  - 这部分是由浏览器和服务器在底层通过 TLS 握手过程中的 ALPN 来自动协商的，如果都支持 HTTP2 协议的话，会优先使用 HTTP2 协议，否则退回到 HTTP1 协议
- 无论是 AJAX 还是 Fetch，在基于 HTTP2 时，都不能流式地发送（ 推送 ）请求数据，只能接收流响应数据，因此只能实现单向 PRC 通信和服务端流式 PRC 通信

#### 2.3 实现服务端流式 PRC 通信

- 通过 Fetch 实现的简单样例
  ```typescript
  fetch('http://example.com')
    .then(response => {
      const reader = response.body.getReader();

      // 使用流的方式来读取数据
      reader.read().then(function processText({ done, value }) {
        if (done) {
          console.log("Stream complete");
          return;
        }
        
        // 处理接收到的数据片段 value
        // …

        // 读取下一个数据片段
        reader.read().then(processText);
      });
    })
    .catch(err => {
      console.error('Fetch error:', err);
    });
  ```

## 3. Nodejs 实现 RPC 调用（ Client 端 ）

- 基于原生的 http，https 和 http2 框架
- 基于 http1 模块（ 同时用到 http 和 https 模块 ）
  ```typescript
  // dubbo-js 源码中的实现
  function h1Request(
    sentinel: Sentinel,
    url: string,
    options:
      | Omit<http.RequestOptions, "signal">
      | Omit<https.RequestOptions, "signal">,
    onRequest: (request: http.ClientRequest) => void
  ): void {
    let request: http.ClientRequest;

    // 通过 url 前缀判断使用 http 模块还是 https 模块
    if (new URL(url).protocol.startsWith("https")) {
      request = https.request(url, options);
    } else {
      request = http.request(url, options);
    }

    sentinel.catch((reason) =>
      request.destroy(dubboErrorFromNodeReason(reason))
    );

    // 出于效率原因，Node.js 通常会缓冲请求头，直到调用 request.end() 或写入第一块请求数据。 然后尝试将请求头和数据打包到单个 TCP 数据包中
    // 这通常是需要的（ 节省了 TCP 往返 ），但是当第一个数据直到可能很晚才发送时才需要。 request.flushHeaders() 绕过优化并启动请求。
    // 强制令它立即发送标头，使得 HTTP1 获得和 HTTP2 Client 一致的行为
    request.flushHeaders();

    request.on("error", sentinel.reject);
    request.on("socket", function onRequestSocket(socket: net.Socket) {
      function onSocketConnect() {
        socket.off("connect", onSocketConnect);
        onRequest(request);
      }

      // 如果 readyState 为 open，则套接字由于 keepAlive 而已经打开，因此connect 事件永远不会触发，因此显式调用 onRequest
      if (socket.readyState === "open") {
        onRequest(request);
      } else {
        socket.on("connect", onSocketConnect);
      }
    });
  }
  ```
  
- 基于 http2 模块
  ```typescript
  // 使用 http2.connect 连接到服务器，返回 http2.ClientHttp2Session 类型的实例
  // url 的前缀可以是 http，也可以是 https
  const session = http2.connect(url, options);

  // 发起请求，一个会话可以有多个请求，返回 http2.Http2Session 类型的实例
  // 可以通过 stream 身上的 session 属性获取会话，即 stream.session === session 为 true
  const stream = session.request({ ':path': '/' });

  // 接收响应头部
  stream.on('response', (headers) => {
    console.log('响应头部:', headers);
  });

  // 接收数据
  stream.on('data', (chunk) => {
    console.log('响应数据:', chunk.toString());
  });

  // 监听请求结束
  stream.on('end', () => {
    console.log('请求结束');
    session.close(); // 关闭会话
  });

  // 结束请求
  stream.end();

  // 监听会话的各种事件
  session.on('connect', () => {
    console.log('连接到服务器');
  });

  session.on('close', () => {
    console.log('会话关闭');
  });

  session.on('error', (error) => {
    console.error('会话错误:', error);
  });
  ```

## 4. Nodejs 实现 RPC 调用（ Server 端 ）

- 基于原生的 http，https 和 http2 框架
- http，https 和 http2 创建服务器的方法都极为相似
  ```typescript
  // http 创建服务器
  const server = http.createServer((req, res) => {
    // 处理请求和响应
  });

  // https 创建服务器
  const server = https.createServer(options, (req, res) => {
    // 处理请求和响应
  });

  // http2 模块提供了两个方法：createServer 和 createSecureServer
  const server = http2.createServer((req, res) => {
    // 处理请求和响应
  });
  const secureServer = http2.createSecureServer(options, (req, res) => {
    // 处理请求和响应
  });
  ```
  - 因此可以封装函数 
    ```typescript
    const nodeRequestHandler = (req, res) => {
      // 处理请求和响应
    }
    ```
  