## 1. 进程间通信

- 尽管今天的大多数 RPC 技术已经不再追求这个目标了，但无可否认，RPC 出现的最初目的，就是为了让计算机能够跟调用本地方法一样去调用远程方法
- 所以，先来看一下本地方法调用时，计算机是如何处理的。通过以下这段 Java 风格的伪代码，来定义几个稍后要用到的概念：
  ```
  // Caller    :  调用者，代码里的main()
  // Callee    ： 被调用者，代码里的println()
  // Call Site ： 调用点，即发生方法调用的指令流位置
  // Parameter ： 参数，由Caller传递给Callee的数据，即“hello world”
  // Retval    ： 返回值，由Callee传递给Caller的数据。以下代码中如果方法能够正常结束，它是void，如果方法异常完成，它是对应的异常
  public static void main(String[] args) {
    System.out.println(“hello world”);
  }
  ```

## 1. RPC 框架介绍

- RPC，远程过程调用（ Remote Procedure Call，RPC ）是一个计算机通信协议，该协议允许运行于一台计算机的程序调用另一台计算机的上的程序
- 通俗讲，RPC 通过把网络通讯抽象为远程的过程调用，调用远程的过程就像调用本地的子程序一样方便，从而屏蔽了通讯复杂性，使开发人员可以无需关注网络编程的细节，将更多的时间和精力放在业务逻辑本身的实现上，提高工作效率
- RPC 本质上是一种 Inter-process communication（ IPC ）—— 进程间通信的形式。常见的进程间通信方式如管道、共享内存是同一台物理机上的两个进程间的通信，而 RPC 就是两个在不同物理机上的进程之间的通信。概括的说，RPC 就是在一台机器上调用另一台机器上的方法，这种调用在远程机器上对代码的执行就像在本机上对代码的执行一样，只是迁移了一个执行环境而已
- RPC 是一种 C/S 架构的服务模型，server 端提供接口供 client 端 调用，client 端向 server 端发送数据，server 端接收 client 端的数据进行相关计算并将结果返回给 client 端
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/9b00f1dd-98a2-4460-9b33-67d5c894af01)
- 为了实现上述 RPC 步骤，许多 RPC 工具被研发出来。这些 RPC 工具大多使用 “接口描述语言” —— interface description language ( IDL ) 来提供跨平台跨语言的服务调用。现在生产中用的最多的 IDL 是 Google 开源的 protobuf
- 在 OSI 网络通信模型 中，RPC 跨越了传输层 和 应用层，而 传输层 常见的协议有 TCP 和 UDP ，应用层 常见协议有 HTTP、FTP、SMTP

## 2. 常见的开源 RPC 框架

- 语言平台绑定的开源 RPC 框架
  - Motan：微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 Java 语言
  - Tars：腾讯内部使用的 RPC 框架，于 2017 年对外开源，仅支持 C++ 语言
  - Spring Cloud：国外 Pivotal 公司 2014 年对外开源的 RPC 框架，仅支持 Java 语言
- 跨语言平台的开源 RPC 框架
  - Dubbo：国内最早开源的 RPC 框架，由阿里巴巴公司开发并于 2011 年末对外开源，支持多种语言
  - gRPC：Google 于 2015 年对外开源的跨语言 RPC 框架，支持多种语言
  - Thrift：最初是由 Facebook 开发的内部系统跨语言的 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持多种语言
