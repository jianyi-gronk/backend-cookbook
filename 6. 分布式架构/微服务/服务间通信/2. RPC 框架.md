## 1. gRPC 框架

#### 1.1 gRPC 框架介绍

- gRPC（ gRPC Remote Procedure Calls ）是 Google 发起的一个 开源远程过程调用（ Remote procedure call ）系统。该系统基于 HTTP/2 协议传输，使用 Protocol Buffers 作为 接口描述语言（ Interface description language，缩写 IDL ）
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/25248b4c-19e8-47ed-b68a-5e33d6ffb9e7)
- 其他功能包含：
  - 认证（ authentication ）
  - 双向流（ bidirectional streaming ）
  - 流控制（ flow control ）
  - 超时（ timeouts ）
- 最常见的应用场景是：
  - 微服务框架下，多种语言服务之间的高效交互。
  - 将手机服务、浏览器连接至后台
  - 产生高效的客户端库
- 需要注意 gRPC 是基于 HTTP/2 协议，而大部分传统 RPC 框架都是基于 TCP/IP 协议，因为一般协议采用的越底层，效率就会越高，但是 gPRC 为了利用 HTTP/2 的多路复用等特性，因此采用 HTTP/2 协议，而那些基于 TCP/IP 的 RPC 框架，因为没有 HTTP/2 新特性，所以通常不支持流式 RPC

#### 1.2 gRPC 服务定义

- 正如其他 RPC 系统，gRPC 基于如下思想：定义一个服务， 指定其可以被远程调用的方法及其参数和返回类型。gRPC 默认使用 protocol buffers 作为接口定义语言，来描述服务接口和有效载荷消息结构。如果有需要的话，可以使用其他替代方案

  ```
  service HelloService {
    rpc SayHello (HelloRequest) returns (HelloResponse);
  }

  message HelloRequest {
    required string greeting = 1;
  }

  message HelloResponse {
    required string reply = 1;
  }
  ```

#### 1.3 gRPC 服务接口方法

- 单向 RPC，即客户端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用

  ```
  rpc SayHello(HelloRequest) returns (HelloResponse){}
  ```

  - 这是最简单的 RPC 形式：客户端发出单个请求，获得单个响应
  - 一旦客户端通过 RPC 调用一个方法，服务端会得到相关通知，通知包括客户端的元数据，方法名，允许的响应期限（ 如果可以的话 ）
  - 服务端既可以在任何响应之前直接发送回初始的元数据，也可以等待客户端的请求信息，到底哪个先发生，取决于具体的应用
  - 一旦服务端获得客户端的请求信息，就会做所需的任何工作来创建或组装对应的响应。如果成功的话，这个响应会和包含状态码以及可选的状态信息等状态明细及可选的追踪信息返回给客户端
  - 假如状态是 OK 的话，客户端会得到应答，这将结束客户端的调用

- 服务端流式 RPC，即客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止

  ```
  rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse){}
  ```

  - 在发送完所有应答后，服务端的状态详情（ 状态码和可选的状态信息 ）和可选的跟踪元数据被发送回客户端，以此来完成服务端的工作。客户端在接收到所有服务端的应答后也完成了工作

- 客户端流式 RPC，即客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答

  ```
  rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse) {}
  ```

  - 客户端通过发送一个请求流给服务端，取代了原先发送的单个请求。服务端通常（ 但并不必须 ）会在接收到客户端所有的请求后发送回一个应答，其中附带有它的状态详情和可选的跟踪数据

- 双向流式 RPC，即两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持

  ```
  rpc BidiHello(stream HelloRequest) returns (stream HelloResponse){}
  ```

  - 双向流式 RPC 调用由客户端调用方法来初始化，而服务端则接收到客户端的元数据，方法名和截止时间
  - 服务端可以选择发送回它的初始元数据或等待客户端发送请求。下一步怎样发展取决于应用，因为客户端和服务端能在任意顺序上读写
  - 这些流的操作是完全独立的。例如服务端可以一直等直到它接收到所有客户端的消息才写应答，或者服务端和客户端可以像"乒乓球"一样：服务端后得到一个请求就回送一个应答，接着客户端根据应答来发送另一个请求，以此类推

#### 1.4 使用 API 接口

- gRPC 提供 protocol buffer 编译插件，能够从一个服务定义的 .proto 文件生成客户端和服务端代码。通常 gRPC 用户可以在服务端实现这些 API，并从客户端调用它们
  - 在服务侧，服务端实现服务接口，运行一个 gRPC 服务器来处理客户端调用。gRPC 底层架构会解码传入的请求，执行服务方法，编码服务应答
  - 在客户侧，客户端有一个存根实现了服务端同样的方法。客户端可以在本地存根调用这些方法，用合适的 protocol buffer 消息类型封装这些参数，gRPC 来负责发送请求给服务端并返回服务端 protocol buffer 响应

#### 1.5 同步 vs 异步

- 同步 RPC 调用一直会阻塞直到从服务端获得一个应答，这与 RPC 希望的抽象最为接近。另一方面网络内部是异步的，并且在许多场景下能够在不阻塞当前线程的情况下启动 RPC 是非常有用的
- 在多数语言里，gRPC 编程接口同时支持同步和异步的特点

#### 1.6 RPC 生命周期

- 截止时间
  - gRPC 允许客户端在调用一个远程方法前指定一个最后期限值。这个值指定了在客户端可以等待服务端多长时间来应答，超过这个时间值 RPC 将结束并返回 DEADLINE_EXCEEDED 错误。在服务端可以查询这个期限值来看是否一个特定的方法已经过期，或者还剩多长时间来完成这个方法
  - 各语言来指定一个截止时间的方式是不同的。比如在 Python 里一个截止时间值总是必须的，但并不是所有语言都有一个默认的截止时间
- RPC 终止
  - 在 gRPC 里，客户端和服务端对调用成功的判断是独立的、本地的，他们的结论可能不一致。这意味着，比如你有一个 RPC 在服务端成功结束("我已经返回了所有应答!")，到那时在客户端可能是失败的（ "应答在最后期限后才来到!" ）。也可能在客户端把所有请求发送完前，服务端却判断调用已经完成了
- 取消 RPC
  - 无论客户端还是服务端均可以再任何时间取消一个 RPC 。一个取消会立即终止 RPC 这样可以避免更多操作被执行。它不是一个"撤销"， 在取消前已经完成的不会被回滚。当然，通过同步调用的 RPC 不能被取消，因为直到 RPC 结束前，程序控制权还没有交还给应用
- 元数据集
  - 元数据是一个特殊 RPC 调用对应的信息 ，这些信息以键值对的形式存在，一般键的类型是字符串，值的类型一般也是字符串( 当然也可以是二进制数据 )
  - 元数据对 gRPC 本事来说是不透明的，它让客户端提供调用相关的信息给服务端，反之亦然。 对于元数据的访问是语言相关的
- 频道
  - 在创建客户端存根时，一个 gRPC 频道提供一个特定主机和端口服务端的连接。客户端可以通过指定频道参数来修改 gRPC 的默认行为，比如打开关闭消息压缩。一个频道具有状态，包含已连接和空闲。gRPC 如何处理关闭频道是语言相关的。有些语言可允许询问频道状态

## 2. Thrift 框架

#### 2.1 Thrift 框架

- Thrift 是一个跨语言的服务部署框架，最初由 Facebook 于 2007 年开发，2008 年进入 Apache 开源项目。Thrift 通过 接口描述语言（ Interface description language，缩写 IDL ）来定义 RPC 的接口和数据类型，然后通过编译器生成不同语言的代码（ 目前支持 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 和 OCaml ），并由生成的代码负责 RPC 协议层 和 传输层 的实现
- Thrift 使用 TCP/IP 传输协议
- 利用 Thrift 用户只需要做三件事：
  - 利用 IDL 定义数据结构及服务
  - 利用代码生成工具将 IDL 编译成对应语言（ 如 C++、JAVA ），编译后得到基本的框架代码
  - 利用编译后的基本框架代码，完成完整代码（ 纯 C++ 代码、JAVA 代码等 ）

#### 2.2 Thrift 基础架构

- Thrift 是 C/S 的架构体系，通过代码生成工具将 IDL 接口定义文件生成服务器端和客户端代码（ 可以为不同语言 ），从而实现服务端和客户端跨语言的支持。用户在 Thirft 描述文件中声明自己的服务，这些服务经过编译后会生成相应语言的代码文件，然后客户端调用服务、服务器端提供服务来实现服务。其中 protocol（协议层, 定义数据传输格式，可以为二进制或者 XML 等）和 transport（ 传输层，定义数据传输方式，可以为 TCP/IP 传输，内存共享或者文件共享等 ）被用作运行时库
- Thrift 协议栈如下图所示：
  ![image](https://github.com/jianyi-gronk/jianyi-gronk/assets/95062803/d5db13b1-01cc-4cbf-8e94-65a8302ef1a0)
- 在 Client 和 Server 最顶层是用户自定义的处理逻辑，用户只需要编写用户逻辑，就可以完成整套的 RPC 调用流程。用户逻辑的下面是 Thrift Runtime 自动生成的代码，这些代码主要用于结构化数据的解析，发送和接收，同时服务器端的自动生成代码中还包含了 RPC 请求的转发（ Client 的 A 调用转发到 Server A 函数进行处理 ）

#### 2.3 TProtocol 层

- TProtocol 主要负责结构化数据组装成 Message，或者从 Message 结构中读出结构化数据。TProtocol 将一个有类型的数据转化为字节流以交给 TTransport 进行传输，或者从 TTransport 中读取一定长度的字节数据转化为特定类型的数据。如 int32 会被 TBinaryProtocol Encode 为一个四字节的字节数据，或者 TBinaryProtocol 从 TTransport 中取出四个字节的数据 Decode 为 int32
- 协议（ TProtocol ）层提供了序列化和反序列化。Thrift 提供了以下协议：
  - TBinaryProtocol：一种直接转成二进制的协议，而不是转成文本
  - TCompactProtocol：非常高效地，密集地转换数据的协议
  - TDenseProtoco：和 TCompactProtocol 相似，但是它传输的数据里剥离了元信息，而在接收端加上了 TDenseProtocol 目前还在测试阶段，java 实现尚不可用
  - TJSONProtocol：使用 JSON 转换数据
  - TSimpleJSONProtocol：一种只用于写的协议，使用 JSON 转换数据，非常适合脚本语言去解析
  - TDebugProtocol：数据转换成可以直接阅读的文本，以用来帮助 debug

#### 2.4 TTranport 层

- 传输（Transport）层是负责读写传输的。Thrift 支持以下几种：
  - TSocket：使用阻塞式 socket I/O
  - TFramedTransport：使用非阻塞 server 传输，以帧来计量传输大小，每帧前携带数据长度
  - TFileTransport：文件方式进行传输，但是这种 Transport 不支持 Java
  - TMemoryTransport： 使用内存 I/O， Java 的实现则是在内部使用 ByteArrayOutputStream。
  - TZlibTransport:：传输执行时使用 zlib 压缩，使用时需要结合其他传输一同使用，Java 不支持。

#### 2.5 TServer 层

- TServer 负责接收 Client 的请求，并将请求转发到 Processor 进行处理。TServer 主要任务就是高效的接受 Client 的请求，特别是在高并发请求的情况下快速完成请求。Thrift 支持以下几种服务类型：
  - TSimpleServer：单线程服务器端使用的标准的阻塞式 I/O
  - TThreadPoolServer：多线程服务器端使用标准的阻塞式 I/O
  - TNonblockingServer： 多线程服务器端使用的非阻塞式 I/O，并实现了 Java 中的 NIO 通道

#### 2.6 TProcessor 层

- TProcessor 负责对 Client 的请求做出响应，包括 RPC 请求转发，调用参数解析和用户逻辑调用，返回值写回等处理步骤。Processor 是服务器端从 Thrift 框架转入用户逻辑的关键流程，同时也负责向 Message 结构中写入数据或者读出数据。处理器的接口也很简单：

  ```
  interface TProcessor {
    bool process(TProtocol in, TProtocol out) throws TException
  }

  typedef list<string> listType
  typedef set<string> setType
  typedef map<string, string> mapType
  ```

- Thrift 结构体定义了一个用在多种语言之间的通用对象。定义一个 Thrift 结构体的基本语法与 C 结构体定义非常相似。域可由一个整型域标识符（在该结构体的作用域内是唯一的），以及可选的默认值来标注

#### 2.7 Underlying I/O 层

- 底层 IO 模块，负责实际的数据传输通信，包括 Socket，文件，或者压缩数据流等。
- TTransport 负责以字节流方式发送和接收 Message，是底层 IO 模块在 Thrift 框架中的实现，每一个底层 IO 模块都会有一个对应 TTransport 来负责 Thrift 的字节流 ( Byte Stream ) 数据在该 IO 模块上的传输。例如 TSocket 对应 Socket 传输，TFileTransport 对应文件传输

#### 2.8 Base Types（ 基本类型 ）

- Thrift 通过一个中间语言 IDL（interface definition language，接口定义语言）来定义 RPC 的接口和数据类型。Thrift IDL 类型系统由预定义的基本类型，用户定义的结构，容器类型，异常和服务定义组成，接下了解下：
- Base Types（基本类型）
  > 请注意，Thrift 不支持无符号整数，因为无法直接转换为目标语言中的本机（ 原始 ）类型
  - bool：布尔值
  - byte：有符号字节
  - i16：16 位有符号整数
  - i32：32 位有符号整数
  - i64：64 位有符号整数
  - double：64 位浮点数
  - binary：二进制
  - string: 字符串
- Containers（ 容器 ）
  - Thrift 容器是强类型的，可映射到大多数编程语言中常用的容器类型。使用 C++ 模板类来标注。有三种可用类型：
    - list：元素的有序列表，对应转换到 STL 的 vector，Java 的 ArrayList，脚本语言中的数组等
    - set：无序的元素集合，对应转换到 STL 的 set，Java 的 HashSet，Python 的 set 等
    - map：对应转到 STL 的 map，Java 的 HashMap，PHP 的关联数组，Python/Ruby 的字典等
    ```
    typedef list<string> listType
    typedef set<string> setType
    typedef map<string, string> mapType
    ```
- Structs（ 结构体 ）

  - Thrift 结构体定义了一个用在多种语言之间的通用对象。定义一个 Thrift 结构体的基本语法与 C 结构体定义非常相似。域可由一个整型域标识符（在该结构体的作用域内是唯一的），以及可选的默认值来标注

    ```
    struct Phone{
      1: i32 id,
      2: string number,
      3: PhoneType type, // 自定义类型
    }

    struct TrafficEnv {
      1: bool Open = false,
      2: string Env = "",
    }
    ```

- Exceptions（ 异常 ）
  - 异常在语法和功能上都与结构体相同，唯一的区别是使用 exception 关键词，而非 struct 关键词进行声明。 生成的对象继承自各目标编程语言中适当的异常基类，以便与任何给定语言中的本地异常处理无缝地整合
    ```
    exception exceptionType{
      1: i32 errCode;
      2: string msg;
      3: string info
    }
    ```

#### 2.9 Services（服务）

- 使用 Thrift 类型定义服务，对一个服务的定义在语法上等同于在面向对象编程中定义一个接口（或一个纯虚抽象类）。Thrift 编译器生成实现该接口的客户与服务器存根。服务的定义如下
- 使用 Thrift 类型来定义服务。服务的定义在语义上等同于 OOP 编程中定义的接口（ 或纯抽象类 ）。Thrift 编译器会生成实现这些接口的 client 和 server stub
  - 服务由一组命名函数组成，每组函数都有一个参数列表和一个返回类型。
  - 除了其他所有已定义的已定义的 Thrift 类型之外，void 是函数返回的有效类型
  - 可以将单向修饰符关键字添加到 void 函数，该函数是生成不等待响应的代码
  - 纯 void 函数将返回对客户端的响应，以确保操作已在服务端完成
  - 使用单向方法调用客户端仅保证请求在传输层完成
  - 可以由 服务器并行/不按调用顺序 的方式执行同一客户端的单向方法调用
- 语法：
  ```
  service <name> {
    <returntype> <name>(<arguments>)
    [throws (<exceptions>)]
    ...
  }
  ```
- 例子：

  ```
  service StringCache {
  void set(1:i32 key, 2:string value), // void 是一个有效的函数返回类型
  string get(1:i32 key) throws (1:KeyNotFound knf),
  void delete(1:i32 key)
  }

  service Hello{
  string helloString(1:string para);
  i32 helloInt(1:i32 para);
  bool helloBoolean(1:bool para);
  void helloVoid();
  string helloNull();
  }
  ```

- Typedefs（ 类型定义 ）

  - Thrift 支持 C / C ++ 类型定义风格

    ```
    // 类型定义
    typedef hash_map<UrlTableProperties \*, string> PropertiesMap;

    typedef i32 MyInteger
    typedef Tweet ReTweet

    // 类和结构体
    class UrlTable { ...
    class UrlTableTester { ...
    struct UrlTableProperties { ...

    // using 别名
    using PropertiesMap = hash_map<UrlTableProperties \*, string>;

    // 枚举
    enum UrlTableErrors { ...
    ```

- Enums（ 枚举 ）

  - 枚举创建一个带有命名值的枚举类型，枚举类型第一个元素默认为 0，也可以为其赋值，但后一个元素必须比前面的元素大。赋予的任何常量值必须为非负数

    ```
    enum TweetType {
      TWEET,
      RETWEET = 2,
      DM = 0xa,
      REPLY
    }

    struct Tweet {
      1: required i32 userId;
      2: required string userName;
      3: required string text;
      4: optional Location loc;
      5: optional TweetType tweetType = TweetType.TWEET // 5
      16: optional string language = "english"
    }
    ```

- Namespaces（ 命名空间 ）
  - Thrift 的命名空间类似于 C++ 中的 namespace 和 java 中的 package，提供了一种隔离代码文件的方式，避免命名冲突等。
    ```
    namespace java xxx
    namespace cpp xxx
    namespace php xxx
    ```
- Comments（ 注释 ）

  - Thrift 支持 Java 中的多行注释
  - Thrift 支持 shell、C 风格的多行以及 Java / C ++ 风格的单行注释。

    ```
    # This is a valid comment.

    /\*

    - This is a multi-line comment.
    - Just like in C.
      \*/

    // C++/Java style single-line comments work just as well.
    ```

- Includes（ 引入 ）

  - 为了提高代码可用性，是代码可复用，经常将不同类别的代码写在不同的文件中，将代码隔离开。include 使得来自另一个文件的所有符号都可见（带前缀使用），并将相应的 include 语句添加到此 Thrift 文档生成的代码中。

    ```
    include "Hello.thrift"

    struct TweetSearchResult {
      1: list<tweet.Tweet> tweets; // 2
    }

    const i32 demoConst = Hello.intConst
    ```

- Constants（ 常量 ）
  - Thrift 可以定义用于多种语言的常量，复杂类型和结构可使用 JSON 表示法指定
    ```
    const i32 INT_CONST = 1234; // 1
    const map<string,string> MAP_CONST = {"hello": "world", "goodnight": "moon"}
    ```
