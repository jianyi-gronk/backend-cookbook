## 1. 什么是 ZooKeeper

#### 1.1 基础介绍

- ZooKeeper 最初由 yahoo 公司开发，目前由 Apache 进行维护
- ZooKeeper 本质上是一个分布式的小文件存储系统（ Zookeeper = 文件系统 + 监听机制 ）
  - 文件系统：提供基于类似于文件系统的**目录树**方式的数据存储，并且可以对树中的节点进行有效管理，从而用来维护和监控存储的数据的状态变化（ 但是 ZooKeeper 并不是用来专门存储数据的 ）
  - 监听机制：通过监控这些数据状态的变化，从而可以达到基于数据的集群管理、统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等功能
- ZooKeeper 采用的的 CP 一致性协议 ZAB
- 很多框架都基于 ZooKeeper 来实现分布式高可用，如：Dubbo、Kafka 等

#### 1.2 Zookeeper 特性

- 顺序一致性：从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 ZooKeeper 中
- 原子性：所有事务请求的处理结果在整个集群中所有机器上都是一致，不存在部分机器应用了该事务，而另一部分没有应用的情况
- 单一视图：所有客户端看到的服务端数据模型都是一致的
- 可靠性：一旦服务端成功应用了一个事务，则其引起的改变会一直保留，直到被另外一个事务所更改
- 实时性：一旦一个事务被成功应用后，ZooKeeper 可以保证客户端立即可以读取到这个事务变更后的最新状态的数据

## 2. ZooKeeper 设计目标

- ZooKeeper 致力于为那些高吞吐的大型分布式系统提供一个高性能、高可用、且具有严格顺序访问控制能力的分布式协调服务

#### 2.1 目标一：简单的数据模型

- ZooKeeper 通过树形结构来存储数据，它由一系列被称为 ZNode 的数据节点组成，类似于常见的文件系统。不过和常见的文件系统不同，ZooKeeper 将数据全量存储在 **内存** 中，而不是 磁盘 上，以此来实现高吞吐，减少访问延迟

  <img src="https://img-blog.csdnimg.cn/956b3a8c2a374e6a82568b9782d61eb2.png" width="400">

#### 2.2 目标二：构建集群

- 可以由一组 ZooKeeper 服务构成 ZooKeeper 集群，集群中每台机器都会单独在内存中维护自身的状态，并且每台机器之间都保持着通讯，只要集群中有半数机器能够正常工作，那么整个集群就可以正常提供服务

  <img src="https://img-blog.csdnimg.cn/ab2a42cb9c0b4a4fac7d5e073211f2d2.png" width="600">

#### 2.3 目标三：顺序访问

- 对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增 ID，这个 ID 反映了所有事务请求的先后顺序

#### 2.4 目标四：高性能高可用

- ZooKeeper 将数据全量存储在内存中以保持高性能，并通过服务集群来实现高可用，由于 ZooKeeper 的所有更新和删除都是基于事务的，所以其在读多写少的应用场景中有着很高的性能表现

## 3. 核心概念

#### 3.1 集群角色

- ZooKeeper 集群中的机器分为以下 3 种角色：Leader，Follower，Ovserver
- Leader：
  - 维护集群状态，它是由集群选举所产生的
  - 它负责发起并维护与各 Follwer 及 Observer 间的心跳。所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器
  - Zookeeper 是单主模型，**一个 Zookeeper 集群同一时间只会有一个实际工作的 Leader**
- Follower：
  - 定期向 Leader 汇报自己的节点状态
  - 可直接处理并返回客户端的读请求，同时会将写请求转发给 Leader 处理。并参与 写操作 “过半写成功” 的策略 和 Leader 的选举
  - 一个 Zookeeper 集群可能同时存在多个 Follower
- Observer：
  - 定期向 Leader 汇报自己的节点状态
  - 可直接处理并返回客户端的读请求，但不参与 写操作 “过半写成功” 的策略 和 Leader 的选举，所以 Observer 节点不会影响到写操作的执行，因此 Observer 可以在不影响写性能的情况下提升集群的读性能

#### 3.2 会话

- ZooKeeper 客户端通过 TCP 长连接连接到服务集群，会话（ Session ）从第一次连接开始就已经建立，之后通过心跳检测机制来保持有效的会话状态。通过这个连接，客户端可以发送请求并接收响应，同时也可以接收到 Watch 事件的通知
- 关于会话中另外一个核心的概念是 sessionTimeOut（ 会话超时时间 ），当由于网络故障或者客户端主动断开等原因，导致连接断开，此时只要在会话超时时间之内重新建立连接，则之前创建的会话依然有效

#### 3.3 数据节点

- ZooKeeper 数据模型是由一系列基本数据单元 ZNode（ 数据节点 ） 组成的节点树，其中根节点为 /。每个节点上都会保存自己的数据和节点信息，并且有一个与之相关联的 ACL
- 因为 ZooKeeper 的设计目标是实现协调服务，而不是真的作为一个文件存储，因此 ZNode 存储数据的大小被限制在 1MB 以内
- ZooKeeper 中节点可以分为四类：
  - 临时节点（ EPHEMERAL ）：
    - session 链接断开就没了
    - 不能创建子节点
    - 不能同名
  - 临时顺序节点（ EPHEMERAL_SEQUENTIAL ）：
    - session 链接断开就没了
    - 不能创建子节点
    - 同名节点会在后面添加上序号
  - 持久节点（ PERSISTENT ）：
    - session 断联、服务端重启还在
    - 可以创建子节点，子节点可以临时也可以持久
    - 不能同名
  - 持久顺序节点（ PERSISTENT_SEQUENTIAL ）：
    - session 断联、服务端重启还在
    - 可以创建子节点，子节点可以临时也可以持久
    - 同名节点会在后面添加上序号

#### 3.4 节点信息

- ZNode 上有一个顺序标志（ SEQUENTIAL ）。如果在创建 ZNode 时，设置了顺序标志（ SEQUENTIAL ），那么 ZooKeeper 会使用计数器为 ZNode 添加一个单调递增的数值，即 zxid。ZooKeeper 正是利用 zxid 实现了严格的顺序访问控制能力
- 每个 ZNode 节点在存储数据的同时，都会维护一个叫做 Stat 的数据结构，里面存储了关于该节点的全部状态信息
- 如下
  ![image](https://img-blog.csdnimg.cn/8b4ddd24b5004cd69e63ecbfd4e01b28.png)

#### 3.5 ACL

- ZooKeeper 采用 ACL（ Access Control Lists ）策略来进行权限控制，类似于 UNIX 文件系统的权限控制
- ACL 依赖于 ZooKeeper 的客户端认证机制。ZooKeeper 提供了以下几种认证方式：
  - digest：用户名和密码 来识别客户端
  - sasl：通过 kerberos 来识别客户端
  - ip：通过 IP 来识别客户端
- 它定义了如下 5 种权限
  - CREATE：允许创建子节点
  - READ：允许从节点获取数据并列出其子节点
  - WRITE：允许为节点设置数据
  - DELETE：允许删除子节点
  - ADMIN：允许为节点设置权限

## 4. 工作原理

#### 4.1 读操作

- 三种集群角色（ Leader/Follower/Observer ）都可直接处理读请求，从本地内存中读取数据并返回给客户端即可
  ![image](https://github.com/user-attachments/assets/6ad65287-a40a-4120-8531-c9d4713e2560)
- 由于处理读请求不需要服务器之间的交互，所以 Follower/Observer 越多，整体系统的读请求吞吐量越大，也即读性能越好

#### 4.2 Leader 写操作

- 所有的写请求实际上都要交给 Leader 处理。Leader 将写请求以事务形式发给所有 Follower 并等待 ACK，一旦收到半数以上 Follower 的 ACK，即认为写操作成功
- 通过 Leader 进行写操作，主要分为五步：
  ![image](https://github.com/user-attachments/assets/627ddfe0-d382-4eb6-b750-8c3bb7b39cb5)
  - 客户端向 Leader 发起写请求
  - Leader 将写请求以事务 Proposal 的形式发给所有 Follower 并等待 ACK
  - Follower 收到 Leader 的事务 Proposal 后返回 ACK
  - Leader 得到过半数的 ACK（ Leader 对自己默认有一个 ACK ）后向所有的 Follower 和 Observer 发送 Commmit
  - Leader 将处理结果返回给客户端
- 注意
  - Leader 不需要得到 Observer 的 ACK，即 Observer 无投票权
  - Observer 虽然无投票权，但仍须同步 Leader 的数据从而在处理读请求时可以返回尽可能新的数据

#### 4.3 Follower/Observer 写操作

- Follower/Observer 均可接受写请求，但不能直接处理，而需要将写请求转发给 Leader 处理
  ![image](https://github.com/user-attachments/assets/c53c7ff6-aefd-4853-a338-b1d7e71ec62b)
- 除了多了一步请求转发，其它流程与直接写 Leader 无任何区别

#### 4.4 事务

- 对于来自客户端的每个更新请求，ZooKeeper 具备严格的顺序访问控制能力
- 为了保证事务的顺序一致性，ZooKeeper 采用了递增的事务 id 号（ zxid ）来标识事务
- Leader 服务会为每一个 Follower 服务器分配一个单独的队列，然后将事务 Proposal 依次放入队列中，并根据 FIFO（ 先进先出 ）的策略进行消息发送
- Follower 服务在接收到 Proposal 后，会将其以事务日志的形式写入本地磁盘中，并在写入成功后反馈给 Leader 一个 Ack 响应
- 当 Leader 接收到超过半数 Follower 的 Ack 响应后，就会广播一个 Commit 消息给所有的 Follower 以通知其进行事务提交，之后 Leader 自身也会完成对事务的提交。而每一个 Follower 则在接收到 Commit 消息后，完成事务的提交
- 所有的提议（ proposal ）都在被提出的时候加上了 zxid。zxid 是一个 64 位的数字，它的高 32 位是 epoch 用来标识 Leader 关系是否改变，每次一个 Leader 被选出来，它都会有一个新的 epoch，标识当前属于那个 leader 的统治时期。低 32 位用于递增计数
- 详细过程如下：
  - Leader 等待 Server 连接
  - Follower 连接 Leader，将最大的 zxid 发送给 Leader
  - Leader 根据 Follower 的 zxid 确定同步点
  - 完成同步后通知 follower 已经成为 uptodate 状态
  - Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了

#### 4.5 Watcher

- ZooKeeper 中一个常用的功能是 Watcher（ 事件监听器 ），该机制是 ZooKeeper 实现分布式协调服务的重要特性
- 客户端注册监听它关心的 ZNode，当 ZNode 状态发生变化（ 数据变化、子节点增减变化 ）时，ZooKeeper 服务会将事件信息推送到客户端

#### 4.6 会话

- ZooKeeper 客户端通过 TCP 长连接连接到 ZooKeeper 服务集群。会话（ Session ）从第一次连接开始就已经建立，之后通过心跳检测机制来保持有效的会话状态。通过这个连接，客户端可以发送请求并接收响应，同时也可以接收到 Watch 事件的通知
- 每个 ZooKeeper 客户端配置中都配置了 ZooKeeper 服务器集群列表。启动时，客户端会遍历列表去尝试建立连接。如果失败，它会尝试连接下一个服务器，依次类推
- 一旦一台客户端与一台服务器建立连接，这台服务器会为这个客户端创建一个新的会话。每个会话都会有一个超时时间，若服务器在超时时间内没有收到任何请求，则相应会话被视为过期。一旦会话过期，就无法再重新打开，且任何与该会话相关的临时 ZNode 都会被删除
- 通常来说，会话应该长期存在，而这需要由客户端来保证。客户端可以通过心跳方式（ ping ）来保持会话不过期
- 会话生命周期
  ![image](https://github.com/user-attachments/assets/304b65ee-91a2-414c-9e13-2091446c3185)
- ZooKeeper 的会话具有四个属性：
  - sessionID：会话 ID，唯一标识一个会话，每次客户端创建新的会话时，Zookeeper 都会为其分配一个全局唯一的 sessionID
  - TimeOut：会话超时时间，客户端在构造 Zookeeper 实例时，会配置 sessionTimeout 参数用于指定会话的超时时间，Zookeeper 客户端向服务端发送这个超时时间后，服务端会根据自己的超时时间限制最终确定会话的超时时间
  - TickTime：下次会话超时时间点，为了便于 Zookeeper 对会话实行”分桶策略”管理，同时为了高效低耗地实现会话的超时检查与清理，Zookeeper 会为每个会话标记一个下次会话超时时间点，其值大致等于当前时间加上 TimeOut
  - isClosing：标记一个会话是否已经被关闭，当服务端检测到会话已经超时失效时，会将该会话的 isClosing 标记为”已关闭”，这样就能确保不再处理来自该会话的新请求了
- Zookeeper 的会话管理主要是通过 SessionTracker 来负责，其采用了分桶策略（ 将类似的会话放在同一区块中进行管理 ）进行管理，以便 Zookeeper 对会话进行不同区块的隔离处理以及同一区块的统一处理

## 5. 存在缺陷

- 单点故障：
  - 在 ZooKeeper 集群中，Leader 是单点，如果 Leader 节点宕机，会导致整个集群的不可用
  - 尽管选举会尽快选出新的 Leader，但仍然存在短暂的不可用性
- 写入性能：
  - 由于所有的写操作都由 Leader 处理，并且需要进行复制，写入性能可能受到影响，特别是在高负载情况下
- 数据限制：
  - ZooKeeper 的数据模型对于每个节点的数据有一定的大小限制，不适合存储大量的数据
- 复杂性：
  - 虽然 ZooKeeper 提供了强大的功能，但对于一些简单的应用场景，使用 ZooKeeper 可能会增加系统的复杂性
