## 1. 多主模型

- 单主模型一个最大问题：所有写入都要经过它，如果由于任何原因，客户端无法连接到主副本，就无法向数据库写入
- 于是提出多主复制，即一个系统，有多个写入点。允许多个节点接受写入，复制仍然是转发给所有其他节点。每个领导者也是其他领导者的追随者

## 1.1. 应用场景

- 单个数据中心，多主模型意义不大，因为复杂度超过了收益，并且由于一致性等问题难以解决，多主模型应用场景较少
- 但有一些场景，很适合多主模型：
  - 数据库横跨多个数据中心
  - 需要离线工作的客户端
  - 协同编辑

#### 1.2 多个数据中心

- 假设一个数据库的副本，横跨多个数据中心，比如一个在北京，一个在西藏，如果使用单主模型，在写入时的延迟会很大，多住模型允许每个数据中心各配一个主副本
- 每个数据中心内部使用常规的主从复制。而数据中心之间，每个数据中心的主库都会将其更改复制到其他数据中心的主库中
  ![image](https://github.com/user-attachments/assets/e2225160-0088-4e14-80a6-955c51b59485)
- 单主 和 多主，在多数据中心场景下的对比
  ![image](https://github.com/user-attachments/assets/97185d0e-7b44-485a-acfc-3afc5c5cb0e3)
- 但是多主模型在一致性方面有很大缺陷：如果两个数据中心同时修改同样的数据，必须合理解决写冲突。另外，对于数据库来说，多主很难保证一些自增主键、触发器和完整性约束的一致性。**因此在工程实践中，多主用的相对较少**

#### 1.3 离线工作的客户端

- 多主复制的另一适用场景：应用程序在断网后仍然需要继续工作
- 离线工作的一个应用的多个设备上的客户端，如果也允许继续写入数据，则每个设备相当于一个“数据中心”。如：日历应用。在电脑上和手机上离线时如果也支持添加日程，并且在各个设备联网时，需要互相同步数据
- 在这种情况下，每个设备都有一个充当领导者的本地数据库（ 它接受写请求 ），并且在所有设备上的日历副本之间同步时，存在异步的多主复制过程。复制延迟可能是几小时甚至几天，具体取决于何时可以访问互联网
- 其中如何支持离线后正常地工作，然后在联网后优雅的解决冲突，是一个难题
- Apache CouchDB 的一个特点便是支持多主模型

#### 1.4 协同编辑

- 协作式编辑不能视为数据库复制问题，但是与离线编辑有许多相似
- 这种应用允许多人在线同时编辑文档或者电子表格，一个用户编辑文档时，所做的更改将立即应用到其本地副本（ web 或者客户端 ），并异步复制到服务器和编辑同一文档的任何其他用户
- 为了实现协同，并解决冲突，可以：
  - 悲观方式。加锁以避免冲突，但粒度需要尽可能小，否则无法允许多人同时编辑一个文档
  - 乐观方式。允许每个用户无脑写入，然后如果有冲突，交由用户解决
- git 也是一个类似的协议

## 2. 处理写入冲突

- 多主模型最核心的问题是 **如何解决冲突**
  ![image](https://github.com/user-attachments/assets/82f3b79e-d737-46d1-9832-4460fcd78824)
  - 假如两个用户同时修改页面标题，用户 1 将该页面标题从 A 修改到 B；用户 2 将该页面标题从 A 修改到 C
  - 两个操作在本地都修改成功，然后异步同步时，会出现冲突
- 如果要使用基于多主模型的系统，一定要知晓下面提到的问题，多做测试，确保其提供的保证符合使用场景

#### 2.1 界定冲突

- 有些冲突显而易见，并发写同一个 Key
- 有些冲突则更隐晦，比如会议室预定系统。预定同一个会议室不一定会发生冲突，只有预定时间段有交叠，才会有冲突。但是其实本质也是更改了一个 Key，不过这个 Key 由 会议室 + 时间段 组成

#### 2.2 冲突检测

- 有同步或者异步的方式进行冲突检测
- 对于单主模型，当检测到冲突时，由于只有一个主副本，可以同步的检测冲突，从而解决冲突：
  - 让第二个写入阻塞，直到第一个写完成
  - 让第二个写入失败，进行重试
- 但对于多主模型，两个写入可能会在不同主副本立即成功。然后异步同步时，发现冲突，但为时已晚，因此没有办法简单决定如何解决冲突
- 虽然，可以在多主间使用同步方式写入所有副本后，再返回请求给客户端。但这会失掉多主模型的主要优点，允许多个主副本独立接受写入，又退化成单主模型

#### 2.3 冲突避免

- 解决冲突最好的方式是在设计上避免冲突。由于多主模型在冲突发生后再去解决会有很大的复杂度，因此常使用冲突避免的设计
- 假设你的数据集可以分成多个分区，让不同分区的主副本放在不同数据中心中，那么从任何一个分区的角度来看，变成了单主模型
- 比如对于服务全球用户的应用，每个用户就近固定路由到附近的数据中心。那么每个用户信息都有唯一的主副本
- 但如果 用户从一个地点迁移到了另一个地点 或者 某个数据中心损坏导致路由变化，此时就会对该设计提出一些挑战

#### 2.4 冲突收敛

- 在单主模型中，所有事件比较容易进行定序，因此我们总可以用后一个写入覆盖前一个写入
- 但在多主模型中，很多冲突无法定序：从每个主副本来看，事件顺序是不一致的，并且没有哪个更权威一些，那么就无法让所有副本最终收敛（ convergent ）
- 此时就需要一些规则，来让其收敛：
  - 给每个写入一个序号，并且后者胜。本质上是使用外部系统对所有事件进行定序。但可能会产生数据丢失。举个例子，对于一个账户，原有 10 元，客户端 A - 8，客户端 B - 3，任何一个单独成功都有问题
  - 给每个副本一个序号，序号更高的副本有更高的优先级。这也会造成低序号副本的数据丢失
  - 提供一种自动的合并冲突的方式。如，假设结果是字符串，则可以将其排序后，使用连接符进行链接，如在之前标题名的冲突中，合并后的标题为 “B/C”
  - 使用程序定制一种保留所有冲突值信息的冲突解决策略。也可以将这个定制权，交给用户

#### 2.5 自定义解决

- 由于只有用户知道数据本身的信息，因此较好的方式是，将如何解决冲突交给用户。即允许用户编写回调代码，提供冲突解决逻。该回调可以在：
  - 写时执行。在写入时发现冲突，调用回调代码，解决冲突后写入。这些代码通常在后台执行，并且不能阻塞，因此不能在调用时同步的通知用户。但打个日志之类的还是可以的
  - 读时执行。在写入冲突时，所有冲突都会被保留（ 如使用多版本 ）。下次读取时，系统会将所有数据本版本返回给用户，进行交互式的或者自动的解决冲突，并将结果写回系统。
- 上述冲突解决只限于单个记录、行、文档层面

## 3. 多主复制拓扑

- 复制拓扑描述了数据写入从一个节点到另一个节点的传播路径
- 在只有两个主副本时，拓扑是确定的，Leader1 和 Leader2 都得把数据发给对方。但随着副本数的增多，数据复制拓扑就会有多种选择，如下图
  ![image](https://github.com/user-attachments/assets/1d2a4db3-c182-48ac-b05f-043414f21689)
  - 上图表示了大于等于 4 个主副本时，常见的复制拓扑
  - 环形拓扑：通信跳数少，但是在转发时需要带上拓扑中前驱节点信息。如果一个节点故障，则可能中断复制链路
  - 星型拓扑：中心节点负责接受并转发数据。如果中心节点故障，则会使得整个拓扑瘫痪
  - 全连接拓扑：每个主库都要把数据发给剩余主库。通信链路冗余度较高，能较好的容错
- 对于环形拓扑和星型拓扑，为了防止广播一直停止不了，需要对每个节点打上一个唯一标志（ ID ），在收到他人发来的自己的数据时，及时丢弃并终止传播
- 全连接拓扑也有自己问题：尤其是所有复制链路速度不一致时。考虑下面一个例子
  ![image](https://github.com/user-attachments/assets/a32e6034-2581-4ad8-be2f-fbc0838e1fa4)
  - 两个有因果依赖的（ A 先插入，B 后更新 ）的语句，在复制到 Leader 2 时，由于速度不同，导致其接收到的数据违反了因果一致性
- 要想对这些写入事件进行全局排序，仅用每个 Leader 的物理时钟是不够的，因为物理时钟
  - 可能不能够充分同步
  - 同步时可能会发生回退
- 可以用一种叫做 **版本向量** 的策略，对多个副本的事件进行排序，解决因果一致性问题
