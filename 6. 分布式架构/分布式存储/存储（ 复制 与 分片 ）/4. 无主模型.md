## 1. 无主模型

- 有主模型中，由主副本决定写入顺序，从副本在写入上不直接和客户端打交道，只是重放其对应的主副本的写入顺序（ 也可以理解为主副本为从副本的客户端 ）
- 而无主模型，则允许任何副本接受写入
- 在关系数据库时代，无主模型已经快被忘却。从 Amazon 的 Dynamo 论文开始，无主模型又重新大放异彩，Riak，Cassandra 和 Voldemort 都受其启发，可以统称为 Dynamo 流
- 通常来说，在无主模型中，写入时可以：
  - 由客户端直接写入副本
  - 由协调者接收写入，转发给多副本。但与主副本不同，协调者并不负责定序

## 1.1 有节点故障时的写入

- 基于主副本的模型，在主副本故障时，需要进行故障切换。但在无主模型中，简单忽略它就行
  ![image](https://github.com/user-attachments/assets/4994a741-10df-42f4-ab8a-a88b8f2b61fa)
  - 多数派写入，多数派读取，以及读时修复
  - 由于写入时，简单的忽略了宕机副本，因此在读取时就要多做些事情了，需要同时读取多个副本，选取最新版本的值
- 读时修复和反熵

## 1.2 读时修复和反熵

- 无主模型也需要维持多个副本数据的一致性。在某些节点宕机重启后，如何让其弥补错过的数据
- 无主模型的存储中通常有两种机制：
  - 读时修复，本质上是一种捎带修复，在读取时发现旧的就顺手修了
  - 反熵过程，本质上是一种兜底修复，读时修复不可能覆盖所有过期数据，因此需要一些后台进程，持续进行扫描，寻找陈旧数据，然后更新

#### 1.3 一致性监控

- 对副本数据陈旧性监控，能够让你了解副本的健康情况，当其落后太多时，可以及时调查原因
- 基于领导者的多副本模型，由于每个副本复制顺序一致，则可以方便的给出每个副本的落后进度。但对于无主模型，由于没有固定写入顺序，副本的落后进度变得难以界定。如果系统只使用读时修复策略，则对于一个副本的落后程度是没有限制的。读取频率很低数据可能版本很老
- 最终一致性是一种很模糊的保证，但通过监控能够量化 “最终”（ 比如到一个阈值 ），也是很棒的

#### 1.4 多数据中心

- 无主模型也适用于系统多数据中心部署
- 为了同时兼顾多数据中心和写入的低延迟，有一些不同的基于无主模型的多数据中心的策略：
  - 其中 Cassandra 和 Voldemort 将 n 配置到所有数据中心，但写入时只等待本数据中心副本完成就可以返回
  - Riak 将 n 限制在一个数据中心内，因此所有客户端到存储节点的通信可以限制到单个数据中心内，而数据复制在后台异步进行

## 2. Quorum 读写

- Quorum 读写指在分布式系统中对数据进行读取和写入操作时，通过 Quorum（ 法定人数 ）来确保数据的一致性和可用性
- 如果副本总数为 n，写入 w 个副本才认定写入成功，并且在查询时最少需要读取 r 个节点。只要满足 w + r > n，我们就能读到最新的数据（ 鸽巢原理 ）。此时 r 和 w 的值称为 quorum 读写。即这个约束是保证数据有效所需的最低（ 法定 ）票数
  ![image](https://github.com/user-attachments/assets/c9db1464-a420-474c-8eda-ed6b311e1306)
  - n、r 和 w 通常是可以配置的
  - n 越大冗余度就越高，也就越可靠
  - r 和 w 都常都选择超过半数，如 (n + 1) / 2
  - w = n 时，如果让 r = 1，此时就是牺牲写入性能换来读取性能
- 考量满足 w + r > n 系统对节点故障的容忍性：
  - 如果 w < n，则有节点不可用时，仍然能正常写入
  - 如果 r < n，则有节点不可用时，仍然能正常读取
- 特化一下：
  - 如果 n = 3，r = w = 2，则系统可以容忍最多一个节点宕机
  - 如果 n = 5，r = w = 3，则系统可以容忍最多两个节点宕机
- 通常来说，我们会将读或者写并行的发到全部 n 个副本，但是只要等到法定个副本的结果，就可以返回
- 如果由于某种原因，可用节点数少于 r 或者 w，则读取或者写入就会出错

#### 2.1 quorum 一致性的局限

- 由于 w + r > n 时，总会至少有一个节点（ 因为读写子集至少有一个节点的交集 ）保存了最新的数据，因此总是期望能读到最新的
- 当 w + r ≤ n 时，则很可能会读到过期的数据
- 但在 w + r > n 时，有一些特殊情况，也会导致客户端读不到最新数据：
  - 使用宽松的 Quorum 时（ n 台机器范围可以发生变化 ），w 和 r 可能并没有交集
  - 对于写入并发，如果处理冲突不当时。比如使用 last-win 策略，根据本地时间戳挑选时，可能由于时钟偏差造成数据丢失
  - 对于读写并发，写操作仅在部分节点成功就被读取，此时不能确定应当返回新值还是旧值
  - 如果写入节点数 < w 导致写入失败，但并没有对数据进行回滚时，客户端读取时，仍然会读到旧的数据
  - 虽然写入时，成功节点数 > w，但中间有故障造成了一些副本宕机，导致成功副本数 < w，则在读取时可能会出现问题
  - 即使都正常工作，也有可能出现一些关于时序的特殊情况
- 因此，虽然 Quorum 读写看起来能够保证返回最新值，但在工程实践中，有很多细节需要处
- 如果数据库不遵守上一篇副本滞后引入的几个一致性保障，前面提到的异常仍然可能会发生

#### 2.2 放松的 Quorum 和提示转交

- 正常的 Quorum 能够容忍一些副本节点的宕机。但在大型集群（ 总节点数目 > n ）中，可能最初选中的 n 台机器，由于种种原因（ 宕机、网络问题 ），导致无法达到法定读写数目，则此时有两种选择：
  - 对于所有无法达到 r 或 w 个法定数目的读写，直接报错
  - 仍然接受写入，并且将新的写入暂时交给一些正常节点
- 后者被认为是一种宽松的法定数目，写和读仍然需要 w 和 r 个成功返回，但是其所在节点集合可以发生变化
  ![image](https://github.com/user-attachments/assets/2770b5ef-60d1-49c9-bcc9-e54384d31f23)
  - 一旦问题得到解决，数据将会根据线索移回其应该在的节点（ D—> B ），我们称之为提示移交。这个移交过程是由反熵 anti-entropy 后台进程完成的。
  - 这是一种典型的牺牲部分一致性，换取更高可用性的做法。在常见的 Dynamo 实现中，放松的法定人数是可选的。在 Riak 中，它们默认是启用的，而在 Cassandra 和 Voldemort 中它们默认是禁用的

## 3. 并发写入检测

- 由于 Dynamo 允许多个客户端并发写入相同 Key，则即使使用严格的 Quorum 读写，也会产生冲突。比如对于时间间隔很短（ 并发 ）的相同 key 两个写入，不同副本上收到的顺序可能不一致
  ![image](https://github.com/user-attachments/assets/2300cad3-9971-4484-a7f8-3a78f5ddf215)
  - 如果每个节点不去检查顺序，而是简单的接受写入请求，就落到本地，不同副本间可能就会出现永久不一致
  - 上图 Node1 和 Node3 上副本 X 的值是 A，Node2 上副本 X 的值是 B
  - 此外，读时修复和提示移交时，也可能产生冲突

#### 3.1 最后写入胜利（ Last Write Win，LWW ）

- 具体策略是，通过某种手段确定一种全局唯一的顺序，然后让后面的修改覆盖之前的修改。比如，为所有写入附加一个全局时间戳，如果对于某个 key 的写入有冲突，可以挑选具有最大时间戳的数据保留，并丢弃较早时间戳的写入
- 但是 LWW 有一个问题。如果同一个 Key 有多个并发写入，不同写入分别被写入不同的 w 个副本（ 无交集 ），即使它们报告给客户端的都是成功，最终也只有一个写入将存活，而其他写入将被静默丢弃。如果其迅速再读，会发现不是自己写入的数据
- 因此如果丢失数据不可接受，那么最后写入胜利是个很不好的选择
- 使用 LWW 唯一安全的方法是，每一个键只写入一次，然后视为不变，避免并发更新。如 Cassandra 建议使用一个 UUID 作为主键，则每个写操作都只会有一个唯一的键

#### 3.2 先后发生 和 并发

- 只要有两个操作 A 和 B，就有三种可能性：A 在 B 之前发生，或者 B 在 A 之前发生，或者 A 和 B 并发
- 因此需要的是一个算法来告诉我们两个操作是否是并发的
- 如果一个操作发生在另一个操作之前，则后面的操作应该覆盖较早的操作，但是如果这些操作是并发的，则存在需要解决的冲突

#### 3.3 先后发生

- 通过以下算法，可以确定两个操作是否是并发的，还是先后关系，该算法如下
  - 服务器为每个键分配一个版本号 V，每次该键有写入时，将 V + 1，并将版本号与写入的值一块保存
  - 当客户端读取该键时，服务器将返回所有未被覆盖的值以及最新的版本号
  - 客户端在进行下次写入时，必须包含之前读到的版本号 Vx（ 说明基于哪个版本进行新的写入 ），并将读取的值合并到一块
  - 当服务器收到特定版本号 Vx 的写入时，可以用其值覆盖所有 V ≤ Vx 的值
  - 如果又来一个新的写入，不基于任何版本号，则该写入不会覆盖任何内容
- 比如两个客户端同时向一个购物车添加项目，注意版本号
  ![image](https://github.com/user-attachments/assets/c7ca4fb5-135f-4dcd-b885-04ba107954ae)
  - 不会主动读取，只有主动写入，通过写入的返回值读取数据库当前状态
  - 客户端下一次写入，依赖于（因果关系）本客户端上一次写入后获取的返回值
  - 对于并发，数据库不会覆盖，而是保留多个并发值（ 每个 client 一个 ）
- 上图中的数据流，如下图所示。箭头表示先后发生关系。本例中，客户端永远没办法完全获知服务器数据，因为总有另外的客户端进行并发操作。但是旧版本的值会被覆盖，并且不会丢失写入
  ![image](https://github.com/user-attachments/assets/6f8df041-bd97-4f4b-b91b-5cfd8cc1359f)

#### 3.4 合并并发值

- 该算法可以保证所有数据都不会被无声的丢弃。但需要客户端在随后写入时合并之前的值来清理多个值。如果简单基于时间戳进行 LWW，则有些数据又会被丢掉
- 因此需要根据实际情况，选择一些策略来解决冲突，合并数据
  - 比如对于上述购物车中只增加物品的例子，可以使用“并集”来合并冲突数据
  - 但是如果购物车汇总还有删除操作，就不能简单并了，但是可以将删除变为增加（ 写一个 tombstone 标记 ）

#### 3.5 版本向量

- 上面例子只有单个副本。将该算法扩展到无主多副本模型时，只使用一个版本值显然不够，这时需要进行改造
  - 每个副本、每个主键都定义一个版本号
  - 每个副本在处理写入时增加自己的版本号，并且跟踪从其他副本中看到的版本号
  - 这个信息指出了要覆盖哪些值，以及保留哪些值作为并发值
- 版本向量定义为
  - 所有副本的版本号集合称为版本向量（ version vector ）
  - 版本向量允许数据库区分覆盖写入和并发写入
