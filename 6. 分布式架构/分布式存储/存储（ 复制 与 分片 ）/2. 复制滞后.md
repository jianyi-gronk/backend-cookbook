## 1. 复制滞后问题

- 对于读多写少的场景，想象中，可以通过使劲增加读副本来均摊流量。但有个隐含的条件是，多副本间的同步得做成异步的，否则读副本过多，某些副本就很容易出故障，进而阻塞写入
- 但若是异步复制，就会引入不一致问题，即某些副本进度落后于主副本。如果此时不再有写入，经过一段时间后，多副本最终会达到一致（ 最终一致性 ）
- 在实际中，网络通常比较快，副本滞后不太久，也即这个 **“最终”** 通常不会太久，比如 ms 级别，最多 s 级别。但是，对于分布式系统，谁都不敢打包票，由于网络分区、机器高负载等等软硬件问题，在极端情况下，这个最终可能会非常久
- 对于这种最终一致的系统，在工程中，要考虑到由于副本滞后所带来的一致性问题

## 2. 读写一致性

- 异步复制所带来的第一个问题，在一个异步复制的分布式数据库里，**同一个客户端，写入主副本后返回，稍后再去读一个落后的从副本，可能会发现，读不到自己刚写的内容**
  ![image](https://github.com/user-attachments/assets/c50a8cc4-baec-4884-95db-2538e6c45bf4)
- 为了避免这种反直觉的事情发生，需要引入一种新的一致性，即读写一致性
- 若数据库提供这种一致性保证，对于单个客户端来说，就一定能够读到其所写变动。这种一致性是从单个客户端角度来看的一种因果一致性

#### 2.1 实现读写一致性的方案

- 按内容分类
  - 对于客户端可能修改的内容集，只从主副本读取
  - 如社交网络上的个人资料，读自己的资料时，从主副本读取；但读其他人资料时，可以向从副本读
- 按时间分类
  - 如果每个客户端都能访问基本所有数据，则方案一就会退化成所有数据都要从主副本读取，这显然不可接受
  - 此时，可以按时间分情况讨论，近期内有过改动的数据，从主副本读，其他的，向从副本读
  - 那这个区分是否最近的时间阈值（ 比如一分钟 ）如何选取呢？可以监控从副本一段时间内的最大延迟这个经验值，来设置
- 利用时间戳
  - 客户端记下本客户端上次改动时的时间戳，在读从副本时，利用此时间戳来看某个从副本是否已经同步了改时间戳之前内容。时间戳可以是逻辑时间戳，也可以是物理时间戳（ 此时多机时钟同步非常重要 ）
  - 可以在所有副本中找到一个已同步了的
  - 也可以阻塞等待某个副本同步到改时间戳后再读取

#### 2.2 实际复杂情况

- 数据分布在多个物理中心
  - 所有需要发送给主副本的请求都要首先路由到主副本所在的数据中心
- 一个逻辑用户有多个物理客户端
  - 比如一个用户通过电脑、手机多终端同时访问，此时就不能用设备 id，而需要使用用户 id，来保证用户角度的读写一致性。但不同设备有不同物理时间戳，且不同设备访问时可能会路由到不同数据中心

## 3. 单调读

- 异步复制所带来的第二个问题，对于一个客户端来说，系统可能会发生 “时光倒流”，即**第一次请求到从副本看到了评论，第二次请求到另外一个从副本发现评论消失**
  ![image](https://github.com/user-attachments/assets/4d834746-945b-4354-b721-800af4c6631d)
- 单调读保证了这种异常不会发生，方法为
  - 确保每个用户总是从同一副本来读取。比如基于用户 ID 的散列来选择副本，而不是随机选。但是如果该副本失败，则需要路由到另一个副本

## 4. 一致前缀读

- 异步复制所带来的第三个问题，即**有时候会违反因果关系**
- 本质在于，如果数据库由多个分区组成，而分区间的事件顺序无法保证。此时，如果有因果关系的两个事件落在了不同分区，则有可能会出现果在前，因在后
- 为了防止这种问题，再引入一种一致性，一致前缀读
  ![image](https://github.com/user-attachments/assets/4e669e45-6d1c-43b8-9b32-05bc0a47b238)
- 实现这种一致性保证的方法
  - 任何因果相关的写入都写入相同的分区

## 5. 复制延迟的解决方案

- 多副本异步复制所带来的一致性问题，都可以通过事务来解决
- 最开始是单机事务，但数据库走向分布式之后，很多 NoSQL 系统抛弃了事务，因为设计起来非常复杂，于是复杂度被转移到了应用层。现在经验积累的够多，事务必然会被引回，如今越来越多的分布式数据库开始支持分布式事务
