## 1. multirepo 与 monorepo

#### 基础介绍

- multirepo：
  - 每个项目（应用程序、库、服务等）都在自己的独立代码库 repo
  - 共享和重用可能更具挑战性，因为需要跨多个仓库同步代码
  - 维护和更新依赖关系可能更复杂，因为每个项目可能使用不同版本的依赖
  - 跨项目的协作和代码审查可能更困难，因为团队成员需要访问多个仓库
  - 构建和部署策略可能相对简单，因为每个项目都是独立的
- monorepo：
  - 所有项目（应用程序、库、服务等，可能相关，也可能独立）都存储在一个代码库 repo 中
  - 代码共享和重用更容易实现，因为所有代码都位于同一个仓库中
  - 维护和更新依赖关系更简单，因为所有项目都使用相同的依赖版本
  - 跨项目的协作和代码审查更容易进行，因为团队成员可以同时访问所有项目
  - 可能需要更复杂的构建和部署策略，以确保正确处理各种项目之间的依赖关系
  - 有些公司将所有代码放在一个存储库中，供所有人共享，Monorepos 可以达到巨大的尺寸，例如，谷歌理论上拥有有史以来最大的代码存储库，每天有数十个提交，超过 80 tb。其他使用 Monorepos 的公司还有微软、Facebook 和 Twitter
- 从 multirepo 到 monorepo，需要将所有的项目移动到一个存储库中
  <img src="https://img-blog.csdnimg.cn/403fa634879746be972a72a992c4082b.png">

#### monorepo 的优缺点

- monorepo 优点
  - 可见性：每个人都可以看到其他人的代码，这样可以带来更好的协作和跨团队贡献——不同团队的开发人员都可以修复代码中的 bug，而你甚至都不知道这个 bug 的存在
  - 更简单的依赖关系管理：共享依赖关系很简单，因为所有模块都托管在同一个存储库中，因此都不需要包管理器
  - 唯一依赖源：每个依赖只有一个版本，意味着没有版本冲突，没有依赖地狱
  - 一致性：当把所有代码库放在一个地方时，执行代码质量标准和统一的风格会更容易
  - 共享时间线：API 或共享库的变更会立即被暴露出来，迫使不同团队提前沟通合作，每个人都得努力跟上变化
  - 原子提交：原子提交使大规模重构更容易，开发人员可以在一次提交中更新多个包或项目
  - 隐式 CI：因为所有代码已经统一维护在一个地方，因此可以保证持续集成
  - 统一的 CI/CD：可以为代码库中的每个项目使用相同的 CI/CD 部署流程
  - 统一的构建流程：代码库中的每个应用程序可以共享一致的构建流程
- monorepo 缺点
  - 随着单一代码库的发展，我们在版本控制工具、构建系统和持续集成流水线方面达到了设计极限（代码太多了，仓库变得很庞大，复杂）。这些问题可能会让一家公司走上多代码库的道路
  - **性能差**：单一代码库难以扩大规模，像 git blame 这样的命令可能会不合理的花费很长时间执行，IDE 也开始变得缓慢，生产力受到影响，对每个提交测试整个 repo 变得不可行，比如就想改一个翻译问题，需要拉下来几十 G 的代码，这谁受的了啊
  - **破坏主线**：主线损坏会影响到在单一代码库中工作的每个人，这既可以被看作是灾难，也可以看作是保证测试既可以保持简洁又可以跟上开发的好机会
  - 学习曲线：如果代码库包含了许多紧密耦合的项目，那么新成员的学习曲线会更陡峭
  - 大量的数据：单一代码库每天都要处理大量的数据和提交
  - 所有权：维护文件的所有权更有挑战性，因为像 Git 或 Mercurial 这样的系统没有内置的目录权限
  - 代码审查：通知可能会变得非常嘈杂。例如，GitHub 有有限的通知设置，不适合大量的拉取请求和代码审查

#### monorepo 的推广程度

- 比较大型的软件开发公司，比如说 Google, Uber, Netflix 他们都在使用 monorepo
- 许多开源项目已经成功使用了单一代码库，例如：
  - Babel：一个用户 Web 开发的流行的 JavaScript 编译器，其单一代码库包含了完整的项目及其所有插件
  - React、Ember 和 Meteor 等前端框架都使用单一代码库
  - Laravel：一个用于 Web 开发的 PHP 框架
  - Symfony：一个用 PHP 编写的 MVC 框架。有趣的是，他们已经为每个 Symfony 工具和库创建了只读存储库，这种方法被称为分库（split-repo）
  - NixOS：一个用单一代码库发布包的 Linux 发行版

#### 举例（ 编的 ）

- 就比如之前所在的公司，采用的是 multirepo 模式，每个项目分开进行管理
  - 这就造成了，公司虽然为了打包方便，实现可视化打包流程自动化，但存在很多歌打包流程，因为不同基线上的打包流程有很大差异，所以需要记下不同开发基线，所对应的不同打包流，所以非常影响开发体验，并且编写这些不同打包脚本，也很花费精力时间
  - 并且有时候想让一个项目正常运行，要想使整个项目运行完整，可能需要下载多个模块，然后再通过固定的搭配方式，比如把某个模块放到某个文件中，才能正常运行，这个过程也很麻烦，需要特意去记
  - 并且当其中一个模块出现了问题，可能就直接影响到了整个项目的其他模块的运行，很麻烦
- 有的可能会考虑 monorepo 导致太大的代码，但像 google 这样的大公司他们都用自己的代码管理系统，那一个程序员要修改一个模块的代码的时候，他需要把所有的项目代码都下载到本地来，并获取最新的代码。做一个修改以后，check in 完成就会进行整个项目的编译。整个项目可能需要两个小时的编译时间，这个时候，这个程序员可以跟别人聊聊天，可以学点东西，这也是很好的一种程序员生活。在 monorepo 的开发模式下，这是一个非常常见的工作状态
- multirepo 跟微服务架构理念相似
  - 通过这个分解，每一个小部分作为一个单独的 repo。每个 repo，可以分给不同的小组来开发和管理。每个小组只需要关心这一小部分工作就可以了。每一个小的部分都可以单独的进行买酒测试和开发。这个是好的一个方面
  - 下面来说一个坏的方面。因为每个小组可以各自为战。这样就给协同工作带来很大的问题。比如说一个小组的模块进行了升级，导致现有的大系统其他模块儿无法正常工作。这种现象在微服务架构系统的开发中非常常见
  - 如果把这个坏的方面再发挥到极致，就是每个组件之间互相依赖互相破坏，这样子你整体系统可能就陷入万劫不复的深渊。也就是说，随着微服务架构，继续把模块儿进细化，每个模块失去了紧密的联系，与此同时又没有很好的管理机制把握全局， 导致整个项目开发失去了控制，这也是很多微服务架构系统失败的原因
  - 所以在 multirepo 的开发过程中，非常重要的一点就是避免过度的细分。一定要有一个机制来把握全局，时刻监控整个开发环境是否正常
- 选择 Monorepo 还是 Multirepo 取决于项目的需求和团队的偏好。Monorepo 更适合大型企业级应用程序，需要跨多个项目共享和重用代码，以及更紧密的团队协作。而 Multirepo 则更适合小型项目和独立的应用程序，需要独立的开发和部署周期

## 2. Nx

#### 基础介绍

- Nx 是一个可扩展的开发工具集，可以帮助团队更高效地构建现代化的前端应用。由 Nrwl（来自 Angular 团队成员的公司）开发，主要用于优化大型企业级应用程序的开发过程。Nx 提供了一系列工具和功能，以简化开发过程并确保应用程序的质量
- 以下是 Nx 的一些关键特性：
  - 代码共享和组织：Nx 使用 Monorepo（单一代码库）的概念，它提供了一种简单的方法来组织和共享代码，以便在多个应用程序和库之间重用。这有助于保持代码的一致性，减少重复，并促进团队间的协作
  - 生成器和执行器：Nx 提供了一个丰富的生成器和执行器生态系统，可以帮助开发人员轻松创建、构建、测试和部署应用程序。生成器可以用于自动创建新的组件、模块和服务，而执行器则可以用于运行各种任务，如构建、测试和部署
  - 构建缓存：Nx 通过使用分布式缓存来加速构建过程。这意味着如果某个任务已经在其他开发人员的机器上执行过，那么其他开发人员可以直接从缓存中获取结果，而无需重新执行该任务。这大大减少了构建时间，提高了团队的生产力
  - 依赖图：Nx 提供了一个可视化工具，用于显示应用程序和库之间的依赖关系。这有助于开发人员理解代码的结构，更容易地进行更改和重构
  - 高度可扩展：Nx 是一个高度可扩展的平台，可以轻松地集成各种前端框架和技术。这包括 Angular、React、NestJS、Express 等。这意味着你可以在同一个项目中使用多种技术，而无需担心兼容性问题

#### 基础使用（[详情](https://nx.dev/packages/nx/documents)）

- create-nx-workspace [name] [options]
  - 用来创建一个新的 Nx 工作空间
  - 常用选项
    - --preset：可以选择一个预先配置的工作空间模板，以便为特定类型的项目创建初始结构，预设值包括：["apps", "empty", "core", "npm", "ts", "web-components", "angular-monorepo", "angular-standalone", "react-monorepo", "react-standalone", "next", "nextjs-standalone", "react-native", "expo", "nest", "express", "react", "angular", "node-standalone", "node-monorepo", "ts-standalone"]
    - --ci：生成 CI 工作流文件。可选值：github、circleci、azure、bitbucket-pipelines 和 gitlab
    - --bundler：用于构建应用的打包工具
    - --workspaceType：要创建的工作空间类型。可选值：integrated、package-based 和 standalone
    - --nxCloud：启用分布式缓存以加快 CI 速度
- nx generate \<collection:generator\> [options]
  - 运行生成器，该生成器基于集合中的生成器创建和/或修改文件
  - 常用生成器（Nx 15 或者 更低的版本，需要用 @nrwl 代替 @nx）
    - nx generate @nx/angular:app myapp：生成一个新的 angular 应用
    - nx generate @nx/react:app myapp：生成一个新的 react 应用
    - nx generate @nx/web:app myapp：生成一个新的 web component 应用
    - nx generate @nx/node:app myapp：生成一个新的 node 应用
    - nx generate @nx/angular:library mylibrary：生成一个新的 angular library
    - nx generate @nx/react:library mylibrary：生成一个新的 react library
    - nx generate @nx/node:library mylibrary：生成一个新的 node library
- nx run-many [options]
  - 因为 Nx 通常管理多个项目，所以我们可能需要同时运行工作空间中多个项目
  - 常用选项
    - --target：要运行的目标，必须指定（例如：build、test、lint 等）
    - --all: （默认为 true，已弃用）在工作空间中的所有项目上运行目标
    - --projects：要运行的项目列表，以逗号分隔，不使用该选项时，默认运行所有项目（例如：app1,app2,lib1）
    - --exclude：排除某些项目，不进行处理
    - --graph: 显示命令的任务图。将文件路径传递给该选项以将图数据保存为文件，而不是在浏览器中查看
    - --nx-bail：（默认为 false）在第一个任务失败后停止命令执行
    - --parallel：（值为 string，默认为 3，也可以设置为 false，使项目串行运行）可限制并行进程的最大数量，这可以加快执行速度，但也会增加资源使用
    - --output-style: 定义 Nx 如何输出任务日志。可选值包括：dynamic、static、stream 和 stream-without-prefixes
