## 1. 介绍

- Makefile 文件用于指导 GNU Make 脚本工具进行自动化构建，它定义了一系列规则和变量，用来描述如何将源代码编译成可执行文件、库文件或其他目标文件
- Makefile 能够管理依赖关系，可以检测文件之间的依赖关系，并确保在修改源文件后只重新编译受影响的文件，而不是整个项目
- 通过 Makefile，开发者可以使用简单的 make 命令来构建整个项目，而不必手动执行一系列复杂的编译命令

## 2. 变量

#### 基础介绍

- Makefile 存在多种变量赋值方式
- Makefile 中内置的特殊变量，具有固定的含义和用途，可以在 Makefile 中直接使用或者对其进行自定义和覆盖
- Makefile 中环境变量用于自定义构建过程、控制编译器和链接器的行为
  - 可以从外部通过命令行参数传入 make 命令的环境变量，如果没有传递参数，默认的环境变量值是空字符串或系统默认值
  - 可以通过赋值符号赋值或者修改值
  - 可以直接在 Makefile 中直接使用

#### 变量赋值

- = ：简单赋值符号，将变量设置为指定的值。每次使用变量时，都会重新计算其值
  ```
  VAR = value
  ```
- := ：延迟赋值符号，也被称为“覆写符号”。在整个 Makefile 的执行过程中，只会在赋值时立即展开，只执行一次计算操作，后续使用该变量时，不会重新计算其值
  ```
  VAR := value
  ```
- ?= ：条件赋值符号，如果变量未定义，则将其设置为指定的值。如果变量已定义，则保持原来的值不变
  ```
  VAR ?= value
  ```
- += ：追加赋值符号，用于向变量的末尾追加值。如果变量未定义，则会被视为空
  ```
  VAR += value
  ```
- ::= ：将变量设置为指定的值，类似于 = 赋值符号。但是，如果变量已经定义过，则会发出警告
  ```
  VAR ::= value
  ```
- ?!= ：执行命令并将命令的输出结果赋值给变量。类似于 := 赋值符号，但是右侧的命令会被解析并执行
  ```
  VAR ?!= command
  ```
- != ：执行命令并将命令的输出结果赋值给变量。每次使用变量时，都会重新执行命令获取最新的输出结果
  ```
  VAR != command
  ```

#### 自动变量

- $@：表示目标文件（Target），即规则中的目标项
- $<：表示第一个依赖文件（Prerequisite），即规则中的第一个依赖项
- $^：表示所有的依赖文件列表，即规则中的所有依赖项
- $?：表示比目标文件新的所有依赖文件列表
- $\*：表示匹配到的目标文件名称（不包含后缀）
- $(@D)：表示目标文件所在的目录
- $(@F)：表示目标文件的文件名部分（不包含目录）。

#### 特殊变量

- $(MAKE)：值默认被设置为 make，即执行 make 命令的可执行文件名，可当作 make 命令使用
- $(MAKEFILE_LIST)：包含了当前 Makefile 及其所有被包含的 Makefile 的文件名列表
- $(CURDIR)：表示当前工作目录的路径
- $(PWD)：表示当前工作目录的路径，与 $(CURDIR) 一样
- .DEFAULT_GOAL：用于设置默认目标，在运行 make 命令而没有指定目标时执行该默认目标
  - 比如直接命令行运行 make 时，没指定运行目标的时候，默认运行 make $(.DEFAULT_GOAL)
  - 例
    ```
    .DEFAULT_GOAL := all
    ```
    - 通过执行 make all 命令，可以自动化地执行所有必要的步骤来构建整个项目，而无需手动执行每个步骤
- .SHELLFLAGS：这个值会默认地添加在通过 Makefile 执行的所有 shell 命令的后面
  - 意味着无需手动为每个命令指定相同的标志和选项，而是定义一次 .SHELLFLAGS 即可应用于所有命令
  - 通常定义例如 错误处理、未定义变量的处理方式 等等
  - 例
    ```
    .SHELLFLAGS := -e -u -o pipefail -c
    ```
    - -e（或 --errexit）：当命令返回非零退出状态码时，立即终止脚本的执行。这可以帮助在构建过程中及时捕获错误并停止继续执行
    - -u（或 --nounset）：如果引用了未定义的变量，则会导致脚本中止。这有助于防止使用未初始化的变量造成潜在的错误
    - -o pipefail：在通过管道连接多个命令时，如果任何一个命令失败，则整个管道命令的返回值将是失败。这有助于确保正确处理管道中的错误
    - -c：告诉 shell 程序选取下一个命令参数（ 字符串 ）作为命令输入，而不是从标准输入或者从一个给定的文件中读命令

#### 环境变量

- CC：指定 C 编译器的名称或路径
- CXX：指定 C++ 编译器的名称或路径
- CFLAGS：指定 C 编译器的额外参数
- CXXFLAGS：指定 C++ 编译器的额外参数
- LDFLAGS：指定链接器的额外参数
- LDLIBS：指定要链接的库文件
- AR：指定静态库生成工具（ 通常是 ar ）的名称或路径
- ARFLAGS：指定静态库生成工具的额外参数
- MAKEFLAGS：包含传递给 make 命令的标志和选项
- MAKECMDGOALS：保存 make 命令的目标列表
- MAKELEVEL：表示当前 make 的递归层级
- MFLAGS：即将废弃，可使用 MAKEFLAGS 替代，用于传递 make 的标志和选项
- CURDIR：表示当前工作目录的绝对路径
- SHELL：指定用于执行命令的 Shell 解释器（ 默认是 /bin/sh ）
- VPATH：指定查找源文件的路径列表
- 如果想手动添加变量值，但又不想影响传入的参数，可以通过 +=，例
  ```
  MAKEFLAGS += --warn-undefined-variables
  MAKEFLAGS += --no-builtin-rules
  MAKEFLAGS += --no-print-directory
  ```

## 3. 函数

#### 内置函数

- 字符串处理函数：
  - $(subst from,to,text)：将字符串 text 中的 from 替换为 to
  - $(patsubst pattern,replacement,text)：使用模式匹配将字符串 text 中符合 pattern 的部分替换为 replacement
  - $(strip string)：去除字符串 string 开头和结尾的空格
  - $(findstring find,in)：在字符串 in 中查找子串 find，如果存在返回 find，否则返回空
- 文件处理函数：
  - $(wildcard pattern)：匹配符合 pattern 的文件列表
  - $(foreach variable,list,text)：对列表 list 中的每个元素，将其赋值给变量 variable，然后展开 text
  - $(shell command)：执行 shell 命令 command，并返回输出结果
- 变量处理函数：
  - $(eval text)：解析 text 中的变量和规则，并执行相应的操作
  - $(if condition,then-part,else-part)：如果 condition 为非空字符串，则返回 then-part，否则返回 else-part
- 调用自定义函数：
  - $(call function,arg1,arg2,...)：调用自定义的函数 function，并传递参数 arg1、arg2 等
- 其他函数：
  - $(error text)：输出错误信息并终止 make 执行
  - $(warning text)：输出警告信息，但继续执行 make

#### 自定义函数

- 可以使用 define 关键字指定函数的名称和内容，在通过内置函数 call 来调用自定义函数

  ```
  # 定义自定义函数
  define my_function
      @echo "Hello, $(1)!"
  endef

  # 调用自定义函数
  my_rule:
      $(call my_function,world)
  ```

## 4. 规则

#### 基础介绍

- 规则描述了如何根据依赖文件生成目标文件，并定义了执行所需命令的步骤
- 一个规则结构通常由以下部分组成：
  - 目标（ Target ）：规则所要生成或更新的文件或操作的名称。目标是规则的核心，也是规则被执行时的最终产物
  - 依赖（ Prerequisite ）：生成目标所需要的文件或操作的列表。依赖指定了目标所依赖的其他文件，当这些依赖发生变化时，目标可能需要重新生成。根据依赖关系，Make 工具会按照正确的顺序执行依赖项的规则，然后再执行目标规则
  - 命令（ Command ）：执行生成目标的具体命令行。命令描述了将依赖转化为目标的步骤，每一行都以一个制表符或多个空格字符开头
- 规则的执行遵循以下原则：
  - 如果目标文件不存在，或者目标的依赖文件的时间戳比目标的时间戳更晚，那么命令将会被执行
  - 如果目标的依赖文件有更新，那么目标将会被重新生成
  - 如果目标和依赖都存在，且目标的时间戳比依赖的时间戳更晚，那么命令将不会被执行，规则也会被视为已经执行
- 可以创建多个规则，再通过依赖，让所有规则按指定顺序执行，从而实现整体自动化构建流程

#### 特殊目标

- .PHONY：用于定义伪目标。伪目标是一种不代表实际文件的目标，通常用于指定一些操作而不涉及实际文件生成的情况，常见的包括 清理操作（ clean ）、测试操作（ test ）、安装操作（ install ）等，例
  ```
  .PHONY: clean
  clean:
      rm -rf build/
  ```
- .DEFAULT：指定默认目标，当没有显式指定目标时，会执行默认目标下的命令
  ```
  .DEFAULT:
      @echo "This is the default target."
  ```
- .SUFFIXES：定义伪目标 .SUFFIXES 后面跟随一系列后缀名，用于指定默认的文件后缀规则
- .PRECIOUS：指定某些文件为宝贵文件，防止被 Make 工具自动删除
- .INTERMEDIATE：指定某些文件为中间文件，Make 在完成目标生成后会自动删除这些中间文件
- .SECONDARY：指定某些文件为次要文件，当这些文件为生成目标的依赖项时，make 不会自动删除它们，即使它们未被其他目标使用

#### 自定义规则

- target 是目标文件，dependency1 和 dependency2 是它的依赖文件，command1 和 command2 是用于生成目标文件的命令
  ```
  target: dependency1 dependency2
      command1
      command2
  ```
- 例，Make 工具会首先检查 dependency1 和 dependency2 的状态。如果它们的状态需要更新，则会依次执行相应的规则。只有当所有依赖项的规则执行完毕后，才会执行目标 target 的规则

  ```
  target: dependency1 dependency2
      echo "Executing target rule"
      # 执行目标规则的命令

  dependency1:
      echo "Executing dependency1 rule"
      # 执行依赖1规则的命令

  dependency2:
      echo "Executing dependency2 rule"
      # 执行依赖2规则的命令
  ```

#### 模式规则

- 模式规则用于指定一类具有相同模式的文件的构建规则。它是一种通配符规则，可以方便地处理多个源文件和目标文件之间的依赖关系
  ```
  targets: target-pattern: prerequisite-patterns
      recipe
  ```
  - targets 是目标文件的列表，表示需要生成的目标文件
  - target-pattern 是目标文件名的模式，其中可以使用 % 符号作为通配符，表示匹配任意字符序列
  - prerequisite-patterns 是依赖文件名的模式，用于指定目标文件所依赖的文件。也可以使用 % 通配符表示匹配任意字符序列
  - recipe 是生成目标文件的命令，也就是执行构建操作的命令
- 当执行模式规则时，Make 工具会根据目标文件和依赖文件的模式匹配来确定需要执行的规则。它会自动推导出符合模式的具体文件名，并根据依赖关系来生成目标文件
- 例

  - %.o: %.c 是一个模式规则，它指定了将任意的 .c 文件编译为对应的 .o 文件。通过使用 $< 和 $@ 来引用依赖文件和目标文件的名称
  - test 是一个普通的目标规则，它依赖于 program。program 的依赖文件是 file1.o 和 file2.o，当这两个依赖文件更新时，Make 工具会根据模式规则自动推导生成对应的目标文件。
  - 通过运行 make 命令，可以执行 Makefile 中定义的规则，例如 make test 可以构建项目

  ```
  # 模式规则
  %.o: %.c
      gcc -c $< -o $@

  # 目标规则
  all: program

  program: file1.o file2.o
      gcc file1.o file2.o -o program

  clean:
      rm -f *.o program
  ```

## 5. 其他语法

- 条件语句：可以根据条件执行不同的命令。语法如下
  ```
  ifeq (arg1, arg2)
      ...
  else ifeq (arg3, arg4)
      ...
  else
      ...
  endif
  ```
  - 例
    ```
    # 根据操作系统类型选择不同的删除文件命令
    ifeq ($(OS), Windows_NT)
        RM = del /Q
    else
        RM = rm -f
    endif
    ```
- 包含其他 Makefile：可以使用 include 语句将其他 Makefile 文件包含到当前 Makefile 中。这对于模块化和重用 Makefile 代码非常有用。例
  ```
  include common.mk
  ```

## 6. 小技巧

- 静默模式：
  - 在 Shell 命令前加上 @ 可以让命令在执行时不打印到控制台。这在你希望避免显示冗长或不必要的输出时非常有用。例
  ```
  # 执行 make clean 时，rm -f *.o 命令将不会显示在控制台
  clean:
      @rm -f *.o
  ```
- 忽略失败：
  - 在 Shell 命令前加上 - 可以起到了忽略命令执行失败并继续执行的作用
  ```
  # 执行 make clean 时，rm -f *.o 命令将不会显示在控制台
  clean:
      -rm -f *.o
  ```
- 依赖本身：
  - 当规则的依赖值为 Makefile 的时候，表示目标文件依赖于 Makefile 文件本身
  - 通过这种方式，Make 工具可以确保目标文件在生成时始终基于最新的 Makefile 内容进行构建，以保持构建过程的一致性和可靠性
  - 常用于 根据 Makefile 中的设置生成配置文件、更新依赖关系、调用其他生成工具等 场景
  ```clike
  .bin/test: Makefile
    ...
  ```
