## 1. 编程设计模式

#### 基础介绍

- 主要用于优化代码结构，解决特定的问题或场景。这类设计模式有助于提高代码的模块化、可维护性和可扩展性
- 不同编程语言的设计模式本质上是相同的，无论使用哪种编程语言，我们都可以使用相同的设计模式来解决相似的问题。例如，单例模式、工厂模式和观察者模式等基础设计模式在大多数编程语言中都有相应的实现
- 但是，不同的编程语言可能会使用不同的语法和语言特性来实现相同的设计模式。例如，Java 中的观察者模式使用接口和抽象类来定义观察者和主题，而 JavaScript 中则使用回调函数和事件发射器来实现相同的功能
- 此外，某些编程语言可能具有独特的设计模式，这些模式可能只适用于该语言或特定领域。例如，Swift 中引入了 MVVM 模式，用于构建 iOS 应用程序的用户界面，而在其他编程语言中可能没有这种模式

#### 具体设计模式

- 工厂模式（Factory Pattern）：通过一个共同的方法，再根据条件或参数，来动态创建一系列相似的对象，而无需指定它们的具体类，使用工厂模式可以将对象的创建过程封装起来，并帮助我们避免代码重复

  - 构造函数就类似于工厂模式的思想，通过传入不同的参数创建不同的对象，但是还是存在差异，因为构造函数只能创建一种类型的对象，只是不同对象身上的属性可以不同，而工厂模式的思想是可以创建任意类型的对象

  ```
  // 创建了一个 EmployeeFactory 对象，该对象的 create() 方法根据类型参数返回相应的对象实例

  function Developer(name, type) {
      this.name = name;
      this.type = type;
  }

  function Designer(name, type) {
      this.name = name;
      this.type = type;
  }

  function EmployeeFactory() {
      this.create = (name, type) => {
        switch(type) {
            case 'developer':
              return new Developer(name, type);
              break;
            case 'designer':
              return new Designer(name, type);
              break;
        }
      }
  }

  const employeeFactory = new EmployeeFactory();
  const employees = [
    // 类似于工厂，传入不同的参数（ 原材料 ），就能返回一个新的对象（ 成品 ），中间的过程被封装起来，不需要知道
      employeeFactory.create('John', 'developer'),
      employeeFactory.create('Jane', 'designer'),
      employeeFactory.create('Jack', 'developer'),
  ];
  ```

- 单例模式（Singleton Pattern）：确保一个类只有一个实例，且提供一个全局访问点来访问该实例，该模式在 JavaScript 中的应用非常广泛

  - 比如 jQuery 就是一个单例

  ```
  // 创建了一个 Singleton 对象，该对象的 getInstance() 方法返回单例实例
  // 如果已经创建了单例，则直接返回该实例，否则，将创建新的实例并返回

  var Singleton = (function() {
    // 利用闭包保存实例，在内存中不会被回收，保证每次调用都是返回同一个实例
      var instance;

      function createInstance() {
        var object = new Object("I am the instance");
        return object;
      }

      return {
        getInstance: function() {
            if (!instance) {
              instance = createInstance();
            }
            return instance;
        }
      };
  })();

  function run() {
    // 获得的是同一个实例对象
      var instance1 = Singleton.getInstance();
      var instance2 = Singleton.getInstance();

      alert("Same instance? " + (instance1 === instance2));
  }
  ```

- 观察者模式（Observer Pattern）：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象发生变化时，它会通知所有的观察者对象，使它们能够自动更新自己的状态

  - Vue 的响应式采用了观察者模式思想，在 Vue 中，每个组件都有一个对应的 Watcher 实例对象，当组件数据发生变化时，数据对应的依赖收集器会发送给所有依赖于它的 Watcher 实例通知，让 Watcher 调用相应的更新函数来更新视图；Promise 其实也是基于观察者模式的，Promise 对象可以注册多个回调函数（观察者），并在异步操作完成后通知这些回调函数执行相应的任务；RxJS 也是基于观察者模式的

  ```
  // 创建了一个 Subject 对象和一个 ObserverList 对象，用于跟踪并通知所有的观察者
  // 每次主题对象发生变化时，它会调用 notify() 方法

  // 依赖收集器，用来跟踪哪些观察者已经注册到哪些被观察者上
  function ObserverList() {
      this.observerList = [];
  }

   // 在依赖收集器中添加 Watcher
  ObserverList.prototype.add = function(obj) {
      return this.observerList.push(obj);
  };

   // 通过 index 获取依赖收集器中的指定 Watcher
  ObserverList.prototype.get = function(index) {
      if (index > -1 && index < this.observerList.length) {
        return this.observerList[index];
      }
  };

   // 获取依赖收集器中 Watcher 的数量
  ObserverList.prototype.count = function() {
      return this.observerList.length;
  };

   // 主题对象
  function Subject() {
    // 该主题对象对应的依赖收集器
      this.observers = new ObserverList();
  }

  Subject.prototype.addObserver = function(observer) {
    this.observers.add(observer);
  };

   // 通知依赖收集器中的 观察者们 去进行更新操作
  Subject.prototype.notify = function(context) {
    var observerCount = this.observers.count();
    // 其实就是去遍历依赖收集器，让其中所有的 Watcher 进行 update 操作
      for(var i=0; i < observerCount; i++) {
        this.observers.get(i).update(context);
      }
  };

   // 定义 Watcher 的操作
  function Observer() {
      this.update = function() {
        // ...
      };
  }
  ```

- 策略模式（Strategy Pattern）：定义一系列算法，将每一个算法都封装起来，并且使它们可以相互替换，使得算法可独立于使用它的客户而变化

  - 比如 Array.sort()，可以指定不同算法来进行排序

  ```
  // 创建 strategy 对象，包含各种算法定义，根据参数动态的调用不同算法

  // 创建策略对象
  const strategy = {
      addition: function (num1, num2) {
        return num1 + num2;
      },
      subtraction: function (num1, num2) {
        return num1 - num2;
      },
      multiplication: function (num1, num2) {
        return num1 * num2;
      },
      division: function (num1, num2) {
        return num1 / num2;
      }
  };

  // 定义策略函数
  function calculate(num1, num2, operation) {
      if (!strategy[operation]) {
        throw new Error('Invalid operation');
      }

      return strategy[operation](num1, num2);
  }

  // 使用策略函数计算结果
  console.log(calculate(10, 5, 'addition')); // 15
  console.log(calculate(10, 5, 'subtraction')); // 5
  console.log(calculate(10, 5, 'multiplication')); // 50
  console.log(calculate(10, 5, 'division')); // 2
  ```

- 代理模式（Proxy Pattern）：允许你提供一个在某些对象或者操作前后添加额外处理逻辑的中介代理对象，从而控制对对象的访问，可以限制对敏感资源的访问（ 不可以直接访问实际操作对象 ）、提高系统性能（ 代理模式内可以缓存目标对象的结果 ）、转移业务责任（ 代理模式可以将一些非核心业务逻辑转移到代理对象中实现 ）等

  - 比如，Proxy（ 该函数会返回一个新的对象，它将拦截对目标对象的访问，并执行特定的操作 ），vuex 都采用了代理模式的思想（ 拦截对 state 对象的访问，在 mutation 进行业务逻辑处理 ）

  ```
  // 定义一个目标对象
   class RealSubject {
        request() {
            console.log("RealSubject handles request.");
        }
    }

    // 定义一个代理对象
    class ProxySubject {
        constructor() {
            this.realSubject = new RealSubject();
        }

        request() {
          // 在目标对象的基础上，包装了很多业务逻辑
            if (this.checkAccess()) {
              this.realSubject.request();
              this.logAccess();
            }
        }

        checkAccess() {
            console.log("ProxySubject: Checking access prior to firing a real request.");
            return true;
        }

        logAccess() {
            console.log("ProxySubject: Logging the time of request.");
        }
    }

    // 使用代理对象调用方法
    const proxy = new ProxySubject();

  // 只能通过代理对象才能访问到目标对象身上的属性和方法
    proxy.request();
  ```

- 装饰器模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责，代码扩展性强，可避免使用子类进行扩展
- 命令模式（Command Pattern）：将请求封装成对象，从而允许我们使用不同的请求、队列或日志请求来参数化其他对象，也支持可撤销操作
- 模板方法模式（Template Method Pattern）：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变算法结构的情况下重新定义算法中某些步骤
- 职责链模式（Chain of Responsibility Pattern）：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有一节点处理该请求为止
