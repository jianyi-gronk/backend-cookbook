## 1. TCP（ Transmission Control Protocol，传输控制协议 ）

#### 1.1 基础介绍

- TCP 是一种面向广域网的通信协议，目的是在跨越多个网络通信时，为两个通信端点之间提供通信方式，特点如下：
  - 面向连接：
    - 一定是一对一才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息
    - 并且通信连接维护是面向通信的两个端点的，而不考虑中间网段和节点
  - 可靠的：
    - 无论的网络链路中出现了怎样的链路变化，TCP 都可以保证报文一定能够到达接收端
  - 字节流：
    - 用户消息通过 TCP 协议传输时，消息可能会被操作系统分组成多个的 TCP 报文，如果接收方的程序如果不知道 “消息的边界”，是无法读出一个有效的用户消息的
    - 并且 TCP 报文是有序的，当前一个 TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对重复的 TCP 报文会自动丢弃
- TCP（ 传输控制协议 ）是基于 IP（ 互联网协议 ）的，而 IP 本身是一种无连接、不可靠的协议
  - 这意味着在 IP 网络中，数据包可能会因为网络拥塞、丢包或其他原因而丢失、到达顺序错乱或重复到达
  - 所以 TCP 通过在其上层引入可靠性机制，例如 **到达确认，重传机制（ 总共有 超时重传，快速重传，SACK，D-SACK 四种 ），传输错误处理，滑动窗口** 等操作，来弥补 IP 协议的不可靠性

#### 1.2 四元组

- TCP 四元组可以唯一的确定一个 TCP 连接，四元组包括如下：
  ![image](https://i-blog.csdnimg.cn/blog_migrate/f8bbeda1fcbbdbae814a30549259a5b9.png)
- 源地址和目的地址的字段（ 32 位 ）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机
- 源端口和目的端口的字段（16 位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程

#### 1.3 TCP 头部格式

![image](https://i-blog.csdnimg.cn/blog_migrate/003be4950bae37588d20030c7a5f76cc.png)

- 序列号：
  - 在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就累加一次该数据字节数的大小
  - 可用来解决网络包乱序问题
- 确认应答号：
  - 指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已被正常接收
  - 可用来解决丢包的问题
- 控制位：
  - ACK：该位为 1 时，”确认应答” 的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1
  - RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接
  - SYN：该位为 1 时，表示希望建立连接，并在其 “序列号” 的字段进行序列号初始值的设定
  - FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段

### TCP 连接前提

- 建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识
  - Socket：由 IP 地址和端口号组成
  - 序列号：用来解决乱序问题等
  - 窗口大小：用来做流量控制

## 2. 到达确认

### 序列号

- TCP 数据包中的序列号（ Sequence Number ）不是以报文段来进行编号的，而是将连接生存周期内传输的所有数据当作一个字节流，序列号就是整个字节流中每个字节的编号
- 一个 TCP 数据包中包含多个字节流的数据（ 即数据段 ），而且每个 TCP 数据包中的数据大小不一定相同
- 在建立 TCP 连接的三次握手过程中，通信双方各自已确定了初始的序号 x 和 y，TCP 每次传送的报文段中的序号字段值表示所要传送本报文中的第一个字节的序号

### 基础介绍

- TCP 的报文到达确认（ ACK ），是对接收到的数据的最高序列号的确认，并向发送端返回一个下次接收时期望的 TCP 数据包的序列号（ ACK Number ）
- 例如，主机 A 发送当前数据序号是 400，数据长度是 100，则接收端收到后会返回一个确认号是 501 的确认号给主机 A

### 优化亮点

- TCP 提供的确认机制，可以在通信过程中可以不对每一个 TCP 数据包发出单独的确认包（ Delayed ACK 机制 ），而是**在传送数据时，顺便把确认信息传出**，这样可以大大提高网络的利用率和传输效率
- 同时，TCP 的确认机制，也**可以一次确认多个数据报**，例如，接收方收到了 201，301，401 的数据报，则只需要对 401 的数据包进行确认即可，对 401 的数据包的确认也意味着 401 之前的所有数据包都已经确认，这样也可以提高系统的效率（ 详细可以看滑动窗口 ）

## 3. 重传机制 —— 超时重传

### 基础介绍

- 当发出一个数据之后就开启一个定时器，如果在规定的时间之内没有得到发送数据报的 ACK 的应答就应当从缓存中把数据取出并重新发送出去，一直到数据发送成功为止。影响超时重传机制协议效率的非常重要的参数就是超时重传超时时间（ retransmission time out 即 RTO ）
  - 如果 RTO 值设置的过大，会使得发送端经过较长的时间才能够发现报文确实是丢失了，从而降低连接数据传输的吞吐量
  - 如果 RTO 值设置的过小，发送端尽管可以很快的检测出报文段的丢失，但它有可能将一些延迟稍大的报文段误认为是丢失的报文段，从而造成没有必要的重传，进而浪费网络资源

### 具体算法

- 超时重传时间 RTO 计算公式：RTO = RTT + 4 × RTTD
  - RTT 值：指端点间的平均传输往返时延
  - RTTD 值：传输往返时延的偏差值
- 为了确定合适的往返时延 RTT，在传输层方面是非常困难的一件事，因为 TCP 的下层是一个因特网的网际互联环境，发送的报文段可能要经过一个高速以太网，但也有可能是多个低速率的广域网，并且数据报所选择的路由还可能随时发生变化，所以 TCP 采用了一种自适应的算法，具体算法是： - 在数据成功传输的情况下，记录每一个报文段发出的时间，以及收到对应的确认报文段的时间 - 这两个时间的差值就是我们所说的报文段的一个往返时延 - 将各个报文段的往返时延样本进行加权平均就得到报文段的平均往返时延 RTT - 每测量一个新的往返时延的样本就按照以下规律进行一次计算平均往返时延
  往返时延 RTT 公式： - RTT(new) = RTT(sample)（ 第一次测量得到的 RTT 样本值我们就把它当做往返时延的第一次测量值 ） - RTT(new) = α × RTT(old) + (1−α) × RTT(sample)（ 第二次以后的测量 ） - 对第二次以后的测量值这其中有两个参数即 RTT 的累积值（ RTT(old) ），当前 RTT 的样本值（ RTT(sample) ），这里我们用一个参数 α 来进行调节，在公式中 α 取值在 0~1 之间，这其中我们能够看出 - 如果 α 很接近于 1，就表示计算出的往返时延 RTT 和原来累积值的变化差别不大，而对新的往返时延的测量样本对 RTT 的更新影响并不大 - 如果 α 趋近于 0，就表示加权计算受新的往返时延的影响较大 - 这里典型的 α 取值是 7 / 8，也就是说 87.5% 取决于累积值，1 / 8 取决于新的测量样本值

## 4. 重传机制 —— 快速重传

### 基础介绍

- 快速重传和超时重传不同，它不以时间为驱动，而是以数据驱动重传
- 快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段
- 例如，发送方发出了 1，2，3，4，5 份数据，如下图
  ![image](https://i-blog.csdnimg.cn/blog_migrate/8449299b862155835ee9ff3082ada2aa.png)
  - 第一份 Seq1 先送到了，于是就 Ack 回 2
  - 结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2
  - 后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到
  - 发送端收到了 3 个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2
  - 最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6

### 存在缺陷

- 重传的时候，不知道应该重传多少数据
- 举个例子，假设发送方发了 6 个数据，编号的顺序是 Seq1 ~ Seq6 ，但是 Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，但是发送方并不清楚这连续的 ACK2 是接收方收到哪个报文而回复的， 那是选择重传 Seq2 一个报文，还是重传 Seq2 之后已发送的所有报文呢（Seq2、Seq3、 Seq4、Seq5、 Seq6） 呢
  - 如果只选择重传 Seq2 一个报文，那么重传的效率很低。因为对于丢失的 Seq3 报文，还得在后续收到三个重复的 ACK3 才能触发重传
  - 如果选择重传 Seq2 之后已发送的所有报文，虽然能同时重传已丢失的 Seq2 和 Seq3 报文，但是 Seq4、Seq5、Seq6 的报文是已经被接收过了，对于重传 Seq4 ～ Seq6 折部分数据相当于做了一次无用功，浪费资源
- 可以看到，不管是重传一个报文，还是重传已发送的报文，都存在问题
- 为了解决不知道该重传哪些 TCP 报文，于是就有 SACK 方法

## 5. 重传机制 —— SACK 方法

### 基础介绍

- SACK（ Selective Acknowledgment ），选择性确认。这种方式需要在 TCP 头部 “选项” 字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据
- 如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复
  ![image](https://i-blog.csdnimg.cn/blog_migrate/644a15d85cc95b403b7967794f7f896d.png)
- 如果要支持 SACK，必须双方都要支持。在 Linux 下，可以通过 net.ipv4.tcp_sack 参数打开这个功能（ Linux 2.4 后默认打开 ）

## 6. 重传机制 —— D-SACK

### 基础介绍

- D-SACK（ Duplicate SACK ），其主要使用了 SACK 来告诉发送方有哪些数据被重复接收了
- 例如，ACK 丢包情况
  ![image](https://i-blog.csdnimg.cn/blog_migrate/e7d117cda70b7f36b32af5b054701336.png)
  - “接收方” 发给 “发送方” 的 2 个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（ 3000 ~ 3499 ）
  - 于是 "接收方" 发现数据是重复收到的，于是回了一个 SACK = 3000 ~ 3500，告诉 “发送方” 3000 ~ 3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK
  - 这样 ”发送方“ 就知道了，数据没有丢，是 “接收方” 的 ACK 确认报文丢了
- 例如，网络延时情况
  ![image](https://i-blog.csdnimg.cn/blog_migrate/8eddd664cc6e827c98882447a255f731.png)
  - 数据包（ 1000 ~ 1499 ） 被网络延迟了，导致 ”发送方“ 没有收到 Ack 1500 的确认报文
  - 而后面报文到达的 3 个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（ 1000 ~ 1499 ）又到了 “接收方”
  - 所以 “接收方” 回了一个 SACK = 1000 ~ 1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包
  - 这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了
- 在 Linux 下可以通过 net.ipv4.tcp_dsack 参数开启/关闭这个功能（ Linux 2.4 后默认打开 ）

### D-SACK 优势

- 可以让 “发送方” 知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了
- 可以知道是不是 “发送方” 的数据包被网络延迟了
- 可以知道网络中是不是把 “发送方” 的数据包给复制了

## 5. 错误处理

- **失序处理**
  - 作为 IP 数据报来传输的 TCP 分片到达时可能会失序，TCP 将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层
  - 如果接收方收到的数据报文没有错误，只是未按序号，而 TCP 协议应当保证数据报按序到达接收方，那这种现象如何处理呢
    - TCP 协议本身没有规定，而是由 TCP 协议的实现者自己去确定，通常有两种方法进行处理：
      - 对没有按序号到达的报文直接丢弃
      - 将未按序号到达的数据包先放于缓冲区内，等待它前面的序号包到达后，再将它交给应用进程
    - 后一种方法将会提高系统的效率
      - 例如，发送方连续发送了每个报文中 100 个字节的 TCP 数据报，其序号分别是 1，101，201，…，701。假如其它 7 个数据报都收到了，而 201 这个数据报没有收到，则接收端应当对 1 和 101 这两个数据报进行确认，并将数据递交给相关的应用进程，301 至 701 这 5 个数据报则应当放于缓冲区，等到 201 这个数据报到达后，然后按序将 201 至 701 这些数据报递交给相关应用进程，并对 701 数据报进行确认，确保了应用进程级的 TCP 数据的按序到达
      - 如果缓冲区满了，这时接收端会直接丢弃报文，不做任何其他处理，等发送方重传
- **重复处理**
  - 接收方如果收到了重复的报文，将会丢弃重复的报文，但是必须发回确认信息，否则对方会再次发送
- **差错处理**
  - 首先通过数据检验来进行判断报文
  - 接收方如果收到一个有差错的报文，则丢弃此报文，并不向发送方发送确认信息，也不会告诉发送方说发送的数据有错误，而是会等待超时重发

## 1. 滑动窗口（ [详细](https://zhuanlan.zhihu.com/p/571711795?utm_id=0) ）

### 缓冲区

- TCP 在进行数据传输时都是先将数据放在数据缓冲区中的，TCP 维护了 2 个缓冲区，发送方缓冲区和接收方缓冲区
  - 发送方缓冲区：发送方缓冲区用于存储已经准备就绪数据和发送了但是没有被确认的数据
  - 接收方缓冲区：接收方缓冲区用于存储已经被接收但是还没有被用户进程消费的数据

### 基础介绍

- 早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。但由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题
- TCP 滑动窗口是一种流量控制和拥塞控制的机制，用于调整发送方发送数据的速率，以适应网络传输的实际情况，确保传输的可靠性和效率。它通过动态调整发送方的发送窗口大小，实现了数据的有序传输、流量的平衡和网络的稳定性
- 滑动窗口（ Sliding window ）是一种流量控制技术。滑动窗口协议是用来改善吞吐量的一种 技术，即容许发送方在停止并等待确认前连续发送多个分组，而不必每发送一个分组就停下来等待确认，从而增加数据传输的速率提高应用的吞吐量
- 接收方告诉发送方在某一时刻能送多少包（ 即 窗口尺寸 ）
- TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报
- 滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制 的承载结构

### 发送端窗口

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/bc0247dc453f57f97c07ce3b389bd4d0.png)

- TCP 的包可以分为 4 种状态
  - 已发送并且已经确认的包
  - 已发送但是没有确认的包
  - 未发送但是可以发送的包
  - 不允许被发送的包

## 2. 拥塞控制（ Reno 版本 ）

### 拥塞窗口

- 拥塞窗口（ cwnd，Congestion Window ）是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的
- 拥塞控制的本质就是使用算法控制拥塞窗口，从而避免过多的数据注入到网络
- 但是其实真正决定传输速率的是发送方的滑动窗口大小，发送窗口 = min(拥塞窗口, 接收窗口)
- 当发生了重传，就会认为网络出现了拥塞，拥塞窗口减小，否则拥塞窗口增大

### 拥塞控制流程

- 该算法主要包括四个主要部分：慢启动、拥塞避免、快速重传、快速恢复
- 在 TCP 连接建立完毕后，会先使用慢启动算法，指数级逐渐增大拥塞窗口（ +1 +2 +4 +8… ）
- 当拥塞窗口达到慢启动门限 ssthresh（slow start threshold）时，会使用拥塞避免算法，线性逐渐增大拥塞窗口。（+1 +1 +1…）
- 当发生超时重传或快速重传时，会使用拥塞发生算法：

  - 发生超时重传，将 ssthresh 设为 cwnd / 2，将 cwnd 设为初始值，然后会再次使用慢启动算法 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2b746456ac6b6add54672577839d76e0.png)

  - 发生快速重传，使用快速恢复算法，然后进入拥塞避免阶段 ![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/3ca453406a5c57c9c47745937efd8eb5.png)

### 慢启动

- TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1
- 慢启动算法发包的个数是指数性的增长
- 有一个叫慢启动门限 ssthresh （slow start threshold）的状态变量
  - 当 cwnd < ssthresh 时，使用慢启动算法
  - 当 cwnd >= ssthresh 时，就会使用拥塞避免算法

### 拥塞避免

- 规则：每当收到一个 ACK 时，cwnd 增加 1 / cwnd
- 拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长。就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，当触发了重传机制，也就进入了拥塞发生算法

### 拥塞发生

- 当触发 TCP 重传机制时，就视为拥塞发生。TCP 的重传包括超时重传和快速重传，两种重传表示两种不同的网络情况，对应的也有两种拥塞控制手段

### 超时重传

- 当发送方未在规定时间内接收到 ACK 确认包时，就会超时重传。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送
- 当发生超时重传时，就会使用拥塞发生算法，重新进入慢启动阶段。
- 这个时候，ssthresh 和 cwnd 的值会发生变化：
  - ssthresh 设为 cwnd / 2
  - cwnd 重置为初始值

### 快速重传

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8d0f892bac7085674ea6e19d36bf576b.png)

- 快速重传不以时间为驱动，而是以数据驱动重传
- 如果接收方收到一个失序的报文段，就即回送一个 ACK 给发送方
- 快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。
- 当发生「快速重传」，TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：
  - cwnd = cwnd / 2
  - ssthresh = cwnd
  - 进入快速恢复算法阶段

### 快速恢复

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/be31611cb8213a0064e8037e5ea4f141.png)

- 快速恢复算法如下：
  - 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是已经确认收到了 3 个重复的数据包）
  - 重传丢失的数据包
  - 如果再收到重复的 ACK，那么 cwnd 增加 1（ 1 代表每个收到的重复的 ACK 包，都已经离开了网络 ）
  - 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态

### 细节

- 首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。
  其次，过程 2（cwnd 逐渐加 1）的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的
  TCP 拥塞控制算法也有很多个版本，最早的 TCP Tahoe，是没有快速恢复算法的，当发生快速重传时，也会进入慢启动过程
  这里说的是 TCP Reno，除此之外，还有很多版本进行了各自的优化
  另外，网上的许多资料都对快速恢复算法进行了简化，跳过了中间过程而直接进入到拥塞避免阶段
- 扩展-快速恢复失败：快速恢复算法会重传丢失的数据包，如果此时再次发生快速重传，就不会再使用快速恢复，而会直接进入慢启动阶段
