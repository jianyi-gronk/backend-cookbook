## 1. HTTP 存在的问题

- HTTP 由于是明文传输，即客户端与服务端通信的信息都是肉眼可见的，随意使用抓包工具都可以截获通信内容
- 所以安全上存在以下三个风险
  - **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没
  - **篡改风险**，比如强制植入垃圾广告，视觉污染，用户眼容易瞎
  - **冒充风险**，比如冒充淘宝网站，用户钱容易没

## 2. HTTPS 解决 HTTP 安全问题

- HTTPS 在 HTTP 与 TCP 层之间加入了 TLS 协议，来解决上述的风险
  ![image](https://i-blog.csdnimg.cn/blog_migrate/f4f5decc3bb0884f9d42b0c4762ad4ea.png)
- TLS 解决 HTTP 的三个安全风险
  - 解决窃听：信息加密，HTTP 交互信息是被加密的，第三方就无法被窃取
  - 解决篡改：校验机制，校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示
  - 解决冒充：身份证书，证明淘宝是真的淘宝网
- TLS 是 SSL 的升级版，它在 SSL 的基础上进行了一系列的改进和增强，包括密码套件的更新、安全性提升、握手过程优化等方面
- 大体流程
  ![image](https://i-blog.csdnimg.cn/blog_migrate/dd684192e1f9fb431c2fcd071a43354f.png)

## 3. TLS 协议

- TLS 建立连接需要进行 4 次握手，所以 HTTPS 建立连接的时候，实质需要先建立 TCP 连接后，再进行 TLS 连接，即 **总共需要 3 + 4 次握手**，才能真正建立 HTTPS 连接
- 在建立 TLS 握手时，包括 **客户端和服务器会 协商加密算法、交换密钥 和 验证身份**，从而建立安全连接
  - **协商加密算法**：
    - 客户端会发送支持的 **加密算法列表** 给服务器，然后服务器从中选择一个加密算法。通常情况下，双方会选择一种相互支持的最高级别的加密算法，以确保通信的安全性和性能
  - **交换密钥**：
    - 因为考虑到性能的问题，所以双方在加密应用信息时使用的是对称加密密钥，而对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用 **非对称加密的方式来保护对称加密密钥的协商**，这个工作就是密钥交换算法负责的
    - **不同的 密钥交换算法，TLS 的握手过程可能会有一些区别**，常见的密钥交换算法有 RSA 和 ECDHE
  - **验证身份**
    - 指客户端和服务器在握手过程中相互验证对方的身份的过程，通常通过使用 **数字证书** 来完成
    - 为了确保客户端和服务器都是合法、可信任的实体，并且防止中间人攻击等安全威胁
    - 服务器会发送自己的数字证书给客户端，该证书包含了服务器的公钥以及相关的身份信息，客户端会验证服务器证书的有效性，包括检查证书的签名是否有效、证书是否过期、是否与预期的域名匹配等，如果服务器的证书通过验证，客户端就可以信任服务器的身份
    - 类似地，如果客户端需要验证服务器身份，客户端也可以发送自己的数字证书给服务器进行验证
- TLS 握手过程（ RSA 算法为例 ）
  ![image](https://i-blog.csdnimg.cn/blog_migrate/5a40f63355b063df32f95a16f3d049c8.png)
  - 其中每一个 “框” 都是一个记录（ record ），记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment
  - 多个记录可以组合成一个 TCP 包发送，所以通常经过 “四个消息” 就可以完成 TLS 握手，也就是需要 2 个 RTT 的时延，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议

## 4. HTTPS 加密原理

#### 4.1 对称加密 和 非对称加密

- 对称加密：加密和解密用的是同一个密码或者同一套逻辑的加密方式
- 非对称加密：非对称加密用的是一对秘钥，分别叫做公钥和私钥，也叫非对称秘钥
- 两者区别：
  - 对称加密是一个秘钥，非对称加密是一对，两个秘钥
  - 非对称加密比起对称加密更安全，因为不存在秘钥泄露问题，公钥即便被知道也没关系
  - 由于使用非对称加密在计算上特别复杂，所以一般来说对称加密的加密解密的速度相对于非对称加密快很多
  - 非对称秘钥除了加密（ 私钥加密，公钥解密 ）还可以用于认证（ 公钥加密，私钥解密 ）

#### 4.2 公钥 和 私钥

- 非对称的含义是，使用秘钥对中的一个秘钥加密，加密后的数据只能通过另一个秘钥解密
- 也就是说使用一对秘钥中的公钥加密数据，只能通过另一个私钥解密出数据（ 加密）
- 或者反过来，使用一对秘钥中的私钥进行加密的数据，只能通过另一个公钥解密出来（ 认证 ）
- **所以，从加密角度来说，公钥 和 私钥 的功能是相同的，只不过，一般私钥是掌握在自己手中，可以将公钥公布**

#### 4.3 非对称密钥实现认证

- 非对称秘钥除了用于加密数据，用于认证也是非常广泛的，比如手机 apk 的签名， https 中的证书
- 比如现在要认证一个 apk 的代码是否被串改过，首先准备一对非对称秘钥，一般来自权威机构
  - 官方在打包 apk 时不但包含应用代码，还带上一个签名，这个签名这里简单理解为使用 私钥 对应用代码的 hash 值加密后的数据
  - 在安装 apk 时，android 系统会提取 apk 中的签名，使用公钥解密签名得到原始应用代码的 hash，和原始应用代码的 hash 进行比对
  - 如果内容相同，那么 apk 没有被篡改过
  - 若 apk 的应用代码被第三方修改了，那么从签名中解密出来的 hash 和应用代码的 hash 肯定是不同的
  - 所以可以起到确保应用代码没有篡改，也就是认证
- 认证的关键其实是因为签名的存在，签名必须保证能拿到 apk 原始应用代码的 hash
- 使用私钥对内容加密可以达到认证的目的，但不能使用公钥加密来认证，因为如果使用公钥对内容进行加密，那中间人要篡改内容，伪造签名非常简单，直接使用公钥对伪造后的内容的 hash 加密就可以

#### 4.4 https 为什么不可以采用对称加密

- 如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的
- 但这个密钥怎么让传输的双方知晓，同时不被别人知道
- 如果由服务器生成一个密钥并传输给浏览器，那在这个传输过程中密钥被别人劫持到手了，之后他就能用密钥解开双方传输的任何内容了，所以这么做当然不行

#### 4.5 https 为什么不可以采用非对称加密

- 如果把公钥传给浏览器，且浏览器之后发送数据，都用公钥加密，再发给服务器，由于只有服务器有私钥，所以只有服务器能获取数据
  - 但这不对啊，只保证了 浏览器 -> 服务器 是安全的
  - 由于公钥公开了，公钥如果被人拿到了，那么就可以获取服务器传来的数据了，所以 服务器 -> 浏览器 这个数据不安全
- 可以改良使它安全，比如通过两次非对称加密
  - 既然服务器对称加密保留私钥可以保证 浏览器 -> 服务器 时的数据安全
  - 那么浏览器也进行一次对称加密，保留私钥，公钥发给服务器，是不是也保证了 服务器 -> 浏览器 时的数据安全
  - 之后每次通信，都用对方的公钥去加密，用自己的私钥去解密
  - 安全性这样确实可以了（ 实际上还有问题，中间人攻击 ）
- 但是，还是存在性能问题，由于非对称加密在计算上特别复杂，如果每次传输数据都要非对称的加密和解密，需要费很多时间

#### 4.6 https 采用的是 非对称加密 + 对称加密

- 由于非对称耗时严重，我们需要尽可能避免非对称加密，所以我们采用思路
- 数据加密解密通过对称加密，而对称加密的密钥通过非对称加密传递，防止被窃取，这就是 **密钥交换算法**
- 具体步骤为
  - 某服务器拥有用于非对称加密的 公钥 A，私钥 A’
  - 浏览器向网站服务器请求，服务器把 公钥 A 明文给传输浏览器
  - 浏览器随机生成一个用于对称加密的 密钥 X，用 公钥 A 加密后传给服务器
  - 服务器拿到后用私钥 A’ 解密得到 密钥 X
  - 这样双方就都拥有 密钥 X，且别人无法知道它，之后双方所有数据都通过 密钥 X 加密解密即可
- 即只用了一次非对称加密，且之后数据传递用的都是对称加密
- 但和进行两次非对称加密一样，安全性还是有一点小问题，中间人攻击，这时候就需要 **身份验证**

## 5. 身份验证

#### 5.1 中间人攻击

- 在 服务器 和 浏览器 都不会发现异常的情况下，中间人通过一套 “狸猫换太子” 的操作，掉包了服务器传来的公钥，进而得到了密钥 X
  - 某网站服务器有用于非对称加密的 公钥 A，私钥 A’
  - 浏览器向网站服务器请求，服务器把 公钥 A 明文给传输浏览器
  - 中间人劫持到 公钥 A，保存下来，把数据包中的 公钥 A 替换成自己伪造的 公钥 B（ 它当然也拥有公钥 B 对应的私钥 B’ ）
  - 浏览器生成一个用于对称加密的 密钥 X，用 公钥 B（ 浏览器无法得知公钥被替换了 ）加密后传给服务器
  - 中间人劫持后用 私钥 B’ 解密得到 密钥 X，再用 公钥 A 加密后传给服务器
  - 服务器拿到后用 私钥 A’ 解密得到 密钥 X
- **根本原因是浏览器无法确认收到的公钥是不是网站服务器自己的**

#### 5.2 CA 机构 和 数字证书

- 比如现实生活中，若想证明某身份证号一定是 xxx 的，可以看他身份证，而身份证是由政府作证的，这里的前提就是 “政府机构可信”，这也是社会正常运作的前提
- 而 CA 机构充当了互联网世界的 “公理”，作为一切证明的源头，给网站颁发一个 “身份证”，即数字证书，用来证明公钥是对应该网站服务器的（ 即公钥是可信的 ），从而避免中间人攻击
- 一个数字证书通常包含了：
  - 公钥信息
  - 证书持有者信息
  - 证书认证机构（ CA ）的信息
  - CA 对这份文件的数字签名及使用的算法
  - 证书有效期
  - 等等其他额外信息
- **网站在使用 HTTPS 前，需要向 CA 机构申领一份数字证书，服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了**
- 所以本质上，**服务器不是直接把公钥传输给浏览器，而是把公钥信息写在数字证书里（ 还有其他内容 ），再把数字证书给浏览器**

#### 5.3 数字签名

- 现在仍然存在问题：**既然 数字证书 可以起到 “证明” 的作用，那么如何避免它在传输中被篡改**
- 需要把证书原本的内容生成一份 “签名”，比对证书内容和签名是否一致就能判别是否被篡改，这就是数字证书的 “防伪技术”，这里的 “签名” 就叫 **数字签名**
- 下图中左侧是数字签名的制作过程，右侧是验证过程
  ![image](https://i-blog.csdnimg.cn/blog_migrate/8e8bd87cf7b39246561fca8b7dedc496.png)
- 数字签名的制作过程：
  - CA 机构拥有非对称加密的私钥和公钥
  - CA 机构对证书明文数据 T 进行 hash
  - 对 hash 后的值用私钥加密，得到数字签名 S
- 明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了
- 浏览器验证过程
  - 拿到证书，得到明文 T，签名 S
  - 用 CA 机构的公钥对 S 解密（ 由于是浏览器信任的机构，所以浏览器保有它的公钥 ），得到 S’
  - 用证书里指明的 hash 算法对明文 T 进行 hash 得到 T’
  - 显然通过以上步骤，T’ 应当等于 S‘，除非明文或签名被篡改。所以此时比较 S’ 是否等于 T’，等于则表明证书可信

#### 5.4 数字证书链（ 也叫 信任链 ）

- 数字证书是为了证明某网站的公钥是可信，那怎么证明 CA 机构的公钥是可信的呢，则需要通过其他的数字证书来证明，这便形成一个套娃，称作证书链。也就是一连串的数字证书，由根证书为起点，通过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份
- 另外，比如网站访问不了，提示需安装证书的场景，这里安装的就是根证书。说明浏览器不认给这个网站颁发证书的机构，那么就得手动下载安装该机构的根证书（ 风险自己承担 ）。安装后，就有了它的公钥，就可以用它验证服务器发来的证书是否可信了
- 我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级
  ![image](https://i-blog.csdnimg.cn/blog_migrate/b15c77eeef1dfbc7c818e136f11904b0.png)
  - 最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书
- 操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有 CA 机构的根证书，这样就可以拿到它对应的可信公钥了
  - 比如操作系统可能内置了根证书
    ![image](https://i-blog.csdnimg.cn/blog_migrate/8611b0b50e08ffd65bbe16610d6040dd.png)
- 这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示
  ![image](https://i-blog.csdnimg.cn/blog_migrate/a273547eb0cce5efb4f0a8e6ed8f9a35.png)
- 为什么全部证书不直接由根证书信任，而是需要证书链去证明。这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题

#### 5.5 细节问题

- 中间人有可能篡改该证书吗？
  - 假设中间人篡改了证书的原文，由于他没有 CA 机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名
  - 浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人
- 中间人有可能把证书掉包吗？
  - 假设有另一个网站 B 也拿到了 CA 机构认证的证书，它想劫持网站 A 的信息
  - 于是它成为中间人拦截到了 A 传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到 B 的证书里的公钥了
  - 但是因为证书里包含了网站 A 的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了
- 为什么制作数字签名时需要 hash 一次？
  - 最显然的是性能问题，因为非对称加密效率较差，证书信息一般较长，比较耗时，而 hash 后得到的是固定长度的信息（ 比如用 md5 算法 hash 后可以得到固定的 128 位的值 ），这样加解密就快很多
  - 除此之外也有安全上的原因，[详情](https://crypto.stackexchange.com/questions/12768/why-hash-the-message-before-signing-it-with-rsa/12780#12780)
- 每次进行 HTTPS 请求时都必须在 SSL/TLS 层进行握手传输密钥吗？
  - 服务器会为每个浏览器（ 或客户端软件 ）维护一个 session ID，在 TLS 握手阶段传给浏览器
  - 浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的 session ID 下
  - 之后浏览器每次请求都会携带 session ID，服务器会根据 session ID 找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥

## 6. TLS 握手（ RSA 密钥交换算法 ）

#### 6.1 RSA 密钥交换算法

- 传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件中包含服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取
- 在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息

#### 6.2 TLS 四次握手

![image](https://i-blog.csdnimg.cn/blog_migrate/8120e211389d73e06c1c284b54634be3.png)
![image](https://i-blog.csdnimg.cn/blog_migrate/cff750498f76c119f9653ba7ea4ad83e.png)

#### 6.3 第一次握手（ Client Hello ）

- 客户端首先会发一个 “Client Hello” 消息，字面意思也能理解到，这是跟服务器 “打招呼”
  ![image](https://i-blog.csdnimg.cn/blog_migrate/a1075c00209948738970a5eb145e9d5e.png)
- 消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（ Client Random ），这个随机数会被服务端保留，它是生成对称加密密钥的材料之一

#### 6.4 第二次握手

- 第二次握手有三个部分，“Server Hello“，”Server Certificate“ 和 ”Server Hello Done“
- Server Hello
  - 当服务端收到客户端的 “Client Hello” 消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成随机数（ Server Random ）
  - 接着，返回 “Server Hello” 消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（ Server Random ），然后从客户端的密码套件列表选择了一个合适的密码套件
    ![image](https://i-blog.csdnimg.cn/blog_migrate/d8ff467af841d9aacb7551e885f464ac.png)
  - 密码套件的基本形式是：密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法
  - 前面这两个客户端和服务端相互 “打招呼” 的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且客户端和服务端都会各自生成一个随机数，并把随机数传递给对方
  - 这两个随机数是后续作为生成 “会话密钥” 的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥
- Server Certificate
  - 然后，服务端为了证明自己的身份，会发送 “Server Certificate” 给客户端，这个消息里含有数字证书
    ![image](https://i-blog.csdnimg.cn/blog_migrate/fd43ff8b2c656a6e096e68c7bbb0cdb2.png)
- Server Hello Done
  - 最后，服务端发 “Server Hello Done” 消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕
    ![image](https://i-blog.csdnimg.cn/blog_migrate/505180c6ef5f1791a203c20b065dbf07.png)

#### 6.5 第三次握手

- 客户端验证完第二次握手收到的证书后，认为可信则继续往下走
- 第三次握手有三个部分，“Client Key Exchange“，”Change Cipher Spec“ 和 ”Encrypted Handshake Message（ Finishd ）“
- Client Key Exchange
  - 客户端会生成一个新随机数（ pre-master ），用服务器的 RSA 公钥加密该随机数，通过 “Client Key Exchange” 消息传给服务端
    ![image](https://i-blog.csdnimg.cn/blog_migrate/41723d13f0c56faeae2d8088a6a1c332.png)
- Change Cipher Spec
  - 目前，客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master
  - 双方根据已经得到的三个随机数，生成会话密钥（ Master Secret ），它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密
  - 生成完 “会话密钥” 后，然后客户端发一个 “Change Cipher Spec”，告诉服务端开始使用加密方式发送消息
    ![image](https://i-blog.csdnimg.cn/blog_migrate/9d0c3c94a1258f983a683e3d1ef61972.png)
  - 即 “Change Cipher Spec” 之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文
- Encrypted Handshake Message（ Finishd ）
  - 最后，客户端再发一个 “Encrypted Handshake Message（ Finishd ）” 消息，把之前所有发送的数据做个摘要，再用会话密钥（ master secret ）加密一下，让服务器做个验证，验证加密通信 是否可用 和 之前握手信息是否有被中途篡改过
    ![image](https://i-blog.csdnimg.cn/blog_migrate/85d5925d80c5276ad69fc414591e5970.png)

#### 6.6 第四次握手

- 服务器也是同样的操作，发 “Change Cipher Spec” 和 “Encrypted Handshake Message」消息
- 如果双方都验证加密和解密没问题，那么握手正式完成
- 最后，就用「会话密钥」加解密 HTTP 请求和响应了

#### 6.7 RSA 缺陷

- 客户端传递随机数（ 用于生成对称加密密钥的条件之一 ）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数
- 所以 RSA 密钥协商算法的最大问题是不支持前向保密，因为一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解
- 为了解决这个问题，后面就出现了 ECDHE 密钥协商算法，并且现在大多数网站使用的正是 ECDHE 密钥协商算法

#### 6.8 ECDHE 密钥交换算法

- 有点复杂，不过多深究，[详情](https://www.xiaolincoding.com/network/2_http/https_ecdhe.html)
- ECDHE 大致握手过程
  ![image](https://i-blog.csdnimg.cn/blog_migrate/d887b0d3deff4a2d4179693b3c8a5659.png)
- 使用 ECDHE 时，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。所以，ECDHE 相比 RSA 握手过程省去了一个消息往返的时间，这个有点 “抢跑” 的意思，它被称为是 “TLS False Start”，跟 “TCP Fast Open” 有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率
- 并且使用 ECDHE 时， 在 TLS 第 2 次握手中，会出现服务器端发出的 “Server Key Exchange” 消息，而 RSA 握手过程没有该消息
- 除此之外，RSA 密钥协商算法 不支持 前向保密，而 ECDHE 密钥协商算法 支持 前向保密
