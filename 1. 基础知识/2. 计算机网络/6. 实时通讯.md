## 1. 实现 Web 端即时通讯的方法

通过轮询（短轮询）、长轮询、WebSocket、sse（长连接），从性能方面考虑，WebSocket > sse > 长轮询 > 轮询

1. 轮询，浏览器端每隔几秒钟向服务器端发送 http 请求，服务端在收到请求后，不论是否有数据更新，都直接进行响应，在服务端响应完成，就会关闭这个 Tcp 连接
   1. 优点：实现非常简单，它的兼容性也比较好，只要支持 http 协议就可以用这种方式实现
   2. 缺点：建立 tcp 连接是非常消耗资源的，服务端响应完成就会关闭这个 tcp 连接，下一次请求再次建立 tcp 连接
2. 长轮询 ，客户端发送请求后服务器端不会立即返回数据，服务器端会阻塞请求连接不会立即断开，直到服务器端有数据更新或者是连接超时才返回，客户端才再次发出请求新建连接、如此反复从而获取最新数据
   1. 优点：长轮询和短轮询比起来，明显减少了很多不必要的 http 请求次数，相比之下节约了资源
   2. 缺点：连接挂起也会导致资源的浪费
3. Server-Sent 是 HTML5 提出一个标准。由客户端发起与服务器之间创建 tcp 连接，然后并维持这个连接，直到客户端或服务器中的任何一方断开，Server-Sent 使用的是"问"+"答"的机制，连接创建后浏览器会周期性地发送消息至服务器询问，是否有自己的消息
   1. 优点：重复利用一个连接来处理多个消息，直到其中一端断开连接，并且 SSE 会在连接意外断开时自动重连
   2. 缺点：如果客户端有很多需要保持很多长连接，这回占用大量内存和连接数（所以如果一段时间内（具体的时间可以在 header 当中进行设置，也就是所谓的超时时间），这个连接没有 http 请求发出的话，那么这个长连接就会被断掉）
4. WebSocket 是一种网络传输协议，可在单个 tcp 连接上进行全双工通信，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输
   1. 优点：浏览器和服务器只需要要做一个握手的动作，在建立连接之后，双方可以在任意时刻，相互推送信息，同时，服务器与客户端之间交换的头信息很小
   2. 缺点：和长连接一样，服务器长期维护连接需要一定的成本
5. 最后说点细节
   1. 怎么建立长连接
      （HTTP1.0 协议不支持长连接，从 HTTP1.1 协议以后，连接默认都是长连接）
      通过把 Connection 字段设为 keep-alive 来进行指定，不过默认就是 keep-alive，当为 close 的时候是短连接
   2. 长连接使用场景
      （看到一个很好的例子）首先那种正常的频繁发送请求的就不提了，举个别的，比如请求了某个网页，这个网页里肯定还包含了 CSS、JS 等等一系列资源，如果你是短连接（也就是每次都要重新建立 TCP 连接）的话，那你每打开一个网页，基本要建立几个甚至几十个 TCP 连接。但如果是长连接的话，那么这么多次 HTTP 请求（这些请求包括请求网页内容，CSS 文件，JS 文件，图片等等），其实使用的都是一个 TCP 连接，很显然是可以节省很多消耗的
   3. 长连接和 WebSocket 的区别
      一个用的 tcp 协议，一个用的是 WebSocket 协议（实现了全双工），WebSocket 只有一次握手，会发送带有特殊字段的请求头，然后服务器返回响应为 101 状态码（意思是切换协议），之后使用的就是 WebSocket 协议，每次发送请求的响应头都很小
   4. 开发即时通信软件是选择 UDP 还是长连接（WebSocket 同理）（详细可以看[这个](https://blog.csdn.net/xiaoyaGrace/article/details/104795513)）
      例如像 qq，微信这样的大规模即时通讯软件，经常性的是几千万用户同时在线，如果都采用长连接的方式，那服务器的硬件防火墙监控数千万个连接了，就算分布式服务端能承受这么多用户，网关也受不了，而且大概率服务器也受不了。所以对于大规模即时通讯，尤其是用户数量众多，肯定不能用 TCP 常连接的方式，这种方式只适合于小规模的即时通讯，如局域网，公司内部的即时通讯等，对于大规模的，用户数量众多的 C/S 软件，应当采用 UDP 协议进行数据传输，网关就不停收发数据包就可以了
      （所以即时通讯例如会议，聊天之类的使用的一般还是 UDP，长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况）

## 2. 心跳检测

【 心跳检测就是用户在应用层自己实现的一种机制，这里以使用 websocket 的情况举例 】

1. 定义：
   简单地说是为了证明客户端和服务器还活着，websocket 在使用过程中，如果遭遇网络问题等，这个时候服务端没有触发 onclose 事件，这样会产生多余的连接，占用服务器资源，并且服务端会继续发送消息给客户端，造成数据丢失。因此需要一种机制来检测客户端和服务端是否处于正常连接的状态，心跳检测和重连截止就产生了
2. 具体操作：
   - 客户端发起心跳：客户端每隔一段时间发送策略消息给 Socket 服务器，Socket 服务器原路返回策略消息，如果客户端在设定时间内没有收到返回的消息，经重试机制后，判定 Socket 服务器已经 down，关闭连接
   - 服务端发起的心跳：服务端实时记录每条 Socket 的 IO 操作时间，每隔一段时间获取所有 Socket 列表的快照，扫描每条 Socket，如果该 Socket 的 IO 操作时间距当前时间已超出设定值，则判定客户端 down，关闭连接

## 3. WebSocket 协议（ 应用层协议 ）

### 基础介绍

- 是建立在 TCP 协议上的应用层全双工通信协议，可以发送文本和二进制数据
- WebSocket 的协议标识符是 ws（ 如果加密，则为 wss ），HTTP 和 HTTPS 的协议标示符为 http 和 https
- 与 HTTP/HTTPS 协议有着良好的兼容性
  - WebSocket 与 HTTP 和 HTTPS 使用相同的 TCP 端口，一般 WebSocket 协议使用 80 端口，若运行在 TLS 之上时，默认使用 443 端口
  - 并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器，可以绕过大多数防火墙的限制
- 同源协议是针对 HTTP 和 HTTPS，所以 WebSocket 不存在跨域问题，客户端可以与任意服务器通信
- **本质目的是为了解决在 实时双向通信场景 下，传统 HTTP 协议的固定 请求 - 响应 模式带来的性能和效率问题**，比如服务器有连续的状态变化，客户端要获知就非常麻烦，最典型的场景就是聊天室，传统解决方案是 轮询 和 长连接
  - 使用 "轮询"：每隔一段时候，就发出一个询问，了解服务器有没有新的信息
  - 使用 "长连接"：设置 HTTP1.1 中提出的 Connection，但是本质还是轮询，只不过不需要频繁建立 TCP 连接

### WebSocket 协议特点

- 较小的开销：
  - 在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小，头部大概只有 2 Bytes，相对于 HTTP 请求每次都要携带完整的头部，开销显著减少
- 更强的实时性：
  - 由于协议是全双工的，所以服务器可以随时主动给客户端下发数据，相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少
- 会保持连接状态：
  - 与 HTTP 无状态不同的是，WebSocket 需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息，而 HTTP 请求可能需要在每个请求都携带状态信息（ 如身份认证等 ）
- 更好的二进制支持：
  - WebSocket 定义了二进制帧，相对 HTTP1，可以更轻松地处理二进制内容
- 可以支持扩展：
  - WebSocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议，如部分浏览器支持压缩等
- 更好的压缩效果：
  - 相对于 HTTP 压缩，WebSocket 在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率

### WebSocket 和 HTTP2

- WebSocket 和 HTTP2 都是基于 TCP 实现的全双工通信，所以底层原理类似
  - 二进制分帧：HTTP/2 和 WebSocket 都使用二进制分帧技术。在 HTTP/2 中，请求和响应数据被分解为较小的二进制帧，然后在 TCP 连接上进行传输。这使得多路复用成为可能，提高了传输效率。同样，WebSocket 也使用二进制帧作为数据传输的基本单位。这种帧结构使得 WebSocket 可以在一个持久连接上进行双向数据传输，提高了实时通信的效率
  - 多路复用：HTTP/2 支持多路复用，允许在同一个 TCP 连接上并发进行多个请求和响应，从而减少了连接建立和关闭的开销，提高了性能。虽然 WebSocket 本身没有明确的多路复用概念，但由于它是一个全双工协议，允许在一个持久连接上进行双向数据传输，因此可以认为它隐含地支持了多路复用
  - 头部压缩：HTTP/2 引入了 HPACK 头部压缩算法，以减少请求和响应头部的大小，从而提高性能。而 WebSocket 协议没有明确的头部压缩机制。然而，由于 WebSocket 的帧头部本身就相对较小，通常只有几个字节，因此头部压缩在 WebSocket 协议中可能不是一个关键优化点
  - 服务器推送：HTTP/2 支持服务器推送，即服务器可以在客户端请求之前主动发送数据。这可以进一步提高页面加载速度，因为服务器可以预先推送客户端可能需要的资源。而 WebSocket 本身没有服务器推送的概念，但由于 WebSocket 是全双工通信，服务器和客户端可以在任何时候互相发送数据，因此 WebSocket 天然地支持服务器主动向客户端推送数据
- 虽然 HTTP2 和 WebSocket 在底层实现技术上相似，但它们在 通信模式 和 应用场景 等方面有很大不同
  - 通信模式：
    - HTTP2：
      - 虽然 HTTP2 允许在同一个 TCP 连接上并发进行多个请求和响应（ 多路复用 ），但仍然是基于 请求 - 响应 模式的，因此 HTTP2 仍需遵循 HTTP 的基本语义，每个请求需要对应一个响应
    - WebSocket：
      - 在 WebSocket 中，数据传输不再依赖于请求-响应模式，服务器和客户端可以在任何时候相互发送数据
  - 应用场景：
    - HTTP2：
      - HTTP2 主要针对 Web 性能和效率进行了优化，仍然 HTTP2 适用于传统的 Web 应用，如网页加载、API 请求等
    - WebSocket：
      - WebSocket 主要用于实时双向通信场景，如在线聊天、实时数据推送、在线游戏等

### 建立连接原理

- 整个 WebSocket 连接过程，包括 TCP 三次握手和 WebSocket 协议特殊的 HTTP 握手
- 具体说，会先建立 HTTP 连接，底层包括 TCP 三次握手，接下来在这个 HTTP 连接上，发送一次特殊的请求（ 握手 ），用来切换协议
- WebSocket 建立连接的过程遵循一种叫做"握手"（handshake）的协议
  1.  客户端发起一个 HTTP 请求，通常是一个 HTTP GET 请求
      - 带有 Upgrade: websocket 和 Connection: Upgrade 头部，表示希望升级到 WebSocket 协议
      - 带有 Sec-WebSocket-Version 头部，用于指示支持的 WebSocket 协议的版本号
      - 带有 Sec-WebSocket-Key 头部，包含一个 Base64 编码的随机值，用于后续验证服务器的响应
      ```
      GET /my-websocket-endpoint HTTP/1.1
      Host: example.com
      Origin: http://example.com
      Connection: Upgrade
      Upgrade: websocket
      Sec-WebSocket-Version: 13
      Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
      ```
  2.  如果服务器同意建立 WebSocket 连接，它会返回一个 HTTP 响应，状态码为 101 Switching Protocols，表示协议切换
      - 响应头中会包含 Upgrade: websocket 和 Connection: Upgrade，确认协议升级
      - 服务器还会计算一个 Sec-WebSocket-Accept 头部，它是根据客户端发送的 Sec-WebSocket-Key、一个特定的 GUID（ Globally Unique Identifier ）计算出来的，客户端会验证这个值以确保服务器正确响应了握手请求
      ```
      HTTP/1.1 101 Switching Protocols
      Upgrade: websocket
      Connection: Upgrade
      Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
      ```
  3.  握手完成，客户端收到服务器的响应后，会检查 Sec-WebSocket-Accept 头部的值。如果值正确，握手过程完成，WebSocket 连接建立成功。从这一刻起，客户端和服务器之间的通信将不再使用 HTTP 协议，而是使用 WebSocket 协议，可以进行全双工的实时通信

### 如何使用

1. 构造函数，返回一个 WebSocket 对象
   ```
   const webSocket = WebSocket(url[, protocols])
   ```
2. 对要传输的数据进行排队
   ```
   webSocket.send(data)
   ```
3. 关闭当前链
   ```
   webSocket.close([code[, reason]])
   ```
4. 通过事件监听，获取接受到的数 v 据
   ```
   socket.addEventListener('message', function (event) {
     console.log('接收到的数据: ', event.data);
   });
   ```
