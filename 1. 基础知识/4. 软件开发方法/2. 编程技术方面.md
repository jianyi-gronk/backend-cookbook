## 1. 编程技术方面

- 自 20 世纪 60 年代末提出软件工程概念以来，软件开发方法取得了长足的发展，多年来软件开发方法发展过程中的重要里程碑，包括
  - **基本方法（ 结构化程序设计、模块化方法 ）**
  - **面向对象方法**
  - **面向切面方法**
  - **软件复用与构件化方法**
  - **模型驱动方法**
  - **服务化方法**
  - 等等
- **复杂性 是软件开发过程中所固有的特质，而 编程技术方面（ 软件开发方法 ） 的核心在于帮助开发者驾驭这种复杂性**
  - 早期的 结构化程序设计 和 模块化方法 主要针对的是软件程序本身的 复杂性
  - 而后的 面向对象方法 在其基础上增强了应对应用领域问题 复杂性 的能力
  - 面向切面方法 又增强了面向对象方法在处理安全、日志等贯穿性的非功能属性的能力
  - 软件复用 与 构件化方法 通过重复使用已有的软件部件来消除重复开发的 复杂性
  - 模型驱动方法 则力图通过提高解决问题的抽象层次来应对软件系统日益增长的 复杂性
  - 服务化方法 通过中立的访问协议和显式的服务契约解耦服务的提供者和使用者，应对开放异构的互联网环境所带来的 复杂性，并简化了软件的获取和使用方式
- 这些方法之间并非是相互竞争排斥的关系，其历史进程上也未必是线性发展的

## 2. 基本方法

- 软件开发方法是指软件开发过程需要遵循的办法和步骤，早期人们一般性地认为软件开发过程主要包括问题定义、需求分析、设计、编码、测试、维护等阶段，而软件开发方法最初起步于解决软件设计阶段的问题
- 软件设计又分为 概要设计 和 详细设计 两个不同抽象阶段（ 分别建立 软件结构 和 程序过程 ），与之对应的基本方法分别是模块化设计方法和 结构化程序设计

#### 2.1 结构化程序设计

- 结构化程序设计 关注 软件详细设计阶段 的 程序过程（ 代码 ）描述
- 1968 年，Dijkstra 提出了程序中无条件转移语句（ goto ）有害的观点，从而引起了大范围的学术讨论。经过讨论，人们得到共识：goto 语句使得程序的静态结构与程序的动态执行不一致，从而使得程序难以理解和调试。在此基础上，进一步形成了结构化程序设计的主要思想
- 结构化程序设计的主要思想是：**仅使用 顺序、选择（ if ） 和 重复（ for ） 这 3 种结构表示程序过程**。由于这 3 种结构具有 **单入口** 和 **单出口** 特性，因而能够降低程序的复杂性，易于程序理解和维护

#### 2.2 模块化开发方法

- 模块化开发方法 关注 软件概要设计阶段 的 软件体系结构表示
- 面对大规模的复杂问题，通常的解决办法是 **分而治之**，把大问题看成是若干小问题的集合、把复杂问题看成是若干简单问题的集合。软件开发也是如此，与之对应的是模块化方法
- 软件概要设计就是要把软件系统的需求（ 功能 ）对应到软件系统的各个组成部分，这些组成部分称为模块。**模块化是指把软件系统划分成独立命名和可独立访问的模块（ 比如 函数 ），每个模块完成一个子功能，最后集成到一起满足软件的整体功能需求**
- **实现模块化的手段是 抽象 和 信息隐蔽**
  - 抽象 是指抽出事物的本质特性而暂时不考虑它们的细节，比如最开始可以设计某个函数实现某个功能，但是可以之后再具体实现
  - 信息隐蔽意 指一个模块内包含的信息（ 过程 和 数据 ）对于不需要这些信息的模块来说是不可访问的
- 模块化方法 强调 模块独立性，模块独立是指开发的模块具有独立功能并且与其他模块之间没有过多相互作用。模块独立的意义在于功能分割、简化接口、易于测试和维护、易于多人合作开发同一系统

## 3. 面向对象方法（ object oriented programming，简称 OOP ）

#### 3.1 存在问题

- 早期的结构化程序设计和模块化方法围绕功能构造系统，其本质是 **功能分解、过程抽象、自顶向下、逐步求精**。这种方法有助于帮助开发者驾驭软件设计和实现的复杂性，但在应对应用需求的复杂性方面考虑不多。随着软件应用范围的拓展和复杂程度的提高，以及软件需求变化导致的软件演化日益频繁，面向对象的软件开发方法逐渐成为主流

#### 3.2 基本思想

- **对象 是 数据及其所允许操作 的 封装体，是 应用领域现实实体 的 软件抽象，面向对象 通过一组对象的交互来完成系统功能**
- 面向对象方法的实施步骤包含了 **面向对象分析、面向对象设计 和 面向对象实现** 等
  - 面向对象分析：主要包括识别应用领域应被抽象的对象，并分类组织这些对象，形成对象概念模型。刻画这些对象的内部行为和外部交互，以及系统功能目标何以因之达成，形成用例模型
  - 面向对象设计：要在系统各种实施条件的约束下，给出上述概念模型和用例模型的实现方案，包括确定对象模型的操作、设计实现操作的算法、优化数据的访问、调整类结构以提高继承性等，形成面向 实现的类模型、对象交互模型、对象状态模型和存储模型等
  - 面向对象实现：通常使用面向对象程序设计语言和对象持久化设施等将上述设计具体地加以实现
- 在应对需求复杂性方面，面向对象的软件开发方法通过建立与现实世界中的实体、概念、关系和结构直接对应的软件抽象来刻画需求，并支持该软件抽象在需求、设计、实现之间的无缝过渡，有助于弥合问题空间与解空间之间的语义鸿沟
- 在应对需求变化方面，结构化方法下功能的变化将导致如此设计的系统结构发生较大的变化。而应用领域的概念和结构远比应用功能更稳定。因此，较之结构化方法，面向对象方法开发的软件具有更好的结构稳定性、可修改性和可复用性

#### 3.3 核心机制

- 面向对象方法的核心机制包括 **封装、继承 和 多态**
  - 封装：指的是将对象的状态（ 属性 ）和行为（ 方法 ）捆绑在一起，并对外界隐藏对象的实现细节，只暴露必要的接口给外部访问
  - 继承：允许一个类从另一个类 “继承” 属性和方法，继承支持代码的重用，也使得子类可以在父类的基础上扩展或修改行为
  - 多态：指的是相同的方法调用可以根据调用对象的不同而表现出不同的行为。多态使得同一方法可以作用于不同类型的对象，并执行不同的操作

#### 3.4 设计原则

- 为了使开发的软件具有能够快速适应变化的敏捷性，必须遵循面向对象的设计原则，这些原则可以帮助我们设计出更高质量的代码，让代码更健壮、灵活和易于维护
- 常用原则如下
  - **开放封闭原则（ OCP ）**：是面向对象设计的核心，即对扩展开放，对修改封闭
  - **依赖倒置原则（ DIP ）**：要求面向对象的设计要对结构化的方法进行倒置，即高层模块不应依赖低层模块，两者都应依赖于抽象。依赖关系的倒置正是好的面向对象设计的标志所在
  - **单一职责原则（ SRP ）**：要求一个类只负责一个功能领域中的相应职责（ 职责单一 ），且一个类只有一个引起它变化的原因，这是实现软件灵活性的前提
  - **里氏替换原则（ LSP ）**：子类应该可以在任何地方替换它的父类并且能够保证程序的正确性
  - **接口隔离原则（ ISP ）**：客户端不应该被迫依赖于它不需要的接口，即一个类对另外一个类的依赖应建立在最小的接口上。强调接口的高内聚和低耦合
  - **迪米特原则（ LoD ）**：也称为最少知道原则，要求控制对象之间的信息流量、流向及信息的影响，即注意信息的隐藏，一个对象应该尽可能少地了解另外的对象
  - **组合/聚合复用原则**：相比于使用继承来实现复用，更应优先使用 组合/聚合 的复用方式。通过对象的 组合/聚合，可以在运行时动态地配置新对象的功能，并防止类层次规模的爆炸性增长

## 4. 面向切面方法（ aspect oriented programming，简称 AOP ）

#### 4.1 存在问题

- 以日志、安全等为典型代表的非业务功能性属性在常规的面向对象开发当中分布于业务功能模块的各个角落，难以有效统一处理，给软件的理解与维护带来较大障碍，这也就是所谓的 **代码分散**
- 相对应地，会导致的另一个问题则是 **代码缠结**，即同一个模块的代码中要同时处理安全、功能、性能等各类关注点。可想而知，其可读性和可维护性也自然会存在较大问题
- 随着系统规模的快速扩大，代码分散 与 代码缠结 等问题使得 “关注点分离” 更加必要且迫切。而 **面向切面方法 就是 面向对象方法 针对 “关注点分离” 这一目标的有效补充**
- **面向切面方法 采取 横向抽取机制，将分散在 各个方法 中的 重复代码 提取出来，并将其抽象为 “切面”，然后 在程序编译或运行时，再将 这些提取出来的代码 应用到 需要执行的地方**

#### 4.1 面向切面程序设计

- Kiczales 等人在 1997 年欧洲面向对象编程大会上提出了面向切面的程序设计这一思想。相比于 OOP，AOP 把系统关注点分为 核心关注点 与 横切关注点 两类
  - 核心关注点，即处理主要业务逻辑与流程，仍然通过 OOP 去处理
  - 横切关注点，即处理分布在各核心关注点内的共享关注点，如 日志、安全 等
- AOP 通过 “提取” 与 “编织” 解决问题，减少系统的重复代码，降低模块间的耦合度
  - AOP 将这些影响了多个类的 横切关注点 提取封装 到一个 可重用模块，命名为 “Aspect”，即切面
  - 在此基础上，进一步提供了类和切面的 自动编织 机制，将 横切关注点对应的切面 编织 到特点的 连接点 位置，即在运行或编译时应用这些切面，从而实现与原核心业务逻辑的结合

#### 4.2 面向切面程序设计语言

- 出现了以 AspectJ、AspectC 及 AspectC++ 等为代表的面向切面程序设计语言
- 其中，AspectJ 是目前使用得最为广泛的 AOP 语言，其是对 Java 程序设计语言面向切面的扩展，经编译后生成的类文件可以直接在 Java 虚拟机上执行

#### 4.3 各阶段的面向切面方法

- 长期以来，AOP 思想一直受到了学术界和工业界的共同关注，其思想已被引入软件开发的各个阶段，如 需求分析、建模、测试与验证、重构与应用 等阶段，并衍生出 面向切面软件开发（ aspect-oriented software development，简称 AOSD ），面向切面需求工程（ aspect-oriented requirement engineering，简称 AORE ）等多个方向及子研究领域
- 面向切面 的 需求分析
  - 需求分析是软件开发的首要步骤，只有在得到正确需求的情况下才可以进行后续开发。AOP 的主要出发点即横切关注点提取，因此如何 **提取 与 表达** 横切关注点是 AOP 相关领域的重点关注问题
  - 在 横切关注点提取切面，**如何对需求文档进行分析并自动提取** 是一个热点方向。EA-Mine 是一个采用自然语言技术寻找横切点的代表性工具，有的文献采用词汇链分析技术来识别文本需求中的 Aspect
  - 在 横切关注点表达切面，则存在 基于状态机的表达、基于用例图扩充 等多种方法来具体描述相关横切需求
- 面向切面 的 建模
  - 以 UML 为代表的建模工具主要关注的是系统的核心业务逻辑，对于横切关注点缺乏必要的支撑。因此，如何对 UML 进行扩展以支持横切关注点建模，是相关领域的研究热点所在
  - 相关扩展可分为轻量级、重量级两类
    - 所谓 轻量级扩展 即利用 UML 所提供的 Stereotype、Tagged Value、Constraint 等扩展机制进行模型扩展，其优点在于可直接利用 UML 建模工具进行建模
    - 而 重量级扩展 则主要在元模型层面进行直接扩展，给出 Aspect 建模的新型建模元素。这种方法所建立的模型更加直观，但却需要对应的工具支撑。相关方向存在大量工作分布在状态机图、用例图、顺序图、交互概观图乃至活动图以及 Petri 网等多种建模语言上
- 面向切面 的 测试与验证
  - 系统正确性测试与验证是保障系统质量的重要手段。面向切面方法也给相关问题带来了新的挑战，如横切关注点实现的正确性、一致性等
  - 当然，直接把经过编织后的代码当作常规代码进行测试是一种可行手段。除此之外，也仍有大量工作从 AOP 的问题特性出发去研制对应的测试方法，包括面向切面的单元测试、集成测试、回归测试等，并研发了相关工具，如 Wrasp、Raspect、EAT、Rambutans 等
  - 在验证方向上, 也有工作采用模型检验技术验证集成后模型与需求的一致性，以及验证编织后系统中是否含有死锁等不希望的行为等
- 面向切面 的 重构与应用
  - 将面向切面的思想利用到系统重构领域，特别是针对 Aspect 来基于横切关注点进行重构，是相关领域的热点所在。其中的主要问题自然就关注在两个层面：如何发现与识别横切关注点 和 如何基于相关横切点进行重构
- 在上述系列开发工作的基础上，AOP 思想也在各类领域得到了大量的实际应用，如 安全、数据存储、云计算、竞争检测等。相关研究者也在 操作系统、构件化开发、轨道计算 等领域上展开了面向切面思想的应用与尝试

## 5. 软件复用与构件化方法

- 软件复用是指重复使用已有构件，这不仅能够提高开发效率，而且由于使用的越多就越容易发现错误，所以能够保障质量
- 程序语言大都提供了使用外部构件的能力，汇编语言的子程序、结构化程序设计中的函数模块 以及 面向对象程序中的类，都是可以复用的基本构件

#### 5.1 发展阶段

- 1968 年，Mcllroy 在 NATO 软件工程会议上发表的论文 “大量生产的软件构件” 提出了大规模复用的考虑
- 早期具有代表性的工作是美国自然科学基金会组织构建的数学函数库，在 20 世纪 80 年代中期，基本上完成了所有可能的数学函数的子程序，使得在程序中应用各种类数学函数都可以直接复用
- 从 20 世纪 90 年代中期开始，伴随着面向对象技术开发技术的成熟，类（ class ） 因其直接对应客观世界的实体特性，更易于成为复用的组织单元，而类间结构和联系也体现出了客观实体的关联关系。可以说，面向对象分析设计方法的成熟，使得软件复用可以在更全面的范围内得以实施
- 21 世纪开始的 Web 服务（ Web service ）及其面向服务的架构分析设计技术（ service-oriented architecture，简称 SOA ）提供了互联网上可访问的服务实体，这使得软件复用的研究和应用领域扩展到了互联网的软件实体中

#### 5.2 开发步骤

- 系统化的软件复用 则特指将软件复用全过程、全技术紧密结合的开发过程，使软件复用从 早期的关注代码复用 逐步发展到 基于复用的软件开发全过程，可以包括 3 个主要阶段
  - 有目的地开发为复用而做的软件（ development for reuse ）
  - 管理已有的可复用软件（ management for reuse ）
  - 复用已有的软件开发新软件（ development by reuse ）
- 这时的软件复用体现了其核心思想，即：**软件系统的开发以现有的工作为基础，充分利用以往软件系统开发过程中积累的知识和经验进行新的软件系统的开发**

#### 5.3 基于构件的软件开发和复用

- 基于构件的软件开发（ component based software development ）是软件复用技术的核心和基础。**基于构件的软件开发将软件的生产模式从传统的软件编码工作转换为以软件构件为基础的系统集成和组装**
- 构件是指软件系统中具有相对独立功能、可以明确辨识、接口由协议约定（ 相同作用的不同构件暴露相同的接口，方便替换构件 ）、与语境有明显依赖关系、可独立部署且多由第三方提供的可组装软件实体，充当基本复用对象的角色。构件模型则是构件本质特征及构件间关系的抽象描述
- 在基于构件的软件复用中，着重研究了 3 方面的技术
  - 如何识别可以复用的成分：针对特定领域来分析领域的共性需求及其实现，而非仅针对单独的项目需求进行开发，有利于开发出有复用价值的构件，这部分形成了领域工程研究方向
  - 如何组织管理可复用的软件：对软件构件进行描述、分类、存储，提供简单且准确的检索机制，这部分形成了软件构件库研究方向
  - 如何组装已有构件形成新的系统：设计适当的构件模型，将软件代码封装成为可以单独使用的成分，基于构件模型的接口进行集成组装，这部分形成了应用工程研究方向
- 软件复用的基本单元从程序代码开始，发展到了面向对象的类以及封装的构件，包括运行态的构件（ 如 CORBA、EJB、DCOM 等分布式运行构件 ）一直在向大粒度方向进化，**因为复用的粒度大，效益更为明显**

#### 5.4 基于开源软件的软件开发和复用

- **本质还是基于构件开发，只是开源软件让选择的空间更广阔**
- 开源软件的发展不仅仅是代码库的积累和开放，大量涉及开发技术细节的文献、信息也被开放在互联网上，更大程度地带来了开发社区和生态的新环境。在开发社区中，开发的需求讨论、缺陷修改的方案等都被邮件信息、缺陷报告工具、版本管理工具等记录。在开发生态系统中，Stackoverflow 这样的技术问答网站直接为用户回答技术细节问题。这些技术文献的搜集、组织和应用，形成了当前的软件复用的主要可复用资源池
- 不同于传统的基于构件的复用中争取代码封装以备组装使用的专门技术方案，开源软件的代码复用更多地是通过代码直接调用程序接口 API 来实现的，这对提供高质量、广泛代表性的使用示例提出了更高的要求，从而也带来了开源软件中软件包关联过于复杂、庞大的系列问题

#### 5.5 知识驱动的软件开发和复用

- 知识驱动的软件开发方法（ knowledge-driven software development，简称 KDSD ）已成为当前软件复用的主要研究方向。**复用的核心关注点 转变为 软件知识，研究如何基于 特定的知识结构 以及 认知方法和机制 来描述（ 定义 ）、理解 和 利用 可复用的软件实体**
- 这其中主要涉及的问题包括
  - 知识的表示：采用 语义网络，知识图谱 等技术来表达丰富的软件开发知识和领域知识
  - 知识的来源：可从软件代码获取高度结构化、精简、准确的领域知识体系，也可从丰富的软件相关信息中获取自然语言表达的知识
  - 知识的语义关联：建立软件代码知识和自然语言知识的关联，形成领域的语义模型
- 在此基础上，软件开发工具能够以智能推荐的方式为开发人员提供帮助，更进一步地，可能部分实现基于自然语言需求描述自动生成对应的程序
- 目前的 知识表示、信息检索 和 机器学习技术 为这方面的发展提供了全新的技术途径。可以期望未来出现一种软件开发的智能化方法，尽可能准确地提供代码推荐和生成，从而使得软件复用方法的研究和实践从面向复用的对象转向基于知识驱动的智能化开发方法
- **DDD 也是知识的一种，它提供了这样的知识手段，让我们知道如何抽象出限界上下文以及如何去分治，更准确的去定义（ 可复用的 ）软件实体**

## 6. 模型驱动方法（ Model-Driven Development，MDD ）

- 软件的复杂度在不断提高，同时软件的演进形态也日益多样化，而模型驱动方法正是在这样的背景下逐渐受到重视，被认为是可以应对 “高效、低成本地开发优质软件” 的一条有效途径。而这一认识也伴随着实践不断得到深化，经历了
  - 从 统一建模语言（ unified modeling language，简称 UML ）到 模型驱动架构（ model-driven architecture，简称 MDA ）
  - 从 模型驱动架构 到 模型驱动工程（ model-driven engineering，简称 MDE ）
  - 从 模型驱动（ model-driven ）到 基于模型（ model-based ）的过程
- 在软件开发的长期摸索过程中，人们逐渐认识到，**“提高解决问题的抽象层次” 是有效利用抽象手段解决软件开发问题的一个非常具体而实用的途径**（ 与软件技术发展密切相关的 3 个要素是 计算机平台、人的思维模式 和 问题的基本特征。而 “提高解决问题的抽象层次” 中的 “提高” 指的就是向着更接近于人的思维模式方向上的提高 ）
- Mellor 在 21 世纪初曾指出：过去的 50 多年里，**人们利用 “提高解决问题的抽象层次” 处理软件 开发的问题已经取得了两个较为显著的进展：开发出了具有较高抽象层次的程序设计语言；能够在更高抽象层次上实现软件复用**
- 因此**上面三种变化经历，每次都是一次更高层次的抽象，每一个都在上一个的基础上进行了扩展**
- 和 DDD 的区别：**DDD 是 重点关注在业务层面，而 MDD 则是 整个环节 或者 侧重于业务到技术的中间层**

#### 6.1 从 UML 到 MDA

- 在面向对象的语言、方法和技术逐渐成为主流的过程中，Booch、OOSE 和 OMT 方法都获得了工业界的支持，并形成了互不兼容的 3 种模型和方法体系。不同的工业应用在这 3 种不同的体系下形成了彼此之间难以理解和复用的软件制品，这让当时原本就不成熟的软件行业更是雪上加霜
- 此时急需形成一个能够支撑从需求到实现的软件行业标准，因此融合了 3 种软件开发方法和模型表示法，形成了统一建模语言（ unified modeling language，简称 UML ），通过国际标准化组织对象管理组（ object management group，简称 OMG ）发布为建模规范，也形成了面向对象方法学发展道路上的一个重要的里程碑
- 有了这样的技术积累，人们开始尝试在更高的抽象层次上开发软件，中间件的形成与发展也正是在这样的背景下逐步明晰和受到重视的。于是，J2EE、.NET 等中间件技术开始各自占据市场，就像当年 Booch、OOSE 和 OMT 方法之间的争斗
- 在这种情况下，OMG 再次提出了以模型为中心的软件开发框架性标准，即模型驱动体系架构（ model driven architecture，简称 MDA ）。尽管 MDA 提出的直接动因是为了解决异构中间件平台的互操作障碍问题，但是由它所倡导的以模型为中心进行软件开发的思想迅速成为研究热点。**MDA 整合了 OMG 在 建模语言（ UML ）、模型存储 以及 模型交换 等方面的一系列标准，形成了一套基于模型技术的软件系统开发方法和标准体系**
- MDA 四层元模型体系结构
  ![image](https://github.com/user-attachments/assets/67f490cc-1a4c-4234-94c4-25114f10dc2b)

#### 6.2 从 MDA 到 MDE

- 2007 年，模型驱动工程 MDE 这个术语正式出现在第 29 届 ICSE 年会的 FoSE 分会上，标志着 MDE 成为模型驱动软件开发领域的代名词
- **相比 MDA，模型驱动工程（ MDE ）则是一个更为广泛的概念，它包含了 MDA 的思想，但不仅限于 MDA 所关注的架构层面，而是将模型驱动的方法扩展到了整个软件开发生命周期的所有阶段**，包括需求分析、设计、编码、测试、部署维护等各个环节。MDE 倡导以模型为核心，构建和操作软件系统的不同抽象视图，使用模型转换和综合工具来自动化或半自动化地生成系统各部分，包括但不限于源代码、配置文件、数据库模式以及其他工件
- 模型驱动工程以模型为首要软件制品（ software artifact ），通过建模为问题域构造软件系统的业务模型，然后依靠 模型转换 驱动软件开发，（ 半 ）自动地产生最终完备的应用程序
- 模型对于模型驱动工程而言，就如同对象对于面向对象软件开发一样，是基本的开发元素，这也就是叫 “模型驱动” 的原因之一。**模型驱动使软件开发的抽象层次进一步提高到模型这个层次**。模型驱动的思想，或者说以模型为中心的软件开发思想，正是抽象层次提高到一定程度的一个自然而然的结果
- 在 MDE 中，模型指的是为了分析或解决问题而对系统某些方面的抽象描述。从广义上讲，它涵盖了软件系统的任意部分，包括需求、设计、文档、代码、部署、配置和测试用例等。代码也可以看作软件系统的模型，这是因为代码反映了软件程序被执行时的行为。然而，通常所指的 MDE 下的模型，更多的是狭义上的 “设计草图”，即今天的开发模型
- MDE 中的各项研究工作中最重要的问题归结为如下三类挑战，其中前两类是针对建模的问题，最后一类主要是转换的问题
  - 建模语言的挑战：这一类挑战主要来自于如何使建模语言支持在问题层面上进行建模，以及如何对模型进行严格的分析
  - 关注点划分的挑战：这一类挑战来源于对同一系统进行多视图建模的结果。由于不同侧面的模型可能是基于异构的语言开发的，而模型间又存在相互重叠的部分，因而很容易出现不一致等问题
  - 对模型操纵和管理的挑战：这一类挑战包括：对 模型转换 的定义、分析和使用；维护 模型元素间 的 可追溯性，以支持 模型演化 和 双向工程；维护不同视点之间的一致性；版本追踪；在运行期使用模型
- 可以看出，模型驱动思想的核心就是 建模 和 模型转换，它们也是完成 MDE 开发的两个最主要的过程。并且，建模过程和模型转换过程又是相互交织的，建模过程涵盖了一系列不同抽象层次模型的构造过程，而相应的转换过程也包括了不同抽象层次间以及相同抽象层次上的转换

#### 6.3 从 Model-Driven 到 Model-Based

- 发展中，以 “模型” 为中心来驱动软件开发的想法也慢慢演化为如何将模型作为有效的抽象手段来刻画软件的某些重要性质，从而更好地支撑在不同研究领域的应用，如测试、验证、推荐、复用等等。在这种背景下，“Model-Driven”的含义慢慢向 “Model-Based” 靠近
- 模型驱动（ model-driven ）的术语主要是从 MDA 中产生出来，其最初的含义是强调系统的构造是通过以模型为中心来完成的，也就是说，模型的主要用来 “驱动” 软件从需求开始向实现过渡的这个过程。而随着 MDE 研究 领域的逐渐形成，模型的价值在整个软件工程更大范围内得到关注，**模型的概念也从最早的 UML 这个具象的对应体，慢慢回归到作为软件系统的 “抽象描述” 这样的本质上来**
- 因而，基于模型（ model-based ）这个说法就成为更能够表达其宽泛含义的术语，在 MDE 领域得到了更多的应用，如基于模型的软件开发（ model-based software development ）、基于模型的测试（ model-based testing ）、基于模型的规约（ model-based specification ）等等
- 这样大大拓宽了 MDE 研究领域的范围，也极大地增强了软件工程各个研究分支与 MDE 的融合，主要研究方向比如
  - 模型对运行时的支持，主要是通过预先定义或者动态获得的系统行为模型，对软件系统在运行时的行为进行监控，从而预判甚至是干预和调整系统动态行为
  - 模型资产库的构造与应用，是近来备受关注的工作，特别是随着互联网上开源软件的急剧增加，可以被直接获得的软件资产已经形成了相当的规模。如何有效地使用这些软件资产，引起了学术界和工业界的格外关注。模型作为软件的抽象描述，可以从不同的视角和维度展示软件的语义信息，进而形成海量软件资产的 “索引”，极大地提高了对开源软件的理解和复用能力
  - 模型与人工智能、机器学习结合的研究，虽然具体的研究内容还没有得到普遍共识，但总的来讲，一方面是研究基于模型的人工智能和机器学习，另一方面是将人工智能和机器学习技术用到 MDE 研究中。目前来看，后者的研究工作更多一些
  - 建模 IDE 的研究，一直都是 MDE 领域的一个重要研究方向，而且具有很好的实用价值。但与之前研究工作不同的是，目前建模 IDE 的研究不仅仅是 UML 家族或者 MDA 框架下的模型概念，更加泛化的模型是目前的一个趋势，甚至是手绘草图、形式化模型等都被逐渐纳入到所讨论的范畴中

## 7. 服务化方法

- **本质还是基于构件开发，只是在网络环境下的进一步延伸和发展，抽象层次更高**

#### 7.1 基本思想

- 软件服务是指将软件的功能以服务的形式通过互联网来交付，可以被使用者（ 最终用户或者第三方客户端程序 ）直接使用的独立的基本单元
- 就其形态而言，软件服务一般基于可共享和集成的应用系统和资源来构建，对外则表现为一组相对独立的业务功能单元（ 通常是可供外部直接调用的应用编程接口，即 API ），更加方便使用者直接使用
- **软件服务的一个重要目标是屏蔽开放网络环境带来的异构性问题，因而一般具有较高的抽象级别和独立性。这种独立性也带来了软件服务之间更加松散的耦合关系，从而使得使用者可以灵活选择服务并进行组装来生成增值服务**。特别地，由于开放环境下存在大量类似的资源，使用者可以在多个相同或相似服务中不断选择最合适的服务
- 目前，软件服务不仅成为网络环境下最为重要的一种软件形态，也改变了传统的软件交付方式，使得软件产业开始从 “以产品为中心的制造业” 向 “以用户为中心的服务业” 转变。软件由服务的运营商负责运维，用户无需拥有软件的本地拷贝，也不必考虑软件的维护和升级，还可以按需定制和购买软件
- 软件服务使其使用者能够在不拥有软件产品的前提下，直接使用软件的功能，从而实现 “即拿即用” 的效果。这种 “只求使用，不求拥有” 的特性，也只有通过互联网和软件的组合才可能实现。进一步地，软件服务的使用者可以更加灵活地进行服务组装以生成增值服务，并能不断地选择最优服务来满足适应性的需求

#### 7.2 主要角色

- 一般而言，基于服务的软件开发主要包含 3 类主要角色，即 服务提供者、服务使用者 和 服务代理
- 服务提供者
  - 按照服务约定的协议，实现了提供业务功能的软件模块。对于提供同一业务功能的服务，可以有多种不同的服务提供者
- 服务使用者
  - 即服务的用户，调用服务提供者所实现的服务，以完成特定的业务需求
  - 服务请求者可以是用户通过客户端应用程序（ 如浏览器或智能手机 ）实现，也可以是没有用户界面的程序实现（ 如另一个服务 ）
- 服务代理
  - 是一个可搜索的第三方注册机构，如 UDDI 等
  - 服务提供者将服务描述发布给服务代理，服务请求者在服务代理处查找服务并进行绑定（ 可分为静态绑定和动态绑定 ）和调用

#### 7.3 开发过程

- 围绕软件服务的开发过程可以分为如下几个
- 服务封装和生成
  - 服务提供者将软件系统中需要开放的功能和数据按照一定的标准（ 如 Web 服务 ）进行封装并发布
  - 服务的生成一般是对已有的软件系统的功能和数据进行封装，也可以是服务提供者新开发的功能和数据
- 服务查找和选择
  - 服务使用者查找并选择满足其功能和非功能需求的服务
  - 服务查找既可以通过统一的服务代理（ 如 UDDI ），也可以通过搜索引擎来进行
- 服务组装
  - 服务使用者对若干服务进行组装来形成新的增值服务应用
  - 组装的过程既可以按照预先定义的规则（ 如业务流程规约 WS-BPEL 或 WSCI ）及其引擎自动/半自动地完成，也可以根据当前的情境以人机协同的方式来完成（ 如 Web Mashups ）
- 服务演化
  - 由于每个软件服务是相对独立的实体，其功能和质量均可能发生演化。相应地，通过服务组装而成的应用也会随之发生演化，可表现为服务的升级/降级、增加、退出和替换等

#### 7.4 发展过程

- 面向服务的体系结构和 Web 服务
  - 软件服务的思想可以追溯到 20 世纪 90 年代中期出现的 “应用服务提供商”（ application service provider，简称 ASP ）
  - 21 世纪的前 10 年，软件服务开始成为学术界和工业界的研究实践热点，其代表为面向服务的体系结构（ service oriented architecture，简称 SOA ）及其主要的实现技术（ Web 服务 ）的兴起
  - 从实际应用情况看，在互联网上，基于 SOAP（ 简单对象访问协议 ）的 Web 服务数量还比较少，且大多只提供相对简单的数据查询功能（ 如天气、股票查 询等 ），Web 服务之间也很少构成复杂的业务逻辑
  - 这里既有 Web 服务技术体系存在自身缺陷的原因，如广域网 中基于 SOAP 协议的消息传输性能较差、服务质量难以保障等，也有一些非技术的因素，如 Web 服务相关的技术标准过于繁杂难以统一、面向互联网的服务注册中心（ UDDI ）难以管理和维护等
- RESTful 服务
  - 2004 年前后，随着 Web 2.0 的兴起，对数据/内容开放共享、多方协同、用户交互体验的需求不断增加，越来 越多的 Web 系统所有者均开始关注如何将自身的功能和数据以服务的形式开放出来
  - 由于传统的基于 SOAP 的 Web 服务在互联网环境下难以进行规模化应用，于是，基于 REST 体系结构风格的软件服务技术得到了广泛关注和使用
  - REST 由 Roy Fielding 于 2000 年左右提出，是 WWW 架构 最为核心的应用软件体系结构风格。与 SOAP 相比，REST 体系结构风格提供了一种相对轻量的应用协议，通过描述资源状态变化的方式而不是远程过程调用（ remote procedure call ）的方式来使用软件服务，更加适合万维网环境
  - 特别地，2007 年起，云计算开始成为互联网环境下最为重要的应用模式，基于 REST 体系结构风格的软件服务成为云计算的基础使能技术之一。几乎所有的主流软件服务提供商（ 如谷歌、亚马逊、 Facebook、百度、腾讯等 ），都开始采用遵循 REST 的 Web API 来发布软件服务供用户在线使用
  - 此外，基于 REST 的 Web 服务功能也不仅限于简单的数据查询，应用的业务范围更广，如谷歌的 Gmail 服务、Salesforce.com 的 CRM（ 客户关系管理 ）服务和亚马逊的存储服务等，都是基于 REST 的 Web 服务
  - 当然，在云计算环境下，软件服务仍有很多问题需要解决，包括对 “黑盒” 形态的遗产系统 “解耦” 和 “安全” 的服务化封装、服务的交付与展现、服务动态组装、服务的跨域安全性、服务资源管理等
- 微服务和开发运行一体化
  - 近年来，“微服务” 得到软件服务研究实践者的广泛关注。微服务是一种基于一组独立部署运行的小型服务来构建应用的方法。与传统的面向服务体系结构 SOA 应用相比，这些小型服务主要围绕应用系统业务能力来构建，采用尽量去中心化的机制管理，使用不同技术栈开发，通过轻量级通信机制交互
  - 围绕微服务架构，一些新的研究正在不断涌现,如面向主流编程语言并支持微服务架构的软件开发框架、事件驱动的开发运行一体化（ 如 DevOps ）基础设施架构、细粒度基础资源及其状态监控、在线测试和快速部署、容错等关键技术等
