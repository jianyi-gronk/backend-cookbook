## 1. 什么是 AOP（ Aspect Oriented Programming，面向切面编程 ）

- AOP 最早是 AOP 联盟的组织提出的，本质是为了解耦，spring 将 AOP 的思想引入框架之中，通过预编译方式和运行期间动态代理实现程序的统一维护的一种技术，理念就是将分散在各个业务逻辑代码中相同的代码通过横向切割的方式抽取到一个独立的模块中
- OOP 面向对象编程，针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。而 AOP 则是针对业务处理过程中的切面进行提取，它所面对的是处理过程的某个步骤或阶段，以获得逻辑过程的中各部分之间低耦合的隔离效果
  ![image](https://github.com/user-attachments/assets/21a90bb8-4d78-4454-b22e-74868da74ff3)

#### 1.1 AOP 术语

- 连接点（ Jointpoint ）：表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring 只支持方法执行连接点
- 切入点（ Pointcut ）：选择一组相关连接点的模式，即可以认为连接点的集合，Spring 支持 perl5 正则表达式和 AspectJ 切入点模式，Spring 默认使用 AspectJ 语法
- 通知（ Advice ）：在连接点上执行的行为，通知提供了在 AOP 中需要在切入点所选择的连接点处进行扩展现有行为的手段。包括 前置通知、后置通知、环绕通知 等，在 Spring 中通过代理模式实现 AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知
- 方面/切面（ Aspect ）：横切关注点的模块化，比如上边提到的日志组件。可以认为是通知、引入和切入点的组合。在 Spring 中可以使用 Schema 和@AspectJ 方式进行组织实现
- 引入（ inter-type declaration ）：也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring 允许引入新的接口（ 必须对应一个实现 ）到所有被代理对象（ 目标对象 ）
- 目标对象（ Target Object ）：需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为被通知对象。由于 Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象
- 织入（ Weaving ）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（ 例如使用 AspectJ 编译器 ），类加载时和运行时完成。Spring 和其他纯 Java AOP 框架一样，在运行时完成织入
- AOP 代理（ AOP Proxy ）：AOP 框架使用代理模式创建的对象，从而实现在连接点处插入通知（ 即应用切面 ），就是通过代理来对目标对象应用切面。在 Spring 中，AOP 代理可以用 JDK 动态代理或 CGLIB 代理实现，而通过拦截器模型应用切面

#### 1.2 通知类型

- 前置通知（ Before advice ）：
  - 在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（ 除非它抛出一个异常 ）
- 后置通知（ After returning advice ）：
  - 在某连接点正常完成后执行的通知。例如，一个方法没有抛出任何异常，正常返回
- 异常通知（ After throwing advice ）：
  - 在方法抛出异常退出时执行的通知
- 最终通知（ After (finally) advice ）：
  - 当某连接点退出的时候执行的通知（ 不论是正常返回还是异常退出 ）
- 环绕通知（ Around Advice ）：
  - 包围一个连接点的通知，如方法调用。这是最常用的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行

## 2. Spring AOP 配置方式

#### 2.1 XML Schema 配置方式

- 定义切面类

  ```java
  package org.study.springframework.aspect;
  import org.aspectj.lang.ProceedingJoinPoint;

  public class LogAspect {
    /**
     * 环绕通知.
     *
     * @param pjp pjp
     * @return obj
     * @throws Throwable exception
     */
    public Object doAround(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("-----------------------");
        System.out.println("环绕通知: 进入方法");
        Object o = pjp.proceed();
        System.out.println("环绕通知: 退出方法");
        return o;
    }

    /**
     * 前置通知.
     */
    public void doBefore() {
        System.out.println("前置通知");
    }

    /**
     * 后置通知.
     *
     * @param result return val
     */
    public void doAfterReturning(String result) {
      System.out.println("后置通知, 返回值: " + result);
    }

    /**
     * 异常通知.
     *
     * @param e exception
     */
    public void doAfterThrowing(Exception e) {
      System.out.println("异常通知, 异常: " + e.getMessage());
    }

    /**
     * 最终通知.
     */
    public void doAfter() {
      System.out.println("最终通知");
    }
  }
  ```

- XML 配置 AOP

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:aop="http://www.springframework.org/schema/aop"
         xmlns:context="http://www.springframework.org/schema/context"
         xsi:schemaLocation="http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/aop
   http://www.springframework.org/schema/aop/spring-aop.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context.xsd
  ">
    <context:component-scan base-package="tech.pdai.springframework" />
    <aop:aspectj-autoproxy/>

    <!-- 目标类 -->
    <bean id="demoService" class="tech.pdai.springframework.service.AopDemoServiceImpl">
        <!-- configure properties of bean here as normal -->
    </bean>

    <!-- 切面 -->
    <bean id="logAspect" class="tech.pdai.springframework.aspect.LogAspect">
        <!-- configure properties of aspect here as normal -->
    </bean>

    <aop:config>
        <!-- 配置切面 -->
        <aop:aspect ref="logAspect">
          <!-- 配置切入点 -->
          <aop:pointcut id="pointCutMethod" expression="execution(* tech.pdai.springframework.service.*.*(..))"/>
          <!-- 环绕通知 -->
          <aop:around method="doAround" pointcut-ref="pointCutMethod"/>
          <!-- 前置通知 -->
          <aop:before method="doBefore" pointcut-ref="pointCutMethod"/>
          <!-- 后置通知；returning属性：用于设置后置通知的第二个参数的名称，类型是Object -->
          <aop:after-returning method="doAfterReturning" pointcut-ref="pointCutMethod" returning="result"/>
          <!-- 异常通知：如果没有异常，将不会执行增强；throwing属性：用于设置通知第二个参数的的名称、类型-->
          <aop:after-throwing method="doAfterThrowing" pointcut-ref="pointCutMethod" throwing="e"/>
          <!-- 最终通知 -->
          <aop:after method="doAfter" pointcut-ref="pointCutMethod"/>
        </aop:aspect>
      </aop:config>

      <!-- more bean definitions for data access objects go here -->
  </beans>
  ```

#### 2.2 AspectJ 注解解析

- Spring 使用了@AspectJ 框架为 AOP 的实现提供了一套注解
- @Aspect：
  - 用来定义一个切面
- @pointcut：
  - 用于定义切入点表达式。在使用时还需要定义一个包含名字和任意参数的方法签名来表示切入点名称，这个方法签名就是一个返回值为 void，且方法体为空的普通方法
- @Before：
  - 用于定义前置通知，相当于 BeforeAdvice。在使用时，通常需要指定一个 value 属性值，该属性值用于指定一个切入点表达式（ 可以是已有的切入点，也可以直接定义切入点表达式 ）
- @AfterReturning：
  - 用于定义后置通知，相当于 AfterReturningAdvice。在使用时可以指定 pointcut / value 和 returning 属性，其中 pointcut / value 这两个属性的作用一样，都用于指定切入点表达式。@Around 用于定义环绕通知，相当于 MethodInterceptor。在使用时需要指定一个 value 属性，该属性用于指定该通知被植入的切入点
- @After-Throwing：
  - 用于定义异常通知来处理程序中未处理的异常，相当于 ThrowAdvice。在使用时可指定 pointcut / value 和 throwing 属性。其中 pointcut/value 用于指定切入点表达式，而 throwing 属性值用于指定-一个形参名来表示 Advice 方法中可定义与此同名的形参，该形参可用于访问目标方法抛出的异常
- @After：
  - 用于定义最终 final 通知，不管是否异常，该通知都会执行。使用时需要指定一个 value 属性，该属性用于指定该通知被植入的切入点
- @DeclareParents：
  - 用于定义引介通知，相当于 IntroductionInterceptor

#### 2.3 AspectJ 注解方式

- 定义切面类

  ```java
  package tech.pdai.springframework.aspect;

  import org.aspectj.lang.ProceedingJoinPoint;
  import org.aspectj.lang.annotation.After;
  import org.aspectj.lang.annotation.AfterReturning;
  import org.aspectj.lang.annotation.AfterThrowing;
  import org.aspectj.lang.annotation.Around;
  import org.aspectj.lang.annotation.Aspect;
  import org.aspectj.lang.annotation.Before;
  import org.aspectj.lang.annotation.Pointcut;
  import org.springframework.context.annotation.EnableAspectJAutoProxy;
  import org.springframework.stereotype.Component;

  /**
   * @author pdai
   */
  @EnableAspectJAutoProxy
  @Component
  @Aspect
  public class LogAspect {
    /**
     * define point cut.
     */
    @Pointcut("execution(* tech.pdai.springframework.service.*.*(..))")
    private void pointCutMethod() {
    }


    /**
     * 环绕通知.
     *
     * @param pjp pjp
     * @return obj
     * @throws Throwable exception
     */
    @Around("pointCutMethod()")
    public Object doAround(ProceedingJoinPoint pjp) throws Throwable {
      System.out.println("-----------------------");
      System.out.println("环绕通知: 进入方法");
      Object o = pjp.proceed();
      System.out.println("环绕通知: 退出方法");
      return o;
    }

    /**
     * 前置通知.
     */
    @Before("pointCutMethod()")
    public void doBefore() {
      System.out.println("前置通知");
    }


    /**
     * 后置通知.
     *
     * @param result return val
     */
    @AfterReturning(pointcut = "pointCutMethod()", returning = "result")
    public void doAfterReturning(String result) {
      System.out.println("后置通知, 返回值: " + result);
    }

    /**
     * 异常通知.
     *
     * @param e exception
     */
    @AfterThrowing(pointcut = "pointCutMethod()", throwing = "e")
    public void doAfterThrowing(Exception e) {
      System.out.println("异常通知, 异常: " + e.getMessage());
    }

    /**
     * 最终通知.
     */
    @After("pointCutMethod()")
    public void doAfter() {
      System.out.println("最终通知");
    }
  }
  ```
