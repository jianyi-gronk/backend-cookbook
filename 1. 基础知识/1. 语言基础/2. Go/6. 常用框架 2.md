## 1. 日志框架

#### 1.1 logrus 日志框架

- github.com/sirupsen/logrus **完全兼容 golang 标准库日志模块，功能丰富且灵活**
- 自定义日志格式 SetFormatter
  - logrus.TextFormatter：将日志信息以 Text 格式输出，日志信息通常包含时间戳、日志级别、日志消息等内容，格式较为易读，适合在开发环境，需要人工查看日志的场景中使用
  - logrus.JSONFormatter：将日志信息以 JSON 格式输出，便于机器解析和处理
  - logrus.XMLFormatter：将日志信息以 XML 格式输出，便于机器解析和处理
  - 自定义格式化器：需要实现 logrus.Formatter 接口，该接口包含一个 Format 方法
- 自定义日志级别 SetLevel
  - 日志级别分六个级别，如 Debug、Info、Warn、Error、Panic、Fatal
  - 设置日志级别后，之后高于或等于的日志级别能打印出来，比如设置 logrus.InfoLevel 后，只能打印出 Debug 级别之后的日志
- 基础样例

  ```go
  func main() {
    // 初始化 logrus
    // 自定义日志格式
    logrus.SetFormatter(&logrus.TextFormatter{})
    // 自定义日志级别
    logrus.SetLevel(logrus.DebugLevel)

    // 记录日志
    logrus.Debug("This is a debug log.")
    logrus.Info("This is an info log.")
    logrus.Warn("This is a warning log.")
    logrus.Error("This is an error log.")
  }
  ```

- 添加钩子，可以让每条日志输出前都会执行钩子的特定方法

  - 钩子需要实现 logrus.Hook 接口
    ```go
    // github.com/sirupsen/logrus/hooks.go
    type Hook interface {
      // Levels() 方法返回感兴趣的日志级别，输出其他级别的日志时不会触发钩子
      Levels() []Level
      // Fire() 是日志输出前调用的钩子方法，在 entry.Data 中添加的字段就会输出到日志中
      Fire(*Entry) error
    }
    ```
  - 实现钩子

    ```go
    import (
      "github.com/sirupsen/logrus"
    )

    type AppHook struct {
      AppName string
    }

    func (h *AppHook) Levels() []logrus.Level {
      return logrus.AllLevels
    }

    func (h *AppHook) Fire(entry *logrus.Entry) error {
      entry.Data["app"] = h.AppName
      return nil
    }

    func main() {
      h := &AppHook{AppName: "awesome-web"}
      logrus.AddHook(h)

      logrus.Info("info msg")
      // 新添的 app 字段会被输出到日志中
      // time="2020-02-08T15:51:52+08:00" level=info msg="info msg" app=awesome-web
    }
    ```

#### 1.2 zap 日志框架

- go.uber.org/zap **非常注重性能，比标准库 log 包快几个数量级，即使在高并发场景下也有出色的性能表现**
- zap 有 4 种创建 logger 的方法，前三种都预先设置了配置信息
  - zap.NewExample()：用在测试代码中，将 DebugLevel 及以上日志用 JSON 格式标准输出，但它省略了时间戳和调用函数，以保持示例输出的简短和确定性
  - zap.NewProduction()：用在生成环境中，也 DebugLevel 及以上日志信息输出，输出文件名和行号，而 NewExample() 没有
  - zap.NewDevelopment()：用在开发环境中，将 info 及以上的日志内容以 JSON 格式记写入，也输出文件名和行号
  - zap.New(core, ...)：自定义 logger，core 是 zapcore.Core 类型的参数，通过 zapcore.NewCore(encoder, writerSyncer, logLevel) 创建，包括 日志编码器（ 输出格式 ），日志输出目标（ 控制台，文件 等 ），日志级别（ 允许处理的最低日志级别 ）
- Zap 提供了两种类型的日志记录器 Logger 和 Sugared Logger

  - Logger 是性能更好的记录器，但是只支持强类型的结构化日志记录
  - Sugared Logger 对 Logger 进行了封装，提供了一些高级的语法糖特性，例如 支持结构化的日志，支持 printf 风格的日志，日志字段不需要定义类型
  - Logger 和 Sugared Logger 之间可以相互转换

    ```go
    // 创建 Logger
    logger := zap.NewExample()
    defer logger.Sync()

    // 转换 Sugared Logger
    sugar := logger.Sugar()

    // 转换 Logger
    plain := sugar.Desugar()
    ```

- 和 logrus 类似，也有 6 中日志级别，如 Debug、Info、Warn、Error、Panic、Fatal
- 由于是高性能的日志库，为了提高性能，在记录日志时可能会将日志条目缓冲起来，而不是立即写入到输出目标，而 logger.Sync() 方法的作用就是强制将缓冲区中的所有日志条目刷新到输出目标
- 可以通过 logger.AddSync 修改日志输出位置
- 通过 Hook 实现钩子，也是在每次日志内容记录后运行这个回调函数

  ```go
  logger, _ := zap.NewProduction(zap.Fields(
    zap.String("log_name", "testlog"),
    zap.String("log_author", "prometheus"),
  ))
  defer logger.Sync()

  logger.Info("test fields output")

  logger.Warn("warn info")
  // {"level":"info","ts":1679477929.842166,"caller":"zapdemos/fields.go:14","msg":"test fields output","log_name":"testlog","log_author":"prometheus"}
  // {"level":"warn","ts":1679477929.842166,"caller":"zapdemos/fields.go:16","msg":"warn info","log_name":"testlog","log_author":"prometheus"}
  ```

- 较复杂场景，通过 zap.New(core, ...) 自定义 logger，且对不同的日志级别，输出到不同的文件

  ```yml
  # 配置文件
  log:
    - level: debug
      output: ./log/debug.log
      size: 10
    - level: info
      output: ./log/info.log
      size: 10
    - level: warn
      output: ./log/warn.log
      size: 10
    - level: error
      output: ./log/error.log
      size: 10
  ```

  ```go
  func init() {
    // config 和 level 映射
    levelMap := map[string]zapcore.Level{
      "debug": zapcore.DebugLevel,
      "info":  zapcore.InfoLevel,
      "warn":  zapcore.WarnLevel,
      "error": zapcore.ErrorLevel,
    }

    // 读取配置
    globalConfig := config.GlobalConfig

    // 创建 Logger
    var cores []zapcore.Core
    for _, logConfig := range globalConfig.Log {
      core, err := createCore(logConfig.Output, levelMap[logConfig.Level], logConfig.Size)
      if err != nil {
        panic(err)
      }
      cores = append(cores, core)
    }
    combinedCore := zapcore.NewTee(cores...) // 合并核心
    // AddCaller 的作用是在日志记录中添加调用者信息
    // AddCallerSkip(1) 的作用是跳过调用者信息的层级数
    Logger = zap.New(combinedCore, zap.AddCaller(), zap.AddCallerSkip(1))
  }

  // createCore 创建核心
  func createCore(logFilePath string, logLevel zapcore.Level, fileSize int) zapcore.Core {
  	// 配置日志输出目标
  	writerSyncer := getLogWriter(logFilePath, fileSize, logLevel)
  	// 配置日志编码器
  	encoder := getEncoder()
  	// 创建核心组件
  	return zapcore.NewCore(encoder, writerSyncer, logLevel)
  }

  // getLogWriter 获取日志写入器
  func getLogWriter(logFilePath string, fileSize int, logLevel zapcore.Level) zapcore.WriteSyncer {
    lumberJackLogger := &lumberjack.Logger{
      Filename:   logFilePath,
      MaxSize:    fileSize, // 日志文件最大大小（ MB ）
      MaxBackups: 5,        // 最多保留的旧日志文件数量
      MaxAge:     30,       // 最多保留的天数
      Compress:   true,     // 启用日志文件压缩
    }
    // Debug 级别日志同时输出到控制台和文件内
  	if logLevel == zapcore.DebugLevel {
  		return zapcore.NewMultiWriteSyncer(zapcore.AddSync(os.Stdout), zapcore.AddSync(lumberJackLogger))
  	} else {
  		return zapcore.AddSync(lumberJackLogger)
  	}
  }

  // getEncoder 获取日志编码器
  func getEncoder() zapcore.Encoder {
    // 创建一个适用于开发环境的编码器配置对象
    encoderConfig := zap.NewDevelopmentEncoderConfig()
    // 配置时间编码方式
    encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
    // 配置日志级别编码方式
    encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder
    return zapcore.NewJSONEncoder(encoderConfig)
  }
  ```

#### 1.3 lumberjack 日志切割框架

- log 包通常不支持日志切割，如果我们业务每天产生海量日志，日志文件就会越来越大，甚至会触发磁盘空间不足的报警，此时如果移动或者删除日志文件，需要先将业务停止写日志，很不方便，而且大日志文件也不方便查询，多少有点失去日志的意义
- 在实际业务开发中，通常用 gopkg.in/natefinch/lumberjack.v2 或其他框架按照日志文件大小或者日期进行日志切割
- 原生 log 接入 lumberjack

  ```go
  log.SetOutput(&lumberjack.Logger{
    Filename:   "/myapp/foo.log", // 存储的文件名
    MaxSize:    500,              // 日志文件最大大小（ MB ）
    MaxBackups: 3,                // 最多保留的旧日志文件数量
    MaxAge:     30,               // 最多保留的天数
    Compress:   true,             // 启用日志文件压缩
  })
  ```

- zap 接入 lumberjack

  ```go
  zapcore.AddSync(&lumberjack.Logger{
    Filename:   "/myapp/foo.log", // 存储的文件名
    MaxSize:    500,              // 日志文件最大大小（ MB ）
    MaxBackups: 3,                // 最多保留的旧日志文件数量
    MaxAge:     30,               // 最多保留的天数
    Compress:   true,             // 启用日志文件压缩
  })
  ```

## 2. jwt 框架

- 之前通常使用 github.com/dgrijalva/jwt-go 库，但是该仓库已经不维护，可以使用 github.com/golang-jwt/jwt 替代，完全兼容 jwt-go
- 生成 JWT

  ```go
  import (
    "fmt"
    "time"
    "github.com/golang-jwt/jwt"
  )

  // 定义一个密钥，用于签名和验证 JWT
  var jwtKey = []byte("your_secret_key")

  // Claims 定义 JWT 的声明结构体
  type Claims struct {
  	data *JwtData
  	jwt.StandardClaims
  }

  // JwtData JWT 中数据
  type JwtData struct {
  	UserID int64 `json:"user_id"`
  }

  // GenerateToken 生成 JWT
  func GenerateToken(userID int64) (string, error) {
    // 设置过期时间，这里设置为 1 小时
    expirationTime := time.Now().Add(1 * time.Hour)
    // 创建 Claims 实例
    claims := &Claims{
      data: &JwtData{UserID: userID},
      StandardClaims: jwt.StandardClaims{
        // 设置过期时间
        ExpiresAt: expirationTime.Unix(),
        // 设置发行人
        Issuer:    "your_issuer",
      },
    }
    // 创建一个新的令牌对象，指定签名方法为 HS256
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    // 使用密钥对令牌进行签名
    tokenString, err := token.SignedString(jwtKey)
    if err != nil {
      return "", err
    } else {
      return tokenString, nil
    }
  }
  ```

- 验证 JWT

  ```go
  // ValidateToken 验证 JWT 的函数
  func ValidateToken(tokenString string) (*JwtData, error) {
    // 定义一个 Claims 实例
    claims := &Claims{}

    // 解析 JWT
    token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
      // 验证签名方法
      if _, ok := token.Method.(*jwt.SigningMethodHMAC);!ok {
        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
      }
      // 返回密钥
      return jwtKey, nil
    })

    if err != nil {
      return nil, err
    }

    if!token.Valid {
      return nil, fmt.Errorf("invalid token")
    }

    return claims.data, nil
  }
  ```
