## 1. Web 框架

- github.com/gin-gonic/gin 类似于 Nodejs 中的 express，是轻量级 Web 框架
- 主要用于快速搭建 Web 服务器和开发 RESTful API，帮助开发者更高效地处理 HTTP 请求、路由管理、中间件集成等常见的 Web 开发任务

#### 1.1 基础使用

- gin 提供了简洁的 API 来定义路由规则，将不同的 HTTP 请求方法（ 如 GET、POST、PUT、DELETE 等 ）和请求路径映射到相应的处理函数上
- 当请求方法对应的 api 使用两个参数时，则第一个参数是请求的路径，第二个参数是处理该请求的处理函数
- 当请求方法对应的 api 使用三个或以上参数时，则第一个参数是请求路径，从第二个参数开始，可以传入多个中间件函数，最后一个参数是处理该请求的处理函数

  ```go
  import (
      "net/http"
      "github.com/gin-gonic/gin"
  )

  // 中间件函数
  func middleware1(c *gin.Context) {
      // 中间件逻辑
      c.Next()
  }
  func middleware2(c *gin.Context) {
      // 中间件逻辑
      c.Next()
  }

  func main() {
    r := gin.Default()

    // 全局使用中间件
    r.use(middleware1)

    // 定义 GET 请求路由
    r.GET("/hello1", func(c *gin.Context) {
      // 获取请求头字段
      userAgent := c.GetHeader("User-Agent")
      // 获取名为 "name" 的查询参数
      name := c.Query("name")
      // 获取名为 "age" 的查询参数，若不存在则使用默认值 "0"
      age := c.DefaultQuery("age", "0")
      c.JSON(http.StatusOK, gin.H{
        "User-Agent": userAgent,
        "name": name,
        "age": age,
      })
    })

    // 定义 Post 请求路由
    r.POST("/hello", middleware2, func(c *gin.Context) {
      // 获取名为 "username" 的表单参数
      username := c.PostForm("username")
      // 获取名为 "password" 的表单参数，若不存在则使用默认值 ""
      password := c.DefaultPostForm("password", "")
      c.JSON(http.StatusOK, gin.H{
        "username": username,
        "password": password,
      })
    })

    r.Run(":8080")
  }
  ```

#### 1.2 路由分组

- 支持路由分组，可以将相关的路由归为一组（ 且 group 是可以嵌套的 ），方便管理和设置公共的中间件

  ```go
  v1 := r.Group("/v1")

  v1.use(middleware) // 分组使用中间件
  v1.GET("/users", getUsers)
  v1.POST("/users", createUser)
  ```

## 2. 数据库框架

- gorm.io/gorm 是一个对象关系映射（ ORM ）库，可以帮助开发者更方便地与数据库进行交互
- 通过结构体标签让结构体和数据库关系表进行映射，设置的不同属性，通过 ';' 分割，标签 gorm 用法如下
  - column：指定字段名，如果不指定则默认是字段的小写驼峰格式，例 gorm:"column:usr_id;"
  - primaryKey：是否是主键，例 gorm:"column:usr_id;primaryKey"
  - unique：是否唯一，例 gorm:"column:usr_id;unique"
  - default：指定默认值，例 gorm:"column:usr_id;default:123"
  - -：忽略该字段，例 gorm:"-"
  - ->：只读，例 gorm:"->;column:usr_id"
  - <-：允许读和写，例 gorm:"<-;column:usr_id"
  - <-:update：允许读和更新，例 gorm:"<-:update;column:usr_id"
  - <-:create：允许读和创建，例 gorm:"<-:create;column:usr_id"
  - ->:false;<-:create：仅创建，例 gorm:"->:false;<-:create;column:usr_id"
- 以 MySQL 数据库为例

  ```go
  import (
    "gorm.io/driver/mysql"
    "gorm.io/gorm"
  )

  type User struct {
    Id int64
    Name string
  }

  type Comment struct {
    Id int64
    UserId int64
    VideoId int64
    Content string
  }

  func main() {
    dsn := "user:password@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local"
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        panic("failed to connect database")
    }

    /*
      AutoMigrate 方法会根据传入的结构体类型，自动创建或更新对应的数据库表结构
        如果数据库中不存在与传入结构体对应的表，会自动创建这些表
        如果数据库中已经存在对应的表，会检查结构体的字段定义与表结构是否一致
          如果有新增的字段，它会在表中添加这些字段
          如果字段的类型或约束发生了变化，它会尝试更新表结构以匹配代码中的定义
     */
    err = db.AutoMigrate(&UserInfo{}, &Comment{})
    if err != nil {
        panic("failed to connect database")
    }

    // 之后可以使用 db 进行数据库操作了
    // 新增
    user := User{Id: "001", Name: "John Doe"}
    result := db.Create(&user)
    if result.Error != nil {
      // 处理错误
    }
    // 查询
    var count int64
    err := DB.Model(&Comment{}).Where("id = ?", id).Count(&count).Error
  }
  ```

## 3. 读取配置文件

- 以 yaml 举例 为例，借助 gopkg.in/yaml.v3 第三方框架去解析
- config.yaml 文件配置如下

  ```yml
  # 数据库配置
  database:
    host: localhost
    port: 3306
    user: root
    password: gronk_20021218
    name: douyin
    parse_time: 100

  # 服务器配置
  server:
    port: 8080
  ```

- 需要声明结构体去对应，自动解析字段名对应的小写格式，注意，字段名需要是大写，不然解析不成功

  ```go
  type Config struct {
    Database
    Server
  }

  type Database struct {
    Host      string
    Port      string
    User      string
    Password  string
    Name      string
    ParseTime int64 `yaml:"parse_time"` // 映射非常笨，只是把所有大写变小写，并没有大驼峰转下划线
  }

  type Server struct {
    Port strinh
  }
  ```

- 借助第三方框架进行解析
  ```go
  fileData, err := os.ReadFile("./config/config.yaml")
  if err != nil {
    fmt.Println("读取文件失败：", err)
    return
  }
  fmt.Println("yaml 文件的内容: \n", string(fileData))
  config := Config{}
  err = yaml.Unmarshal(fileData, &config)
  if err != nil {
    fmt.Println("解析 yaml 文件失败：", err)
    return
  }
  fmt.Printf("config → %+v\n", config)
  ```
