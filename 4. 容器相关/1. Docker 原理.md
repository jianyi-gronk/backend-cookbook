## 1. 容器技术

- 容器是一种轻量级、可移植的虚拟化技术，它允许将应用程序及其依赖项打包在一个独立的运行环境中
- 容器在操作系统级别提供资源隔离和独立的运行空间，使得应用程序可以在不同的环境中一致地运行，而无需担心底层系统的差异
- 容器技术相较于传统的虚拟机技术具有更低的资源开销、更快的启动速度和更高的性能

## 2. Docker 特性

- 环境一致性：
  - Docker 容器包含应用程序及其所有依赖项，确保在不同环境中运行时的一致性，这可以避免因环境差异导致的 “在我电脑上可以运行” 的问题
  - Docker 的跨平台特性主要得益于它能够在所有平台下使用 Linux 环境（ Docker for Windows 就是在所有平台下都使用 Windows 环境 ）
- 轻量级虚拟化：
  - 与传统的虚拟机不同，Docker 容器共享宿主操作系统内核，因此它们比虚拟机更轻量级且启动更快
  - 此外，Docker 容器可以轻松地在不同的环境中运行，包括物理机、虚拟机、公有云和私有云
- 可移植性：
  - 由于 Docker 容器包含应用程序及其所有依赖项，因此它们可以在任何支持 Docker 的平台上运行，无论是开发者的本地机器还是生产环境的服务器
- 易于管理和部署：
  - Docker 提供了一系列命令和工具，以便轻松地创建、运行和管理容器
  - 此外，Docker 可以与许多现有的持续集成/持续部署（ CI/CD ）工具和平台无缝集成，从而简化了部署过程
- 隔离性：
  - Docker 容器在彼此之间和宿主系统之间是隔离的，这意味着它们可以在安全的沙箱环境中运行
  - 这有助于确保应用程序之间不会相互干扰，同时提高了安全性
- 可扩展性：
  - Docker 可以与像 Kubernetes 和 Docker Swarm 这样的容器编排平台集成，以便在集群中自动部署、扩展和管理容器。这使得将应用程序从单个实例扩展到多个实例变得更加简单

## 3. 传统容器 和 Docker

- 传统容器：
  - 传统的 PaaS 技术虽然也可以一键将本地应用部署到云上，并且也是采用隔离环境（ 容器 ）的形式去部署，但是其兼容性非常的不好
  - 因为其主要原理就是将本地应用程序和启停脚本一同打包，然后上传到云服务器上，然后再在云服务器里通过脚本启动这个应用程序
  - 但是在实际情况下，由于本地与云端的环境差异，导致上传到云端的应用经常各种报错、运行不起来，需要各种修改配置和参数来做兼容。甚至在项目迭代过程中不同的版本代码都需要重新去做适配，非常耗费精力
- Docker
  - 然后在 Docker 的方案中，它不仅打包了本地应用程序，而且还将本地环境（ 操作系统的一部分 ）也打包了，组成一个叫做 Docker 镜像 的文件包
  - 所以这个 Docker 镜像 就包含了应用运行所需的全部依赖，我们可以直接基于这个 Docker 镜像 在本地进行开发与测试，完成之后，再直接将这个 Docker 镜像 一键上传到云端运行即可

## 4. 虚拟机 和 Docker

#### 4.1 原理区别

- 下图的左侧是 虚拟机 的原理，右侧是 Docker 容器 的原理
  ![image](https://img-blog.csdnimg.cn/7bc41f1c86a0468cab74971744db8b62.png)
- 虚拟机
  - 虚拟机是在宿主机上基于 Hypervisor 软件虚拟出一套操作系统所需的硬件设备，再在这些虚拟硬件上安装操作系统 Guest OS，然后不同的应用程序就可以运行在不同的 Guest OS 上，应用之间也就相互独立、资源隔离了
  - 但是由于需要 Hypervisor 来创建虚拟机，且每个虚拟机里需要完整的运行一套操作系统 Guest OS，因此这个方式会带来很多额外资源的开销
  - 并且虚拟机对硬件的利用率存在瓶颈，因为虚拟机很难根据当前业务量动态调整其占用的硬件资源
- Docker
  - 而 Docker 容器 中却没有 Hypervisor 这一层，虽然它需要在宿主机中运行 Docker Engine，但它的原理却完全不同于 Hypervisor，它并没有虚拟出硬件设备，更没有独立部署全套的操作系统 Guest OS
  - **Docker 容器没有那么复杂的实现原理，它其实就是一个普通进程而已，只不过它是一种经过特殊处理过的普通进程**
  - 我们启动容器的时候（ docker run ... ），Docker Engine 只不过是启动了一个进程，这个进程就运行着我们容器里的应用。但 Docker Engine 对这个进程做了一些特殊处理，通过这些特殊处理之后，这个进程所看到的外部环境就不再是宿主机的那个环境了（ 它看不到宿主机中的其它进程了，以为自己是当前操作系统唯一一个进程 ），并且 Docker Engine 还对这个进程所使用得资源进行了限制，防止它对宿主机资源的无限使用
- 两者特性差别如下
  ![image](https://img-blog.csdnimg.cn/4a5ab228c348453cb60e22cef45bc3e0.png)

#### 4.2 业务场景 和 特性 差别

- Docker 和 VMware 都是虚拟化技术，但它们有不同的关注点和应用场景
  - Docker 更适合轻量级、跨平台的应用程序虚拟化
  - 而 VMware 更适合完整的操作系统虚拟化和企业级数据中心管理
- 虚拟化类型：
  - Docker 是一种容器虚拟化技术，它主要用于隔离应用程序及其依赖项，而不是整个操作系统。容器共享宿主机的内核，因此它们比传统虚拟机更轻量级
  - VMware 是一种硬件虚拟化技术，它允许在一个物理机上运行多个完整的操作系统实例（ 称为虚拟机 ）。每个虚拟机都有自己的内核和操作系统，因此资源开销相对较大
- 性能：
  - 由于 Docker 容器共享宿主机的内核且不需要运行整个操作系统，它们的启动和运行速度通常比 VMware 虚拟机更快
  - 此外，Docker 容器对系统资源的需求较低，因此可以在同一硬件上运行更多容器实例
- 可移植性：
  - Docker 容器可以在不同的平台和环境之间轻松迁移。只要宿主机上安装了 Docker，就可以在其中运行容器，而无需担心底层操作系统和硬件的差异
  - 虚拟机的可移植性较低，因为它们包含完整的操作系统环境，可能需要额外的配置才能在不同的硬件和虚拟化平台之间迁移
- 生态系统：
  - Docker 拥有庞大的开源生态系统，提供了丰富的预构建容器镜像和工具，可以方便地部署和管理应用程序
  - VMware 也有自己的生态系统，但主要针对企业级虚拟化和数据中心管理

## 5. Docker 原理

#### 5.1 Docker 镜像原理 —— 本质

- **一个基础的容器镜像其实就是一个 rootfs**，它包含操作系统的文件系统（ 文件和目录 ），但并不包含操作系统的内核
  - rootfs（ root filesystem，根文件系统 ）是 Linux 操作系统中的一个术语，指的是操作系统文件系统层次结构（ 称为文件系统树 ）的根目录（ / ）
  - rootfs 包含了系统运行所需的所有文件和目录，如可执行文件、库文件、配置文件、设备文件等
- 容器里根目录上挂载的一个全新的文件系统（ rootfs ），此文件系统与宿主机的文件系统无关，是一个完全独立的，用于给容器进行提供环境的文件系统
- 对于一个 Docker 容器而言，需要基于 pivot_root 指令，将容器的根文件系统切换到一个新的、与宿主机隔离的文件系统上（ 即 rootfs ）
  - 这样，容器内的进程将在这个新的文件系统中运行，从而实现与宿主机环境的隔离，也正是有了 rootfs，才能实现基于容器的本地应用与云端应用运行环境的一致
  - pivot_root 是 Linux 操作系统中的一个系统调用（ system call ），它用于改变当前运行进程及其子进程的 rootfs

#### 5.2 Docker 镜像原理 —— 层

- 为了方便镜像的复用，Docker 在镜像中引入了层（ Layer ）的概念，可以将不同的镜像一层一层的迭在一起。这样，如果我们要做一个新的镜像，就可以基于之前已经做好的某个镜像的基础上继续做
- 如下图，这个例子中最底层是 bootfs，往上一层就是基础镜像层（ Linux 的文件系统 ），再往上就是我们需要的各种应用镜像（ 叠加在一起 ），Docker 会把这些镜像联合挂载在一个挂载点上。当容器启动的时候一个新的层被加载到镜像的顶部，这一层就是我们说的容器层，容器之下都是镜像。**镜像层都是只读的，只有最上面的容器层是可读可写的**
  ![image](https://img-blog.csdnimg.cn/324f967d488b47bfb9bcf9a184763021.png)
- bootfs（ boot filesystem，操作系统引导 ）
  - bootfs 是 Linux 操作系统中负责启动过程的一个小型文件系统，主要目的是为操作系统的启动过程提供必要的支持
  - bootfs 包含了用于引导操作系统的最基本、最关键的程序和文件，例如内核映像（ kernel image ）、引导加载程序（ bootloader ）和初始化内存磁盘映像（ initramfs image ）等
- 这种分层的方案其实是基于 **联合文件系统 UnionFS（ Union File System ）** 的技术实现的。它可以将不同的目录全部挂载在同一个目录下。所以一次同时加载多个文件系统，但外面看起来这只能看到一个文件系统，因为联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录

#### 5.3 Docker 镜像原理 —— 举例

- 举个例子，假如有文件夹 test1 和 test2 ，这两个文件夹里面的文件 有相同的，也有不同的。然后我们可以采用联合挂载的方式，将这两个文件夹挂载到 test3 上，那么 test3 目录里就有了 test1 和 test2 的所有文件（相同的文件有去重，不同的文件都保留）
- 这个原理应用在 Docker 镜像中，比如有 2 个同学，同学 A 已经做好了一个基于 Linux 的 Java 环境的镜像，同学 S 想搭建一个 Java Web 环境，那么他就不必再去做 Java 环境的镜像了，可以直接基于同学 A 的镜像在上面增加 Tomcat 后生成新镜像即可

## 6. 核心概念

#### 6.1 基础概括

- Docker 镜像是由本地环境（ 操作系统的一部分 ）打包而成，从而实现可移植性
- Docker 容器的核心概念，资源的 隔离 和 限制，主要通过 2 个技术点
  ![image](https://img-blog.csdnimg.cn/644601dadeda45ff8d120319e9c8463c.png)
  - Namespace 技术（ 实现隔离 ）
  - Cgroups 技术（ 实现限制 ）

#### 6.2 Namespace 技术

- **Namespace 技术其实就是修改了应用进程的视觉范围，但应用进程的本质却没有变化**
- Namespace 并不是一个什么新技术，它是 Linux 操作系统默认提供的 API，包括 PID Namespace、Mount Namespace、IPC Namespace、Network Namespace 等等
- 以 PID Namespace 举例，它的功能是可以让我们在创建进程的时候，告诉 Linux 系统，我们要创建的进程需要一个新的独立的进程空间，并且这个进程在这个新的进程空间里的 PID=1，也就是说这个进程只看得到这个新进程空间里的东西，看不到外面宿主机环境里的东西，也看不到其它进程（ 不过这只是一个虚拟空间，事实上这个进程在宿主机里 PID 该是啥还是啥，没有变化，只不过在这个进程空间里，该进程以为自己的 PID=1 ）
- 打个比方，就像是一个班级，每个人在这个班里都有一个编号，班里有 90 人，然后来了一位新同学，那他在班里的编号就是 91，可是老师为了给这位同学特别照顾，所以在班里开辟了一块独立的看不到外面的小隔间，并告诉这个同学他的编号是 1，由于这位同学在这个小空间里隔离着，所以他真的以为自己就是班上的第一位同学且编号为 1，当然了，事实上这位同学在班上的编号依然是 91
- 另外，Network Namespace 的技术原理也是类似的，让这个进程只能看到当前 Namespace 空间里的网络设备，看不到宿主机真实情况。同理，其它 Mount、IPC 等 Namespace 也是这样
- 不过，Docker 容器里虽然带有一部分操作系统（ 文件系统相关 ），但它并没有内核，因此多个容器之间是共用宿主机的操作系统内核的。这一点与虚拟机的原理是完全不一样的

#### 6.3 Cgroups 技术

- **Cgroup 全称是 Control Group，其功能就是限制进程组所使用的最大资源（ 这些资源可以是 CPU、内存、磁盘等等 ）**
- 既然 Namespace 技术 只能改变一下进程组的视觉范围，并不能真实的对资源做出限制。那么为了防止容器（ 进程 ）之间互相抢资源，甚至某个容器把宿主机资源全部用完导致其它容器也宕掉的情况发生。因此，必须采用 Cgroup 技术对容器的资源进行限制
- Cgroup 技术也是 Linux 默认提供的功能，在 Linux 系统的 /sys/fs/cgroup 下面有一些子目录 cpu、memory 等，Cgroup 技术提供的功能就是可以基于这些目录实现对这些资源进行限制
- 例如：在 /sys/fs/cgroup/cpu 下面创建一个 dockerContainer 子目录，系统就会自动在这个新建的目录下面生成一些配置文件，这些配置文件就是用来控制资源使用量的。例如可以在这些配置文件里面设置某个进程 ID 对 CPU 的最大使用率
- Cgroup 对其它内存、磁盘等资源也是采用同样原理做限制
