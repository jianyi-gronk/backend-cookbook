## 1. 数据持久化方式

- 容器中的数据可以存储在容器层，但存在以下问题：
  - 数据不是持久化，即如果容器删除了，这些数据也就没了
  - 主机上的其它进程不方便访问这些数据
  - 对这些数据的 I/O 会经过存储驱动，然后到达主机，引入了一层间接层，因此性能会有所下降
- Docker 提供了 3 种持久化数据的方式：
  - volumes（ 最常用的方式 ）
  - Bind Mount（ 比较常用的方式 ）
  - Tmpfs Mount（ 一般都不会用的方式 ）
- 三种方式的示意图如下所示
  ![image](https://github.com/user-attachments/assets/2c68d3b9-f99e-4ca9-9036-4bd9a4632ef7)

## 2 Volume

#### 2.1 介绍

- 创建容器时会将容器内文件映射到 docker volume 的相应目录上，并且不管宿主机还是容器内操作挂载目录中的文件都是互通的
- volume 的存储是在 docker 安装目录内，卸载 docker 会丢失。默认位于 /var/lib/docker/volumes 目录中，由 Docker 管理，非 Docker 进程不应该修改这些数据
- 由下图可以知道，目前所有 Container 的数据都保存在了这个目录下边，由于没有在创建时指定卷，所以 Docker 帮我们默认创建许多匿名卷（ 就下面这一堆很长 ID 的名字 ）
  ![image](https://github.com/user-attachments/assets/d708c381-a415-4c92-a974-180d79acaba1)
- 如果没有显式创建，一个卷会在最开始挂载时被创建。当容器停止时，卷仍然存在。多个容器可以通过 read-write 或 read-only 的方式使用同一个卷
- 只有在显式删除时，卷才会被删除。如果将一个空卷挂载到容器中一个存有文件或目录的目录中，这些文件或目录会被拷贝到空卷中；如果将一个非空卷挂载到容器中一个存有文件或目录的目录中，这些文件或目录会被隐藏

#### 2.2 使用

- 创建卷
  ```
  # 匿名目录，会自动生成的很长串的 vloume 名
  docker volume create
  # 具名目录
  docker volume create test
  ```
- 列出所有卷
  ```
  docker volume ls
  ```
- 删除某个卷
  ```
  docker volume rm 卷名
  ```
- 查看某个卷的信息
  ```
  docker volume inspect 卷名
  ```
- 删除所有未使用的卷
  ```
  docker volume prune
  ```

#### 2.3 场景

- 多个运行容器间共享数据
- 备份、恢复、或将数据从一个 Docker 主机迁移到另一个 Docker 主机时
- 当 Docker 主机不确保具有给定的目录或文件时。卷可以将容器运行时与 Docker 主机的配置解耦合

## 3. Bind Mount

#### 3.1 介绍

- 可以存于主机文件系统中的任意位置，主机中的文件或目录通过全路径被引用，非 Docker 进程可以修改这些数据
- 需要手动在宿主机上创建挂载的目录（ 或者利用现有的 ），数据直接存在了宿主机硬盘上，删除容器或者卸载 docker，数据并不会消失
- 但是，bind mount 在不同的宿主机系统时不可移植的，比如 Windows 和 Linux 的目录结构是不一样的，bind mount 所指向的 host 目录也不能一样。这也是为什么 bind mount 不能出现在 Dockerfile 中的原因，因为这样 Dockerfile 就不可移植了
- 如果使用这种方式将一个目录挂载到容器中一个存有文件或目录的目录中，这些文件或目录会被隐藏；如果主机中的文件或目录不存在，当使用--mount 挂载时，Docker 会报错，当使用 -v 或--volume 时，会在主机上创建目录

#### 3.2 场景

- 一般来说，只要可能，最好使用 volumes
- 主机与容器共享配置文件，Docker 默认情况下通过这种方式为容器提供 DNS 解析，通过将 /etc/resolv.conf 挂载到容器中
- 共享源代码或 build artifacts，比如将 Maven 的 target/ 目录挂载到容器中，每次在 Docker 主机中 build Maven 工程时，容器能够访问到那些 rebuilt artifacts
- 当 docker 主机中的文件或目录结构和容器需要的一致时

## 4. Tmpfs Mount

#### 4.1 介绍

- 只在 linux 中支持，存储在宿主机系统的内存中，注意并不是持久化到磁盘
- 不同于 volumes 和 bind mount
  - 多个容器无法共享 tmpfs mount
  - tmpfs mount 是临时的，只在主机内存中持久化。当容器停止，tmpfs mount 会被移除。在容器的生命周期中，它能被容器用来存放非持久化的状态或敏感信息

#### 4.2 场景

- 当用户既不想将数据存于主机，又不想存于容器中时。这时可以是出于安全的考虑，或当应用需要写大量非持久性的状态数据时为了保护容器的性能

## 5. 挂载卷性能调优

- volume 和 bind mount 都可以使用 -v 或 --volume 标志安装到容器中
- 在 macOS（ 和其他非 Linux 平台 ）上，保证容器内和主机文件一致性的开销很大。然而，在许多情况下，容器与主机之间不需要完美的一致性。区分不同情况可以显着提高性能
- 通过在 docker run -v， --volume 的 option 中指定 cached 或 delegated，可以显着提高 Docker Desktop for Mac 上已装载卷访问的性能。您可以根据情况调整所需的一致性级别：
  - consistent：默认值，完美的一致性，即主机和容器实时一致
  - cached：主机具有权威性。容器执行的写操作对主机是立即可见的，但是在主机上执行的写操作可能不会立即反应在容器内
  - delegated：容器的内容具有权威性。提供最弱保证，由容器执行的写操作可能不会立即反映在主机文件系统上，提供的性能要比其他配置好得多
