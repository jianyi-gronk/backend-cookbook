## 1. Kafka

- Kafka 是由 Linkedin 公司开发的，它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台，它同时也是一款开源的基于发布订阅模式的消息引擎系统
  ![image](https://github.com/user-attachments/assets/8b9e45e4-aa7c-41fa-ac10-f6dd66b33a6d)

## 2. 基本概念

- 消息：Kafka 中的数据单元被称为消息，也被称为记录，可以把它看作数据库表中某一行的记录
- 批次：为了提高效率， 消息会分批次写入 Kafka，批次就代指的是一组消息
- 主题：消息的种类称为 主题（ Topic ），可以说一个主题代表了一类消息，相当于是对消息进行分类。主题就像是数据库中的表
- 分区：主题可以被分为若干个分区（ partition ），同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性，单一主题中的分区有序，但是无法保证主题中所有的分区有序
  ![image](https://github.com/user-attachments/assets/13eb123c-abf4-4cee-a4b3-ec8d03ec3bfe)
- 生产者：向主题发布消息的客户端应用程序称为生产者（ Producer ），生产者用于持续不断的向某个主题发送消息
- 消费者：订阅主题消息的客户端程序称为消费者（ Consumer ），消费者用于处理生产者产生的消息
- 消费者群组：生产者与消费者的关系就如同餐厅中的厨师和顾客之间的关系一样，一个厨师对应多个顾客，也就是一个生产者对应多个消费者，消费者群组（ Consumer Group ）指的就是由一个或多个消费者组成的群体
  ![image](https://github.com/user-attachments/assets/edd26c16-5411-4015-a116-32d6c78cb754)
- 偏移量：偏移量（ Consumer Offset ）是一种元数据，它是一个不断递增的整数值，用来记录消费者发生重平衡时的位置，以便用来恢复数据
- broker: 一个独立的 Kafka 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存
- broker 集群：broker 是集群 的组成部分，broker 集群由一个或多个 broker 组成，每个集群都有一个 broker 同时充当了集群控制器的角色（ 自动从集群的活跃成员中选举出来 ）
- 副本：Kafka 中消息的备份又叫做 副本（ Replica ），副本的数量是可以配置的，Kafka 定义了两类副本：领导者副本（ Leader Replica ）和 追随者副本（ Follower Replica ），前者对外提供服务，后者只是被动跟随
- 重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段

## 3. 系统架构

- 一个典型的 Kafka 集群中包含
  - 若干 Producer（ 可以是 web 前端产生的 Page View，或是服务器日志，系统 CPU、Memory 等 ）
  - 若干 broker（ Kafka 支持水平扩展，一般 broker 数量越多，集群吞吐率越高 ）
  - 若干 Consumer Group
  - 一个 Zookeeper 集群
- Kafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息
  ![image](https://github.com/user-attachments/assets/f9f487ea-a5a6-4117-907c-d7c2526d0531)

## 4. 生产者

#### 4.1 数据执行流程

- 在 Kafka 中，把产生消息的那一方称为生产者
- 比如我们经常会去淘宝购物，你打开淘宝的那一刻，你的登陆信息，登陆次数都会作为消息传输到 Kafka 后台，当你浏览购物的时候，你的浏览信息，你的搜索指数，你的购物爱好都会作为一个个消息传递给 Kafka 后台，然后淘宝会根据你的爱好做智能推荐，那么这些生产者产生的消息是怎么传到 Kafka 应用程序的呢？发送过程是怎么样的呢？
- 尽管消息的产生非常简单，但是消息的发送过程还是比较复杂的。创建对象（ 主题、分区、key/value ）-> 序列化数据 -> 到达分区（ 可自己指定，也可以通过 key hash ）-> 放入批次（ 相同主题和分区 ） -> 独立线程发送 -> 返回主题/分区/分区偏移量/时间戳
  ![image](https://github.com/user-attachments/assets/11db26ca-774d-4f3f-b897-df6ed98f3ccc)
- 我们从创建一个 ProducerRecord 对象开始，ProducerRecord 是 Kafka 中的一个核心类，它代表了一组 Kafka 需要发送的 key/value 键值对，它由记录要发送到的主题名称（ Topic Name ），可选的分区号（ Partition Number ）以及可选的键值对构成
- 在发送 ProducerRecord 时，我们需要将键值对对象由序列化器转换为字节数组，这样它们才能够在网络上传输
- 然后消息到达了分区器。如果发送过程中指定了有效的分区号，那么在发送记录时将使用该分区。如果发送过程中未指定分区，则将使用 key 的 hash 函数映射指定一个分区。如果发送的过程中既没有分区号也没有 hash 映射，则将以循环的方式分配一个分区。选好分区后，生产者就知道向哪个主题和分区发送数据了。ProducerRecord 还有关联的时间戳，如果用户没有提供时间戳，那么生产者将会在记录中使用当前的时间作为时间戳。Kafka 最终使用的时间戳取决于 topic 主题配置的时间戳类型。然后，这条消息被存放在一个记录批次里，这个批次里的所有消息会被发送到相同的主题和分区上。由一个独立的线程负责把它们发到 Kafka Broker 上
- Kafka Broker 在收到消息时会返回一个响应，如果写入成功，会返回一个 RecordMetaData 对象，它包含了主题和分区信息，以及记录在分区里的偏移量，上面两种的时间戳类型也会返回给用户。如果写入失败，会返回一个错误。生产者在收到错误之后会尝试重新发送消息，几次之后如果还是失败的话，就返回错误消息

#### 4.2 分区策略

- Kafka 对于数据的读写是以分区为粒度的，分区可以分布在多个主机（ Broker ）中，这样每个节点能够实现独立的数据写入和读取，并且能够通过增加新的节点来增加 Kafka 集群的吞吐量，通过分区部署在多个 Broker 来实现负载均衡的效果
- 方式 1：顺序轮询
  ![image](https://github.com/user-attachments/assets/2874bc10-c45d-440c-b91b-67b522986bd2)
  - 顺序分配，消息是均匀的分配给每个 partition，即每个分区存储一次消息，见下图。轮训策略是 Kafka Producer 提供的默认策略，如果你不使用指定的轮训策略的话，Kafka 默认会使用顺序轮训策略的方式
- 方式 2：随机轮询
  ![image](https://github.com/user-attachments/assets/9ad03d11-ecc6-41db-92fc-0a554f15ff28)
  - 本质上看随机策略也是力求将数据均匀地打散到各个分区，但从实际表现来看，它要逊于轮询策略，所以如果追求数据的均匀分布，还是使用轮询策略比较好。事实上，随机策略是老版本生产者使用的分区策略，在新版本中已经改为轮询了
- 方式 3：key hash
  ![image](https://github.com/user-attachments/assets/ee878fa7-c73c-4ab9-bab1-45780e1a8a79)
  - 这个策略也叫做 key-ordering 策略，Kafka 中每条消息都会有自己的 key，一旦消息被定义了 Key，那么你就可以保证同一个 Key 的所有消息都进入到相同的分区里面，由于每个分区下的消息处理都是有顺序的，故这个策略被称为按消息键保序策略（ 但是一个分区里不保证只有一种 Key ）

## 5. 消费者

#### 5.1 消费者群组

- 应用程序首先需要创建一个 KafkaConsumer 对象，从 Kafka 中订阅主题并开始接收来自这些主题的消息，验证消息并保存结果
- 但是一段时间后，如果生产者往主题写入的速度超过了应用程序验证数据的速度，这时候该如何处理？如果只使用单个消费者的话，应用程序会跟不上消息生成的速度，就像多个生产者向相同的主题写入消息一样，这时候就需要多个消费者共同参与消费主题中的消息，对消息进行分流处理。Kafka 消费者从属于消费者群组。一个群组中的消费者订阅的都是相同的主题，每个消费者接收主题一部分分区的消息
- 主题 T1 有四个分区，分别是分区 0、分区 1、分区 2、分区 3，我们创建一个消费者群组 1，消费者群组中只有一个消费者，它订阅主题 T1，接收到 T1 中的全部消息。由于一个消费者处理四个生产者发送到分区的消息，压力有些大，需要帮手来帮忙分担任务
  ![image](https://github.com/user-attachments/assets/33aeb51e-a44c-46e5-acf7-2cf3e5557437)
  ![image](https://github.com/user-attachments/assets/7502a8ee-4170-4d2f-ac23-f659b750134e)
  ![image](https://github.com/user-attachments/assets/d9091c82-e1b1-4cf1-a824-0ebd7a203478)
- 向群组中增加消费者是水平扩展提升消费能力的主要方式。这也是为什么建议创建主题时使用比较多的分区数，这样可以在消费负载高的情况下增加消费者来提升性能。另外，消费者的数量不应该比分区数多，因为多出来的消费者是空闲的，没有任何帮助
- Kafka 一个很重要的特性就是，只需写入一次消息，可以支持任意多的应用读取这个消息。换句话说，每个应用都可以读到全量的消息。为了使得每个应用都能读到全量消息，应用需要有不同的消费组。对于上面的例子，假如我们新增了一个新的消费组 G2，而这个消费组有两个消费者，那么就演变为下图这样。在这个场景中，消费组 G1 和消费组 G2 都能收到 T1 主题的全量消息，在逻辑意义上来说它们属于不同的应用
- 如果应用需要读取全量消息，那么请为该应用设置一个消费组；如果该应用消费能力不足，那么可以考虑在这个消费组里增加消费者
  ![image](https://github.com/user-attachments/assets/de3912cb-a61f-4a60-bcc2-e85abaf0a5dd)

#### 5.2 消费者重平衡

- 从消费者演变中可以知道，最初是一个消费者订阅一个主题并消费其全部分区的消息，后来有一个消费者加入群组，随后又有更多的消费者加入群组，而新加入的消费者实例分摊了最初消费者的部分消息，这种把分区的所有权通过一个消费者转到其他消费者的行为称为重平衡（ Rebalance ）
- 重平衡非常重要，它为消费者群组带来了高可用性 和 伸缩性，我们可以放心的添加消费者或移除消费者，不过在正常情况下我们并不希望发生这样的行为。在重平衡期间，消费者无法读取消息，造成整个消费者组在重平衡的期间都不可用。另外，当分区被重新分配给另一个消费者时，消息当前的读取状态会丢失，它有可能还需要去刷新缓存，在它重新恢复状态之前会拖慢应用程序
- 消费者通过向组织协调者（ Kafka Broker ）发送心跳来维护自己是消费者组的一员并确认其拥有的分区。对于不同不的消费群体来说，其组织协调者可以是不同的。只要消费者定期发送心跳，就会认为消费者是存活的并处理其分区中的消息。当消费者检索记录或者提交它所消费的记录时就会发送心跳。如果过了一段时间 Kafka 停止发送心跳了，会话（ Session ）就会过期，组织协调者就会认为这个 Consumer 已经死亡，就会触发一次重平衡。如果消费者宕机并且停止发送消息，组织协调者会等待几秒钟，确认它死亡了才会触发重平衡。在这段时间里，死亡的消费者将不处理任何消息。在清理消费者时，消费者将通知协调者它要离开群组，组织协调者会触发一次重平衡，尽量降低处理停顿
- 重平衡是一把双刃剑，它为消费者群组带来高可用性和伸缩性的同时，还有有一些明显的缺点（ bug ），而这些 bug 到现在社区还无法修改。重平衡的过程对消费者组有极大的影响。因为每次重平衡过程中都会导致万物静止，参考 JVM 中的垃圾回收机制，也就是 Stop The World ，STW。也就是说，在重平衡期间，消费者组中的消费者实例都会停止消费，等待重平衡的完成。而且重平衡这个过程通常很慢

## 6. 特性分析

- 消息路由（ 不支持 ）：Kafka 在处理消息之前是不允许消费者过滤一个主题中的消息。一个订阅的消费者在没有异常情况下会接受一个分区中的所有消息
- 消息有序（ 支持 ）：当消费消息时，如果消费失败，消息不会被放回，所以整个消费过程都是有序进行
- 消息时序（ 不支持 ）：消息直接发送，不会延迟发送，或者指定消息的 TTL
- 容错处理（ 集群支持 / 消息不支持 ）：集群容错能力高，因为是分布式部署，但是消息容错处理弱，因为消息消费失败，需要程序员手动处理，Kafka 不支持消息重新进行消费
- 伸缩（ 非常好 ）：通过扩充分区和消费者数量，实现分区扩容，并提升消费速度
- 持久化（ 非常好 ）：数据存储在磁盘，可以随时订阅消费，消费完后，数据仍然保留
- 消息回溯（ 支持 ）：因为消息支持持久化，就支持回溯，可以理解是附带的功能
- 高吞吐（ 非常好 ）：因为 Kafka 内部同一个主题包含多个分区，所以实现分布式存储，然后消费者数量可以扩充到和分区数量一致，保证了 Kafka 的高吞吐

## 7. 提示

- 在 Kafka 2.8 之前，Kafka 最被大家诟病的就是其重度依赖于 Zookeeper 做元数据管理和集群的高可用。在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，大大简化了 Kafka 的架构，让你可以以一种轻量级的方式来使用 Kafka
- 不过，如果要使用 KRaft 模式的话，建议选择较高版本的 Kafka，因为这个功能还在持续完善优化中。Kafka 3.3.1 版本是第一个将 KRaft（ Kafka Raft ）共识协议标记为生产就绪的版本
