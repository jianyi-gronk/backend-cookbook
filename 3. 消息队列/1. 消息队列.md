## 1. 消息队列

#### 1.1 什么是消息队列

- 消息队列属于中间件，中间件就是一类为应用软件服务的软件，应用软件是为用户服务的，用户不会接触或者使用到中间件。除了消息队列之外，常见的中间件还有 RPC 框架、分布式组件、HTTP 服务器、任务调度框架、配置中心、数据库层的分库分表工具和数据迁移工具等等
- 消息队列指的是各个服务以及系统内部各个组件 / 模块之前的通信。可以把消息队列看作是一个存放消息的容器，当需要使用消息的时候，直接从容器中取出消息供自己使用即可。由于队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的
- 参与消息传递的双方称为 生产者 和 消费者 ，生产者负责发送消息，消费者负责处理消息

#### 1.2 消息队列的作用

- 使用消息队列主要能为系统带来下面三点好处：
  - 异步处理
  - 流量削峰
  - 系统解耦
- 除此之外，消息队列还有其他的一些应用场景，例如实现分布式事务、顺序保证和数据流处理等

#### 1.3 异步处理

- 将用户请求中包含的耗时操作，通过消息队列实现异步处理，将对应的消息发送到消息队列之后就立即返回结果，减少响应时间，提高用户体验。随后，系统再对消息进行消费
  ![image](https://github.com/user-attachments/assets/e4265e4d-84f2-4d04-8926-df0e95cb14b6)
- 因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似平时手机订火车票和电影票

#### 1.4 流量削峰

- 先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉
- 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：
  ![image](https://github.com/user-attachments/assets/604a1f1a-ddda-41ed-adfe-c66fef5c993f)

#### 1.5 系统解耦

- 使用消息队列还可以降低系统耦合性。如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些
- 生产者（ 客户端 ）发送消息到消息队列中去，消费者（ 服务端 ）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性
  ![image](https://github.com/user-attachments/assets/8fc0d710-13b9-4a1e-bb1a-722e6811833a)
- 消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息
- 消息发送者（ 生产者 ）和消息接受者（ 消费者 ）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计
- 例如，商城系统分为用户、订单、财务、仓储、消息通知、物流、风控等多个服务。用户在完成下单后，需要调用财务（ 扣款 ）、仓储（ 库存管理 ）、物流（ 发货 ）、消息通知（ 通知用户发货 ）、风控（ 风险评估 ）等服务。使用消息队列后，下单操作和后续的扣款、发货、通知等操作就解耦了，下单完成发送一个消息到消息队列，需要用到的地方去订阅这个消息进行消息即可
  ![image](https://github.com/user-attachments/assets/792434dd-39c8-40ae-8ebd-6e044eae6a7c)
- 另外，为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息
- 注意，不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（ 一个消息只有一个消费者 ），我们比较常用的是发布-订阅模式。另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了另外 5 种消息模型

#### 1.6 其他特性

- 顺序保证
  - 在很多应用场景中，处理数据的顺序至关重要。消息队列保证数据按照特定的顺序被处理，适用于那些对数据顺序有严格要求的场景。大部分消息队列，例如 RocketMQ、RabbitMQ、Pulsar、Kafka，都支持顺序消息
- 延时 / 定时处理
  - 消息发送后不会立即被消费，而是指定一个时间，到时间后再消费。大部分消息队列，例如 RocketMQ、RabbitMQ、Pulsar、Kafka，都支持定时/延时消息
- 即时通讯
  - MQTT（ 消息队列遥测传输协议 ）是一种轻量级的通讯协议，采用发布/订阅模式，非常适合于物联网（ IoT ）等需要在低带宽、高延迟或不可靠网络环境下工作的应用。它支持即时消息传递，即使在网络条件较差的情况下也能保持通信的稳定性
  - RabbitMQ 内置了 MQTT 插件用于实现 MQTT 功能（ 默认不启用，需要手动开启 ）
- 数据流处理
  - 针对分布式系统产生的海量数据流，如业务日志、监控数据、用户行为等，消息队列可以实时或批量收集这些数据，并将其导入到大数据处理引擎中，实现高效的数据流管理和处理

#### 1.7 引入问题

- 系统可用性降低：系统可用性在某种程度上降低，在加入 MQ 之前，不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后就需要去考虑了
- 系统复杂性提高：加入 MQ 之后，需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题
- 一致性问题：消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息，这样就会导致数据不一致的情况了

## 2. JMS 和 AMQP

#### 2.1 JMS 是什么

- JMS（ JAVA Message Service，java 消息服务 ）是 Java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输
- JMS API 是一个消息服务的标准或者说是规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性
- JMS 定义了五种不同的消息正文格式以及调用的消息类型，允许发送并接收以一些不同形式的数据：
  - StreamMessage：Java 原始值的数据流
  - MapMessage：一套键值对
  - TextMessage：一个字符串对象
  - ObjectMessage：一个序列化的 Java 对象
  - BytesMessage：一个字节的数据流
- ActiveMQ（ 已被淘汰 ） 就是基于 JMS 规范实现的

#### 2.2 JMS 两种消息模型

- 点到点（ P2P ）模型
  ![image](https://github.com/user-attachments/assets/c4e40037-eb01-4b90-a47b-476c1cfe8cff)
  - 使用队列（Queue）作为消息通信载体；满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时
  - 比如：生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（ 也就是你一个我一个的消费 ）
- 发布 / 订阅（ Pub / Sub ）模型
  ![image](https://github.com/user-attachments/assets/ddfdf827-2a04-4a2e-b02d-4470fdea7ec8)
  - 发布订阅模型（ Pub/Sub ） 使用主题（ Topic ）作为消息通信载体，类似于广播模式，发布者发布一条消息，该消息通过主题传递给所有的订阅者

#### 2.3 AMQP 是什么

- AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 高级消息队列协议（ 二进制应用层协议 ），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受不同的开发语言等条件的限制
- RabbitMQ 就是基于 AMQP 协议实现的

#### 2.4 JMS 对比 AMQP

- JMS 对比 AMQP
  ![image](https://github.com/user-attachments/assets/0a84511d-7eb3-46e4-95fd-a94bdd5b4b9a)
- AMQP 为消息定义了线路层（ wire-level protocol ）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性
- JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（ 复杂的类型可序列化后发送 ）
- 由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 发布 / 订阅 方式两种

## 3. 消息队列选型

#### 3.1 常见框架

- 常见框架有 RabbitMQ，RocketMQ，Kafka 等
  ![image](https://github.com/user-attachments/assets/e10583c2-cbd0-4b30-a2d5-8c978b0fbe91)
- Kafka：Apache Kafka 它最初由 LinkedIn 公司基于独特的设计实现为一个分布式的提交日志系统，之后成为 Apache 项目的一部分。号称大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款为大数据而生的消息中间件，以其百万级 TPS 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。
- RabbitMQ：RabbitMQ 2007 年发布，是使用 Erlang 语言开发的开源消息队列系统，基于 AMQP 协议来实现。AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。
- RocketMQ：是阿里开源的消息中间件，它是纯 Java 开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ 思路起源于 Kafka，但并不是 Kafka 的一个 Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog 分发等场景。
- ActiveMQ：是 Apache 出品，以前是最流行的，能力强劲的开源消息队列，现在已经不再热门。官方社区现在对 ActiveMQ 5.x 维护越来越少，较少在大规模吞吐的场景中使用，所以该消息队列也不是我们文章中重点讨论的内容

#### 3.2 Kafka 优缺点

- 优点：
  - 高吞吐、低延迟：kakfa 最大的特点就是收发消息非常快，kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒
  - 高伸缩性：每个主题（ topic ）包含多个分区（ partition ），主题中的分区可以分布在不同的主机（ broker ）中
  - 持久性、可靠性：Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka 底层的数据存储是基于 Zookeeper 存储的，Zookeeper 我们知道它的数据能够持久存储
  - 容错性：非常高，kafka 是分布式的，一个数据多个副本，某个节点宕机，Kafka 集群能够正常工作
  - 消息有序：消费者采用 Pull 方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次
  - 可视化：有优秀的第三方 Kafka Web 管理界面 Kafka-Manager，在日志领域比较成熟，被多家公司和多个开源项目使用
  - 功能支持：功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用
- 缺点：
  - Kafka 单机超过 64 个队列 / 分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长
  - 使用短轮询方式，实时性取决于轮询间隔时间
  - 消费失败不支持重试
  - 支持消息顺序，但是一台代理宕机后，就会产生消息乱序
  - 社区更新较慢
- 总结：
  - Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务
  - 大型公司建议可以选用，如果有日志采集功能，肯定是首选 kafka

#### 3.3 RabbitMQ 优缺点

- 优点：
  - 异步消息传递：支持多种消息协议，消息队列，传送确认，灵活的路由到队列，多种交换类型
  - 支持几乎所有最受欢迎的编程语言：Java，C，C ++，C＃，Ruby，Perl，Python，PHP 等等
  - 可以部署为高可用性和吞吐量的集群，跨多个可用区域和区域进行联合
  - 可插入的身份验证，授权，支持 TLS 和 LDAP
  - 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件
  - 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker，社区活跃度高
- 缺点：
  - erlang 开发，很难去看懂源码，基本职能依赖于开源社区的快速维护和修复 bug，不利于做二次开发和维护
  - RabbitMQ 确实吞吐量会低一些，这是因为他做的实现机制比较重
  - 需要学习比较复杂的接口和协议，学习和维护成本较高
- 总结：
  - 结合 erlang 语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护。不过 RabbitMQ 的社区十分活跃，可以解决开发过程中遇到的 bug
  - 如果你的数据量没有那么大，小公司优先选择功能比较完备的 RabbitMQ

#### 3.4 RocketMQ 优缺点

- 优点：
  - 支持发布/订阅（ Pub / Sub ）和点对点（ P2P ）消息模型
  - 在一个队列中可靠的先进先出（ FIFO ）和严格的顺序传递
  - 支持拉（ pull ）和推（ push ）两种消息模式
  - 单一队列百万消息的堆积能力
  - 支持多种消息协议，如 JMS、MQTT 等
  - 可靠的 FIFO 和严格的有序消息传递在同一队列中
  - 灵活的分布式横向扩展部署架构，满足至少一次消息传递语义
  - 提供 docker 镜像用于隔离测试和云集群部署
  - 提供配置、指标和监控等功能丰富的 Dashboard
- 缺点：
  - 支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟
  - 社区活跃度一般
  - 没有在 mq 核心中去实现 JMS 等接口，有些系统要迁移需要修改大量代码
- 总结：
  - 天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况
  - RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。

#### 3.5 ActiveMQ 优缺点

- 优点
  - 支持来自 Java，C，C ++，C＃，Ruby，Perl，Python，PHP 的各种跨语言客户端和协议
  - 完全支持 JMS 客户端和 Message Broker 中的企业集成模式
  - 支持许多高级功能，如消息组，虚拟目标，通配符和复合目标
  - 完全支持 JMS 1.1 和 J2EE 1.4，支持瞬态，持久，事务和 XA 消息
  - Spring 支持，以便 ActiveMQ 可以轻松嵌入到 Spring 应用程序中，并使用 Spring 的 XML 配置机制进行配置
  - 专为高性能集群，客户端 - 服务器，基于对等的通信而设计
  - CXF 和 Axis 支持，以便 ActiveMQ 可以轻松地放入这些 Web 服务堆栈中以提供可靠的消息传递
  - 可以用作内存 JMS 提供程序，非常适合单元测试 JMS
  - 支持可插拔传输协议，例如 in-VM，TCP，SSL，NIO，UDP，多播，JGroups 和 JXTA 传输
  - 使用 JDBC 和高性能日志支持非常快速的持久性
- 缺点:
  - 官方社区现在对 ActiveMQ 5.x 维护越来越少，较少在大规模吞吐的场景中使用
