## 1. 背景

#### 1.1 安全背景

- **密码存储方式**
  - 系统通常存储密码的哈希值，如 MD5，SHA-1，SHA-256 等，而非明文密码
  - 哈希函数是单向的，理论上无法从哈希值反推原始密码
- **攻击目标**
  - 攻击者获取了数据库中的密码哈希值，例如通过 SQL 注入、数据泄露，目标是找出这些哈希值对应的原始明文密码

#### 1.2 传统方法

- **暴力破解**
  - 尝试所有可能的密码组合，如 a，aa，ab，...，password1，P@ssw0rd!，计算其哈希并与目标哈希比较。计算量巨大，尤其密码较长或复杂时几乎不可行
- **预计算哈希表**
  - 预先计算并存储海量（ 如数十亿 ）常用密码及其对应的哈希值，攻击时直接查表匹配哈希值即可得到密码
  - 但存储所有可能的密码哈希需要巨大的存储空间，例如，包含所有 1-8 字符 MD5 哈希的表可能需要数百 TB 到 PB 级别

## 2. 彩虹表攻击

#### 2.1 基础概念

- **彩虹表攻击 是专门用于 破解密码哈希值 的技术，目的是从 泄露的哈希值 中还原出 原始的明文密码**
- 本质 是一种 **时间-内存** 的权衡策略，通过牺牲一部分计算时间来换取存储空间的大幅减少，同时保持较高的破解效率，它避免了 纯粹的暴力破解 和 纯粹的预计算存储
- 核心 是彩虹表在预计算阶段做大量工作，生成一种特殊的、链式结构的数据表，这个表比存储所有明文-哈希对的表小得多（ 可能只有几个 GB 到 TB ），但破解时仍能保持相对较高的效率
- 彩虹表的核心创新在于使用 约简函数 和 链

#### 2.2 约简函数

- 作用 是将一个哈希值映射回密码空间中的一个可能密码，但它并不是哈希函数的逆运算，因为哈希是单向的
- 例如
  - 假设密码是 8 位数字，哈希值 H 是一个很长的十六进制字符串（ 如 32 字符的 MD5 ）
  - 约简函数 R 可以设计为，取 H 的前 8 个字符，将其解释为一个数字，可能需要模运算或映射规则确保在有效密码范围内，那么结果就是一个 8 位数字的 “密码”
- R 函数的结果是确定性的（ 对同一个 H 总是产生同一个 P ），但不是唯一的（ 多个不同的 H 可能映射到同一个 P ），它只是 “压缩” 或 “转换” 哈希值回密码空间的一种方式

#### 2.3 链

- 链是通过在 起点密码 上反复应用 哈希函数（ 一个彩虹表中使用一种哈希函数 ）和 约简函数 生成的，一条链不是存储单个密码及其哈希，而是存储 一个起点密码 和 一个终点哈希
- 在传统 Hellman 链中，每条链使用同一个约简函数 R，这会导致一个问题，不同的链可能在中间点发生碰撞（ 不同的起点密码经过若干次迭代后产生了相同的中间密码 ），导致链合并，浪费存储空间（ 两条链最终有部分存储了相同的覆盖范围 ）
- 彩虹表使用了一种优化，称为 “彩虹链”，其解决方案是
  - 在一条链的不同位置使用不同的约简函数序列（ $R_1$, $R_2$, ..., $R_k$ ）。想象一下，每个迭代步骤使用不同颜色的约简函数，就像彩虹的不同颜色一样
  - 这样，即使两个密码在某个步骤通过 $R_i$ 映射到同一个值，但在下一步使用 $R_{i+1}$（ 一个不同的函数 ）时，它们又很可能分道扬镳，大大减少了链合并的可能性。这使得彩虹表比传统的 Hellman 表效率更高，存储空间利用更充分

## 3. 预计算阶段

- 选择起点密码
  - 随机选择或按规则生成大量的起点密码，如 a，aa，ab，...，password1，P@ssw0rd!（ 数百万到数十亿条 ）
- 构建链
  - 对每个起点密码，执行以下操作 k 次（ k 是链的长度，例如 10000 ），生成大量的链
    - 步骤 1：哈希，计算当前密码的哈希值，$H_j$ = $Hash(P_j)$
    - 步骤 2：约简，应用约简函数 R 到哈希值，得到一个新的 “密码”，$P_{j+1}$ = $R(H_j)$
    - 下一次迭代使用 $P_{j+1}$ 作为 “当前密码”
    - 经过 k 次迭代后，得到链的终点哈希值 $EP_i$
- 存储端点
  - **在彩虹表中，只存储这条链的起点密码 $SP_i$ 和终点哈希值 $EP_i$，链中间的所有密码和哈希值都不存储**
- 排序
  - 将生成的 (SP, EP) 对按照终点哈希值 EP 进行排序，以优化后续查找速度

## 4. 攻击阶段

- 假设攻击者获得了一个目标哈希值 TargetHash，我们需要在彩虹表中查找是否有对应存在的明文密码
- 本质就是，**遍历 k 次，第 i 次遍历时，查找 n 个链表的第 $(k-i)$ 个节点，如果匹配，那么重新走一次该链表 j，它的第 $(k-i-1)$ 个节点就是我们要找的原始明文密码**
- 那么如何知道是否匹配第 $(k-i)$ 个节点
  - 可以通过 $H_1 = Hash(R(TargetHash))$，...，$H_i = Hash(R(H_{i-1}))$，如果 $H_i$ 等于 EP 列中的某个值，则说明找到了匹配项 $(k-i)$
- 如果回溯了 k 次仍未在 EP 列中找到匹配，则说明该目标哈希值 TargetHash 没有包含在当前使用的彩虹表中，破解失败

## 5. 避免彩虹表攻击

#### 5.1 加盐

- 原理
  - 盐是一个随机生成的、每个用户唯一的字符串（ 或字节序列 ），盐值通常以明文形式与哈希值一起存储在数据库中
  - 在存储密码哈希前，将盐附加（ 或前置 ）到用户密码上，然后对整个（ 密码 + 盐 ）进行哈希：StoredHash = Hash(Password + Salt)
- 效果：盐彻底破坏了彩虹表的预计算优势
  - 随机性
    - 即使两个用户使用相同的密码，由于盐不同，他们的 (Password + Salt) 不同，最终的哈希值也完全不同
  - 攻击失效
    - 攻击者获取了 StoredHash 和对应的 Salt。为了破解这个密码，攻击者需要为 这个特定的盐值 重新计算彩虹表或进行暴力破解
    - 因为彩虹表是针对无盐哈希预计算的（ 或者针对某个固定盐预计算的 ），它无法直接用于破解加了随机盐的哈希。为每个盐值重新计算彩虹表的代价等同于暴力破解，完全失去了彩虹表的意义

#### 5.2 慢哈希函数

- 原理
  - 使用设计上计算缓慢且消耗大量资源（ 内存、CPU ）的哈希函数，如 bcrypt, scrypt, Argon2, PBKDF2
  - 这些函数内部会进行成千上万次迭代，并可能消耗大量内存
- 效果：极大地增加了计算单个密码哈希值所需的时间和资源
  - 预计算代价剧增：
    - 生成覆盖相同密码空间的彩虹表所需的时间变得极其漫长（ 可能是数百年甚至更长 ），存储空间需求也可能剧增（ 对于 scrypt, Argon2 ）
  - 破解速度剧降
    - 即使使用彩虹表，在破解阶段重新计算链（ 这是破解成功必须的步骤 ）也变得非常缓慢。攻击者每秒能测试的密码数量从数百万（ MD5/SHA-1 ）骤降到几百甚至几十个，使得大规模破解变得不切实际

#### 5.3 更复杂的强密码

- 彩虹表只覆盖了其生成时指定的密码空间（ 如所有 1-8 位字母数字组合 ），对于非常长、非常复杂、或者包含特殊字符且不在其覆盖范围内的密码，彩虹表无能为力